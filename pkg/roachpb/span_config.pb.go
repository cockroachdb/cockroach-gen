// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/span_config.proto

package roachpb

import (
	fmt "fmt"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	errorspb "github.com/cockroachdb/errors/errorspb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Constraint_Type int32

const (
	// REQUIRED ensures all replicas are placed on stores with locality tags
	// that match the constraint. Replication will fail if there aren't any such
	// stores.
	Constraint_REQUIRED Constraint_Type = 0
	// PROHIBITED prevents replicas from being placed on stores with locality
	// tags that match the constrain.
	Constraint_PROHIBITED Constraint_Type = 1
)

var Constraint_Type_name = map[int32]string{
	0: "REQUIRED",
	1: "PROHIBITED",
}

var Constraint_Type_value = map[string]int32{
	"REQUIRED":   0,
	"PROHIBITED": 1,
}

func (x Constraint_Type) String() string {
	return proto.EnumName(Constraint_Type_name, int32(x))
}

func (Constraint_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{2, 0}
}

// GCPolicy dictates the garbage collection policy to apply over a given span.
type GCPolicy struct {
	// TTLSeconds is the number of seconds overwritten values will be retained
	// before garbage collection. A value <= 0 means older versions are never
	// GC-ed.
	TTLSeconds int32 `protobuf:"varint,1,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	// ProtectionPolicies is a list of policies that dictate GC behavior for a
	// range (in conjunction with the GC TTL). A ProtectionPolicy can be used
	// to indicate a timestamp above which GC should not run, regardless of the
	// GC TTL. The data it applies over is guaranteed to not be GC-ed provided it
	// wasn't GC-ed before the config applied.
	ProtectionPolicies []ProtectionPolicy `protobuf:"bytes,2,rep,name=protection_policies,json=protectionPolicies,proto3" json:"protection_policies"`
	// IgnoreStrictEnforcement is used to selectively opt out of strict GC TTL
	// enforcement (where requests served at timestamps below the TTL are made to
	// fail, even if the data exists).
	IgnoreStrictEnforcement bool `protobuf:"varint,3,opt,name=ignore_strict_enforcement,json=ignoreStrictEnforcement,proto3" json:"ignore_strict_enforcement,omitempty"`
}

func (m *GCPolicy) Reset()         { *m = GCPolicy{} }
func (m *GCPolicy) String() string { return proto.CompactTextString(m) }
func (*GCPolicy) ProtoMessage()    {}
func (*GCPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{0}
}
func (m *GCPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPolicy.Merge(m, src)
}
func (m *GCPolicy) XXX_Size() int {
	return m.Size()
}
func (m *GCPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_GCPolicy proto.InternalMessageInfo

// ProtectionPolicy dictates a protection policy against garbage collection that
// applies over a given span.
type ProtectionPolicy struct {
	// ProtectedTimestamp is a timestamp above which GC should not run, regardless
	// of the GC TTL.
	ProtectedTimestamp hlc.Timestamp `protobuf:"bytes,1,opt,name=protected_timestamp,json=protectedTimestamp,proto3" json:"protected_timestamp"`
	// IgnoreIfExcludedFromBackup is set to true if the ProtectionPolicy can be
	// ignored when making GC decisions on a span that has been marked to be
	// excluded from backups i.e. the applied SpanConfig has
	// `exclude_data_from_backup = true`.
	//
	// This field is currently only set to true when a protected timestamp record
	// has been written by a backup schedule or job. This is to ensure that
	// ProtectionPolicies written by non-backup users (CDC, streaming) on spans
	// marked as `exclude_data_from_backup` are still respected when making GC
	// decisions on the span.
	IgnoreIfExcludedFromBackup bool `protobuf:"varint,2,opt,name=ignore_if_excluded_from_backup,json=ignoreIfExcludedFromBackup,proto3" json:"ignore_if_excluded_from_backup,omitempty"`
}

func (m *ProtectionPolicy) Reset()      { *m = ProtectionPolicy{} }
func (*ProtectionPolicy) ProtoMessage() {}
func (*ProtectionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{1}
}
func (m *ProtectionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtectionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtectionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtectionPolicy.Merge(m, src)
}
func (m *ProtectionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ProtectionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtectionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ProtectionPolicy proto.InternalMessageInfo

// Constraint constrains the stores that a replica can be stored on. It
// parallels the definition found in zonepb/zone.proto.
type Constraint struct {
	// Type captures the kind of constraint this is: required or prohibited.
	Type Constraint_Type `protobuf:"varint,1,opt,name=type,proto3,enum=cockroach.roachpb.Constraint_Type" json:"type,omitempty"`
	// Key captures the locality tag key we're constraining against.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Value is the locality tag value we're constraining against.
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Constraint) Reset()      { *m = Constraint{} }
func (*Constraint) ProtoMessage() {}
func (*Constraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{2}
}
func (m *Constraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Constraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Constraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Constraint.Merge(m, src)
}
func (m *Constraint) XXX_Size() int {
	return m.Size()
}
func (m *Constraint) XXX_DiscardUnknown() {
	xxx_messageInfo_Constraint.DiscardUnknown(m)
}

var xxx_messageInfo_Constraint proto.InternalMessageInfo

// ConstraintsConjunction is the set of constraints that need to be satisfied
// together by replicas. It parallels the definition found in zonepb/zone.proto.
type ConstraintsConjunction struct {
	// NumReplicas is the number of replicas that should abide by the constraints
	// below. If set to zero, the constraints will apply to all replicas of the
	// range.
	//
	// NB: Only REQUIRED constraints are allowed when the number of replicas is
	// non-zero.
	NumReplicas int32 `protobuf:"varint,1,opt,name=num_replicas,json=numReplicas,proto3" json:"num_replicas,omitempty"`
	// Constraints is the set that needs to be satisfied by the store in order for
	// us to place replicas on it.
	Constraints []Constraint `protobuf:"bytes,2,rep,name=constraints,proto3" json:"constraints"`
}

func (m *ConstraintsConjunction) Reset()      { *m = ConstraintsConjunction{} }
func (*ConstraintsConjunction) ProtoMessage() {}
func (*ConstraintsConjunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{3}
}
func (m *ConstraintsConjunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintsConjunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintsConjunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintsConjunction.Merge(m, src)
}
func (m *ConstraintsConjunction) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintsConjunction) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintsConjunction.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintsConjunction proto.InternalMessageInfo

// LeasePreference specifies a preference about where range leases should be
// located. It parallels the definition found in zonepb/zone.proto.
type LeasePreference struct {
	// Constraints is the set that needs to be satisfied by the store in order for
	// us to prefer placing leases on it.
	Constraints []Constraint `protobuf:"bytes,1,rep,name=constraints,proto3" json:"constraints"`
}

func (m *LeasePreference) Reset()         { *m = LeasePreference{} }
func (m *LeasePreference) String() string { return proto.CompactTextString(m) }
func (*LeasePreference) ProtoMessage()    {}
func (*LeasePreference) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{4}
}
func (m *LeasePreference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeasePreference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeasePreference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeasePreference.Merge(m, src)
}
func (m *LeasePreference) XXX_Size() int {
	return m.Size()
}
func (m *LeasePreference) XXX_DiscardUnknown() {
	xxx_messageInfo_LeasePreference.DiscardUnknown(m)
}

var xxx_messageInfo_LeasePreference proto.InternalMessageInfo

// SpanConfig holds the configuration that applies to a given keyspan. It is a
// superset of the fields found in zonepb.zone.proto.
type SpanConfig struct {
	// RangeMinBytes is the minimum size, in bytes, a range can have. When a range
	// is less than this size, it'll be merged with an adjacent range.
	RangeMinBytes int64 `protobuf:"varint,1,opt,name=range_min_bytes,json=rangeMinBytes,proto3" json:"range_min_bytes,omitempty"`
	// RangeMaxBytes is the maximum size, in bytes, a range can have. When a range
	// is more than this size, it'll split into two ranges.
	RangeMaxBytes int64 `protobuf:"varint,2,opt,name=range_max_bytes,json=rangeMaxBytes,proto3" json:"range_max_bytes,omitempty"`
	// GCPolicy dictates the the GC policy to apply over a range.
	GCPolicy GCPolicy `protobuf:"bytes,3,opt,name=gc_policy,json=gcPolicy,proto3" json:"gc_policy"`
	// GlobalReads specifies whether transactions operating over the range(s)
	// should be configured to provide non-blocking behavior, meaning that reads
	// can be served consistently from all replicas and do not block on writes. In
	// exchange, writes get pushed into the future and must wait on commit to
	// ensure linearizability. For more, see #52745.
	GlobalReads bool `protobuf:"varint,4,opt,name=global_reads,json=globalReads,proto3" json:"global_reads,omitempty"`
	// NumReplicas specifies the number of replicas, including both voting and
	// non-voting kinds.
	NumReplicas int32 `protobuf:"varint,5,opt,name=num_replicas,json=numReplicas,proto3" json:"num_replicas,omitempty"`
	// NumVoters specifies the number of voter replicas. If set to zero, we'll
	// consider NumReplicas to be the voter replica count instead (i.e. no
	// non-voting replicas).
	NumVoters int32 `protobuf:"varint,6,opt,name=num_voters,json=numVoters,proto3" json:"num_voters,omitempty"`
	// Constraints constrain which stores the both voting and non-voting replicas
	// can be placed on.
	//
	// NB: The NumReplicas fields in Constraints must either:
	// - add up to at most SpanConfig.NumReplicas (pinning the sum of replicas and
	//   having the rest float freely);
	// - all be zero (applying each constraint to all replicas).
	Constraints []ConstraintsConjunction `protobuf:"bytes,7,rep,name=constraints,proto3" json:"constraints"`
	// VoterConstraints constrains which stores the voting replicas can be placed
	// on. This must be compatible with the Constraints field above, but not
	// necessarily a subset. It's compatible as long as there are no prohibitive
	// constraints above that are required here.
	VoterConstraints []ConstraintsConjunction `protobuf:"bytes,8,rep,name=voter_constraints,json=voterConstraints,proto3" json:"voter_constraints"`
	// LeasePreference captures the preference for how range leases are to be
	// placed. They're allowed to be placed elsewhere if needed, but will follow
	// the stated preferences when possible.
	//
	// More than one lease preference is allowed; they're considered as the most
	// preferred option to least. The first preference that an existing replica of
	// a range matches will take priority for the lease.
	LeasePreferences []LeasePreference `protobuf:"bytes,9,rep,name=lease_preferences,json=leasePreferences,proto3" json:"lease_preferences"`
	// RangefeedEnabled determines whether rangefeeds are enabled over the
	// specific range.
	RangefeedEnabled bool `protobuf:"varint,10,opt,name=rangefeed_enabled,json=rangefeedEnabled,proto3" json:"rangefeed_enabled,omitempty"`
	// ExcludeDataFromBackup specifies if the range has been marked to be excluded
	// from a backup targeting the table represented by this keyspace. This
	// information is used when ExportRequests issued by backups are being
	// serviced in KV, to decide whether or not to send back any row data.
	ExcludeDataFromBackup bool `protobuf:"varint,11,opt,name=exclude_data_from_backup,json=excludeDataFromBackup,proto3" json:"exclude_data_from_backup,omitempty"`
}

func (m *SpanConfig) Reset()         { *m = SpanConfig{} }
func (m *SpanConfig) String() string { return proto.CompactTextString(m) }
func (*SpanConfig) ProtoMessage()    {}
func (*SpanConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{5}
}
func (m *SpanConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfig.Merge(m, src)
}
func (m *SpanConfig) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfig proto.InternalMessageInfo

// SystemSpanConfigTarget specifies the target of system span configurations.
// System targets are designed for a few different kinds of interactions. We
// want the ability to:
// 1. Allow the host tenant to set a system span configuration on the entire
// keyspace.
// 2. Allow the host tenant to set a system span configuration on a particular
// tenant's keyspace.
// 3. Allow secondary tenants to set system span configurations on their
// keyspace.
//
// Additionally, we also want each tenant to be able to fetch all system span
// configurations that it has installed. Ideally, we want to be able to do this
// without knowing the tenantID of all other tenants that exist. We provide a
// read-only system span config target type to achieve exactly this.
type SystemSpanConfigTarget struct {
	// SourceTenantID is the ID of the tenant that specified the system span
	// configuration.
	SourceTenantID TenantID `protobuf:"bytes,1,opt,name=source_tenant_id,json=sourceTenantId,proto3" json:"source_tenant_id"`
	// Type of the system target.
	Type *SystemSpanConfigTarget_Type `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *SystemSpanConfigTarget) Reset()         { *m = SystemSpanConfigTarget{} }
func (m *SystemSpanConfigTarget) String() string { return proto.CompactTextString(m) }
func (*SystemSpanConfigTarget) ProtoMessage()    {}
func (*SystemSpanConfigTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{6}
}
func (m *SystemSpanConfigTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemSpanConfigTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemSpanConfigTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemSpanConfigTarget.Merge(m, src)
}
func (m *SystemSpanConfigTarget) XXX_Size() int {
	return m.Size()
}
func (m *SystemSpanConfigTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemSpanConfigTarget.DiscardUnknown(m)
}

var xxx_messageInfo_SystemSpanConfigTarget proto.InternalMessageInfo

// TenantKeyspace is a target type that targets the keyspace of a specific
// tenant.
type SystemSpanConfigTarget_TenantKeyspace struct {
	// TenantID is the ID of the tenant whose keyspace the the associated
	// system span configuration applies to.
	//
	// Secondary tenants are only allowed to target their keyspace. The host
	// tenant may use this field to target a specific secondary tenant's
	// keyspace.
	TenantID TenantID `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id"`
}

func (m *SystemSpanConfigTarget_TenantKeyspace) Reset()         { *m = SystemSpanConfigTarget_TenantKeyspace{} }
func (m *SystemSpanConfigTarget_TenantKeyspace) String() string { return proto.CompactTextString(m) }
func (*SystemSpanConfigTarget_TenantKeyspace) ProtoMessage()    {}
func (*SystemSpanConfigTarget_TenantKeyspace) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{6, 0}
}
func (m *SystemSpanConfigTarget_TenantKeyspace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemSpanConfigTarget_TenantKeyspace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemSpanConfigTarget_TenantKeyspace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemSpanConfigTarget_TenantKeyspace.Merge(m, src)
}
func (m *SystemSpanConfigTarget_TenantKeyspace) XXX_Size() int {
	return m.Size()
}
func (m *SystemSpanConfigTarget_TenantKeyspace) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemSpanConfigTarget_TenantKeyspace.DiscardUnknown(m)
}

var xxx_messageInfo_SystemSpanConfigTarget_TenantKeyspace proto.InternalMessageInfo

// EntireKeyspace is a target type that targets the entire keyspace (all
// ranges, including those belonging to secondary tenants). Only the host
// tenant is allowed to target the entire keyspace.
type SystemSpanConfigTarget_EntireKeyspace struct {
}

func (m *SystemSpanConfigTarget_EntireKeyspace) Reset()         { *m = SystemSpanConfigTarget_EntireKeyspace{} }
func (m *SystemSpanConfigTarget_EntireKeyspace) String() string { return proto.CompactTextString(m) }
func (*SystemSpanConfigTarget_EntireKeyspace) ProtoMessage()    {}
func (*SystemSpanConfigTarget_EntireKeyspace) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{6, 1}
}
func (m *SystemSpanConfigTarget_EntireKeyspace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemSpanConfigTarget_EntireKeyspace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemSpanConfigTarget_EntireKeyspace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemSpanConfigTarget_EntireKeyspace.Merge(m, src)
}
func (m *SystemSpanConfigTarget_EntireKeyspace) XXX_Size() int {
	return m.Size()
}
func (m *SystemSpanConfigTarget_EntireKeyspace) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemSpanConfigTarget_EntireKeyspace.DiscardUnknown(m)
}

var xxx_messageInfo_SystemSpanConfigTarget_EntireKeyspace proto.InternalMessageInfo

// AllTenantKeyspacesTargetsSet is is a read-only system target type that
// encompasses all system targets that have been set by the source tenant on
// specific tenant's keyspaces.
type SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet struct {
}

func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) Reset() {
	*m = SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet{}
}
func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) String() string {
	return proto.CompactTextString(m)
}
func (*SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) ProtoMessage() {}
func (*SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{6, 2}
}
func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet.Merge(m, src)
}
func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) XXX_Size() int {
	return m.Size()
}
func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet.DiscardUnknown(m)
}

var xxx_messageInfo_SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet proto.InternalMessageInfo

type SystemSpanConfigTarget_Type struct {
	// Types that are valid to be assigned to Type:
	//	*SystemSpanConfigTarget_Type_SpecificTenantKeyspace
	//	*SystemSpanConfigTarget_Type_EntireKeyspace
	//	*SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet
	Type isSystemSpanConfigTarget_Type_Type `protobuf_oneof:"type"`
}

func (m *SystemSpanConfigTarget_Type) Reset()         { *m = SystemSpanConfigTarget_Type{} }
func (m *SystemSpanConfigTarget_Type) String() string { return proto.CompactTextString(m) }
func (*SystemSpanConfigTarget_Type) ProtoMessage()    {}
func (*SystemSpanConfigTarget_Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{6, 3}
}
func (m *SystemSpanConfigTarget_Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemSpanConfigTarget_Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemSpanConfigTarget_Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemSpanConfigTarget_Type.Merge(m, src)
}
func (m *SystemSpanConfigTarget_Type) XXX_Size() int {
	return m.Size()
}
func (m *SystemSpanConfigTarget_Type) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemSpanConfigTarget_Type.DiscardUnknown(m)
}

var xxx_messageInfo_SystemSpanConfigTarget_Type proto.InternalMessageInfo

type isSystemSpanConfigTarget_Type_Type interface {
	isSystemSpanConfigTarget_Type_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SystemSpanConfigTarget_Type_SpecificTenantKeyspace struct {
	SpecificTenantKeyspace *SystemSpanConfigTarget_TenantKeyspace `protobuf:"bytes,1,opt,name=specific_tenant_keyspace,json=specificTenantKeyspace,proto3,oneof" json:"specific_tenant_keyspace,omitempty"`
}
type SystemSpanConfigTarget_Type_EntireKeyspace struct {
	EntireKeyspace *SystemSpanConfigTarget_EntireKeyspace `protobuf:"bytes,2,opt,name=entire_keyspace,json=entireKeyspace,proto3,oneof" json:"entire_keyspace,omitempty"`
}
type SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet struct {
	AllTenantKeyspaceTargetsSet *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet `protobuf:"bytes,3,opt,name=all_tenant_keyspace_targets_set,json=allTenantKeyspaceTargetsSet,proto3,oneof" json:"all_tenant_keyspace_targets_set,omitempty"`
}

func (*SystemSpanConfigTarget_Type_SpecificTenantKeyspace) isSystemSpanConfigTarget_Type_Type() {}
func (*SystemSpanConfigTarget_Type_EntireKeyspace) isSystemSpanConfigTarget_Type_Type()         {}
func (*SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet) isSystemSpanConfigTarget_Type_Type() {
}

func (m *SystemSpanConfigTarget_Type) GetType() isSystemSpanConfigTarget_Type_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *SystemSpanConfigTarget_Type) GetSpecificTenantKeyspace() *SystemSpanConfigTarget_TenantKeyspace {
	if x, ok := m.GetType().(*SystemSpanConfigTarget_Type_SpecificTenantKeyspace); ok {
		return x.SpecificTenantKeyspace
	}
	return nil
}

func (m *SystemSpanConfigTarget_Type) GetEntireKeyspace() *SystemSpanConfigTarget_EntireKeyspace {
	if x, ok := m.GetType().(*SystemSpanConfigTarget_Type_EntireKeyspace); ok {
		return x.EntireKeyspace
	}
	return nil
}

func (m *SystemSpanConfigTarget_Type) GetAllTenantKeyspaceTargetsSet() *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet {
	if x, ok := m.GetType().(*SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet); ok {
		return x.AllTenantKeyspaceTargetsSet
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SystemSpanConfigTarget_Type) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SystemSpanConfigTarget_Type_SpecificTenantKeyspace)(nil),
		(*SystemSpanConfigTarget_Type_EntireKeyspace)(nil),
		(*SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet)(nil),
	}
}

// SpanConfigTarget specifies the target of an associated span configuration.
type SpanConfigTarget struct {
	// Types that are valid to be assigned to Union:
	//	*SpanConfigTarget_Span
	//	*SpanConfigTarget_SystemSpanConfigTarget
	Union isSpanConfigTarget_Union `protobuf_oneof:"union"`
}

func (m *SpanConfigTarget) Reset()         { *m = SpanConfigTarget{} }
func (m *SpanConfigTarget) String() string { return proto.CompactTextString(m) }
func (*SpanConfigTarget) ProtoMessage()    {}
func (*SpanConfigTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{7}
}
func (m *SpanConfigTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigTarget.Merge(m, src)
}
func (m *SpanConfigTarget) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigTarget.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigTarget proto.InternalMessageInfo

type isSpanConfigTarget_Union interface {
	isSpanConfigTarget_Union()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SpanConfigTarget_Span struct {
	Span *Span `protobuf:"bytes,1,opt,name=span,proto3,oneof" json:"span,omitempty"`
}
type SpanConfigTarget_SystemSpanConfigTarget struct {
	SystemSpanConfigTarget *SystemSpanConfigTarget `protobuf:"bytes,2,opt,name=system_span_config_target,json=systemSpanConfigTarget,proto3,oneof" json:"system_span_config_target,omitempty"`
}

func (*SpanConfigTarget_Span) isSpanConfigTarget_Union()                   {}
func (*SpanConfigTarget_SystemSpanConfigTarget) isSpanConfigTarget_Union() {}

func (m *SpanConfigTarget) GetUnion() isSpanConfigTarget_Union {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *SpanConfigTarget) GetSpan() *Span {
	if x, ok := m.GetUnion().(*SpanConfigTarget_Span); ok {
		return x.Span
	}
	return nil
}

func (m *SpanConfigTarget) GetSystemSpanConfigTarget() *SystemSpanConfigTarget {
	if x, ok := m.GetUnion().(*SpanConfigTarget_SystemSpanConfigTarget); ok {
		return x.SystemSpanConfigTarget
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SpanConfigTarget) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SpanConfigTarget_Span)(nil),
		(*SpanConfigTarget_SystemSpanConfigTarget)(nil),
	}
}

// SpanConfigEntry ties a span to its corresponding config.
type SpanConfigEntry struct {
	// Target specifies the target the config applies over.
	Target SpanConfigTarget `protobuf:"bytes,3,opt,name=target,proto3" json:"target"`
	// Config is the set of attributes that apply over the corresponding target.
	Config SpanConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config"`
}

func (m *SpanConfigEntry) Reset()         { *m = SpanConfigEntry{} }
func (m *SpanConfigEntry) String() string { return proto.CompactTextString(m) }
func (*SpanConfigEntry) ProtoMessage()    {}
func (*SpanConfigEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{8}
}
func (m *SpanConfigEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigEntry.Merge(m, src)
}
func (m *SpanConfigEntry) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigEntry proto.InternalMessageInfo

// GetSpanConfigsRequest is used to fetch the span configurations and system
// span configurations.
type GetSpanConfigsRequest struct {
	// Targets to request configurations for. The targets listed here are not
	// allowed to be duplicated/overlap with one another.
	Targets []SpanConfigTarget `protobuf:"bytes,2,rep,name=targets,proto3" json:"targets"`
}

func (m *GetSpanConfigsRequest) Reset()         { *m = GetSpanConfigsRequest{} }
func (m *GetSpanConfigsRequest) String() string { return proto.CompactTextString(m) }
func (*GetSpanConfigsRequest) ProtoMessage()    {}
func (*GetSpanConfigsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{9}
}
func (m *GetSpanConfigsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpanConfigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpanConfigsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpanConfigsRequest.Merge(m, src)
}
func (m *GetSpanConfigsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSpanConfigsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpanConfigsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpanConfigsRequest proto.InternalMessageInfo

// GetSpanConfigsResponse lists out the span configurations and system span
// configurations that have been requested.
type GetSpanConfigsResponse struct {
	// SpanConfigEntries capture the span configurations over the requested spans.
	// The results for each Span in the matching GetSpanConfigsRequest are
	// flattened out into a single slice, and follow the same ordering. It's
	// possible for there to be no configurations for a given span; there'll
	// simply be no entries for it.
	//
	// Any system span configurations set by the tenant are also returned if
	// requested.
	SpanConfigEntries []SpanConfigEntry `protobuf:"bytes,1,rep,name=span_config_entries,json=spanConfigEntries,proto3" json:"span_config_entries"`
}

func (m *GetSpanConfigsResponse) Reset()         { *m = GetSpanConfigsResponse{} }
func (m *GetSpanConfigsResponse) String() string { return proto.CompactTextString(m) }
func (*GetSpanConfigsResponse) ProtoMessage()    {}
func (*GetSpanConfigsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{10}
}
func (m *GetSpanConfigsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpanConfigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpanConfigsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpanConfigsResponse.Merge(m, src)
}
func (m *GetSpanConfigsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSpanConfigsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpanConfigsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpanConfigsResponse proto.InternalMessageInfo

// UpdateSpanConfigsRequest is used to update the span configurations and system
// span configurations over the given targets.
//
// This is a "targeted" API: the targets being deleted are expected to have been
// present exactly as specified. The same is true for targets being upserted with
// new configs. If targets aren't present, an error is returned.
//
// Adding configurations that target a span are expected to not overlap with any
// existing spans. When divvying up an existing span into multiple others,
// callers are expected to delete the old and upsert the new ones. This can
// happen as part of the same request, as we delete targets marked for deletion
// before upserting what was requested.
//
// Targets are not allowed to overlap with other targets in the same list. They
// are, however, allowed to overlap across lists. This is necessary to support
// the delete+upsert semantics described above.
//
// All delete/upsert updates are performed atomically at a timestamp within the
// [LeaseStartTime, LeaseExpirationTime) supplied. Typically, this corresponds
// to the lease interval of the auto span config reconciliation job issuing the
// request. If the updates can't be performed within the specified lease
// interval, an encoded retryableLeaseExpiredError is returned in the response.
type UpdateSpanConfigsRequest struct {
	// ToDelete captures the targets we want to delete configs for.
	ToDelete []SpanConfigTarget `protobuf:"bytes,3,rep,name=to_delete,json=toDelete,proto3" json:"to_delete"`
	// ToUpsert captures the targets we want to upsert and the configs we want
	// to upsert with.
	ToUpsert []SpanConfigEntry `protobuf:"bytes,4,rep,name=to_upsert,json=toUpsert,proto3" json:"to_upsert"`
	// LeaseStartTime is the lease start timestamp of the request issuer.
	// Typically, this is the lease start time of the auto span config
	// reconciliation job.
	LeaseStartTime hlc.Timestamp `protobuf:"bytes,6,opt,name=lease_start_time,json=leaseStartTime,proto3" json:"lease_start_time"`
	// LeaseExpirationTime is the lease expiration timestamp of the request
	// issuer. Typically, this is the lease expiration time of the auto span
	// config reconciliation job.
	LeaseExpirationTime hlc.Timestamp `protobuf:"bytes,5,opt,name=lease_expiration_time,json=leaseExpirationTime,proto3" json:"lease_expiration_time"`
}

func (m *UpdateSpanConfigsRequest) Reset()         { *m = UpdateSpanConfigsRequest{} }
func (m *UpdateSpanConfigsRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateSpanConfigsRequest) ProtoMessage()    {}
func (*UpdateSpanConfigsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{11}
}
func (m *UpdateSpanConfigsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSpanConfigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UpdateSpanConfigsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSpanConfigsRequest.Merge(m, src)
}
func (m *UpdateSpanConfigsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSpanConfigsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSpanConfigsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSpanConfigsRequest proto.InternalMessageInfo

type UpdateSpanConfigsResponse struct {
	// This field stores any error that occurs on the server, allowing us to
	// differentiate between those and RPC errors.
	Error errorspb.EncodedError `protobuf:"bytes,1,opt,name=error,proto3" json:"error"`
}

func (m *UpdateSpanConfigsResponse) Reset()         { *m = UpdateSpanConfigsResponse{} }
func (m *UpdateSpanConfigsResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateSpanConfigsResponse) ProtoMessage()    {}
func (*UpdateSpanConfigsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{12}
}
func (m *UpdateSpanConfigsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSpanConfigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UpdateSpanConfigsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSpanConfigsResponse.Merge(m, src)
}
func (m *UpdateSpanConfigsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSpanConfigsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSpanConfigsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSpanConfigsResponse proto.InternalMessageInfo

// GetAllSystemSpanConfigsThatApplyRequest is used to fetch all system span
// configs that apply to a given tenant. For a specific tenant range, this
// includes:
// 1. The system span config that applies over the entire keyspace (set by the
// host).
// 2. The system span config set by the host over just the tenant's keyspace.
// 3. The system span config set by the tenant over its own keyspace.
//
// This RPC is only ever meaningful in the context of secondary tenants as it
// allows them a view into system span config state that applies over their
// ranges that has been set by the host tenant.
//
// Tenants are only allowed to request system span configs that apply over their
// own ranges. System span configs set by the requesting tenant itself are also
// returned.
type GetAllSystemSpanConfigsThatApplyRequest struct {
	// TenantID identifies tenant ranges over which all system span configurations
	// that apply are being requested. Given tenants are only allowed to fetch
	// system span configs that apply over their ranges, we expect this field to
	// be set to the requesting tenant's ID.
	TenantID TenantID `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id"`
}

func (m *GetAllSystemSpanConfigsThatApplyRequest) Reset() {
	*m = GetAllSystemSpanConfigsThatApplyRequest{}
}
func (m *GetAllSystemSpanConfigsThatApplyRequest) String() string { return proto.CompactTextString(m) }
func (*GetAllSystemSpanConfigsThatApplyRequest) ProtoMessage()    {}
func (*GetAllSystemSpanConfigsThatApplyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{13}
}
func (m *GetAllSystemSpanConfigsThatApplyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAllSystemSpanConfigsThatApplyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetAllSystemSpanConfigsThatApplyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAllSystemSpanConfigsThatApplyRequest.Merge(m, src)
}
func (m *GetAllSystemSpanConfigsThatApplyRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAllSystemSpanConfigsThatApplyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAllSystemSpanConfigsThatApplyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAllSystemSpanConfigsThatApplyRequest proto.InternalMessageInfo

// GetAllSystemSpanConfigsThatApplyResponse lists out all system span
// configurations that have been requested.
type GetAllSystemSpanConfigsThatApplyResponse struct {
	// SpanConfigs captures all system span configurations that apply over the
	// requested tenant IDs' ranges.
	SpanConfigs []SpanConfig `protobuf:"bytes,1,rep,name=span_configs,json=spanConfigs,proto3" json:"span_configs"`
}

func (m *GetAllSystemSpanConfigsThatApplyResponse) Reset() {
	*m = GetAllSystemSpanConfigsThatApplyResponse{}
}
func (m *GetAllSystemSpanConfigsThatApplyResponse) String() string { return proto.CompactTextString(m) }
func (*GetAllSystemSpanConfigsThatApplyResponse) ProtoMessage()    {}
func (*GetAllSystemSpanConfigsThatApplyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{14}
}
func (m *GetAllSystemSpanConfigsThatApplyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAllSystemSpanConfigsThatApplyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetAllSystemSpanConfigsThatApplyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAllSystemSpanConfigsThatApplyResponse.Merge(m, src)
}
func (m *GetAllSystemSpanConfigsThatApplyResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAllSystemSpanConfigsThatApplyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAllSystemSpanConfigsThatApplyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAllSystemSpanConfigsThatApplyResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.roachpb.Constraint_Type", Constraint_Type_name, Constraint_Type_value)
	proto.RegisterType((*GCPolicy)(nil), "cockroach.roachpb.GCPolicy")
	proto.RegisterType((*ProtectionPolicy)(nil), "cockroach.roachpb.ProtectionPolicy")
	proto.RegisterType((*Constraint)(nil), "cockroach.roachpb.Constraint")
	proto.RegisterType((*ConstraintsConjunction)(nil), "cockroach.roachpb.ConstraintsConjunction")
	proto.RegisterType((*LeasePreference)(nil), "cockroach.roachpb.LeasePreference")
	proto.RegisterType((*SpanConfig)(nil), "cockroach.roachpb.SpanConfig")
	proto.RegisterType((*SystemSpanConfigTarget)(nil), "cockroach.roachpb.SystemSpanConfigTarget")
	proto.RegisterType((*SystemSpanConfigTarget_TenantKeyspace)(nil), "cockroach.roachpb.SystemSpanConfigTarget.TenantKeyspace")
	proto.RegisterType((*SystemSpanConfigTarget_EntireKeyspace)(nil), "cockroach.roachpb.SystemSpanConfigTarget.EntireKeyspace")
	proto.RegisterType((*SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet)(nil), "cockroach.roachpb.SystemSpanConfigTarget.AllTenantKeyspaceTargetsSet")
	proto.RegisterType((*SystemSpanConfigTarget_Type)(nil), "cockroach.roachpb.SystemSpanConfigTarget.Type")
	proto.RegisterType((*SpanConfigTarget)(nil), "cockroach.roachpb.SpanConfigTarget")
	proto.RegisterType((*SpanConfigEntry)(nil), "cockroach.roachpb.SpanConfigEntry")
	proto.RegisterType((*GetSpanConfigsRequest)(nil), "cockroach.roachpb.GetSpanConfigsRequest")
	proto.RegisterType((*GetSpanConfigsResponse)(nil), "cockroach.roachpb.GetSpanConfigsResponse")
	proto.RegisterType((*UpdateSpanConfigsRequest)(nil), "cockroach.roachpb.UpdateSpanConfigsRequest")
	proto.RegisterType((*UpdateSpanConfigsResponse)(nil), "cockroach.roachpb.UpdateSpanConfigsResponse")
	proto.RegisterType((*GetAllSystemSpanConfigsThatApplyRequest)(nil), "cockroach.roachpb.GetAllSystemSpanConfigsThatApplyRequest")
	proto.RegisterType((*GetAllSystemSpanConfigsThatApplyResponse)(nil), "cockroach.roachpb.GetAllSystemSpanConfigsThatApplyResponse")
}

func init() { proto.RegisterFile("roachpb/span_config.proto", fileDescriptor_91c9f1dcea14470a) }

var fileDescriptor_91c9f1dcea14470a = []byte{
	// 1369 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xf7, 0x3a, 0x76, 0xe2, 0x3c, 0x07, 0xc7, 0x99, 0x36, 0xa9, 0x93, 0x2a, 0x76, 0xea, 0x22,
	0x48, 0x85, 0x70, 0xa4, 0x20, 0x01, 0x0a, 0x5c, 0xe2, 0x64, 0xdb, 0xa4, 0xb4, 0x22, 0x5d, 0x3b,
	0xfc, 0xa9, 0x80, 0xd5, 0x78, 0xf7, 0xd9, 0x59, 0xb2, 0x9e, 0x5d, 0x76, 0xc6, 0x55, 0x7c, 0xe4,
	0x0e, 0x12, 0x37, 0x38, 0x70, 0xe8, 0x67, 0xe0, 0x84, 0xf8, 0x04, 0x3d, 0xf6, 0xd8, 0x4b, 0x2b,
	0x48, 0x38, 0xf0, 0x2d, 0x40, 0x3b, 0x3b, 0xb6, 0xd7, 0x8e, 0xeb, 0x26, 0x15, 0xb7, 0xdd, 0xf7,
	0xe7, 0xf7, 0x7e, 0xef, 0x37, 0x6f, 0x66, 0x67, 0x61, 0x39, 0xf0, 0xa8, 0x75, 0xe4, 0x37, 0x36,
	0xb8, 0x4f, 0x99, 0x69, 0x79, 0xac, 0xe9, 0xb4, 0x2a, 0x7e, 0xe0, 0x09, 0x8f, 0x2c, 0x58, 0x9e,
	0x75, 0x2c, 0xdd, 0x15, 0x15, 0xb4, 0xb2, 0x88, 0x41, 0xe0, 0x05, 0xdc, 0x6f, 0x6c, 0x44, 0x0f,
	0x51, 0xe4, 0x0a, 0xe9, 0x81, 0xd8, 0x54, 0x50, 0x65, 0xbb, 0xda, 0xf2, 0x5a, 0x9e, 0x7c, 0xdc,
	0x08, 0x9f, 0x94, 0xb5, 0xd0, 0x11, 0x8e, 0xbb, 0x71, 0xe4, 0x5a, 0x1b, 0xc2, 0x69, 0x23, 0x17,
	0xb4, 0xed, 0x47, 0x9e, 0xf2, 0x73, 0x0d, 0x32, 0x77, 0x76, 0x0e, 0x3c, 0xd7, 0xb1, 0xba, 0x64,
	0x03, 0xb2, 0x42, 0xb8, 0x26, 0x47, 0xcb, 0x63, 0x36, 0x2f, 0x68, 0x6b, 0xda, 0x7a, 0xba, 0x9a,
	0x3b, 0x7d, 0x51, 0x82, 0x7a, 0xfd, 0x5e, 0x2d, 0xb2, 0x1a, 0x20, 0x84, 0xab, 0x9e, 0xc9, 0x43,
	0xb8, 0x12, 0xc2, 0xa0, 0x25, 0x1c, 0x8f, 0x99, 0x7e, 0x88, 0xe2, 0x20, 0x2f, 0x24, 0xd7, 0xa6,
	0xd6, 0xb3, 0x9b, 0x37, 0x2b, 0xe7, 0x3a, 0xa9, 0x1c, 0xf4, 0xa3, 0xa3, 0x92, 0xd5, 0xd4, 0x93,
	0x17, 0xa5, 0x84, 0x41, 0xfc, 0x61, 0xbb, 0x83, 0x9c, 0x6c, 0xc1, 0xb2, 0xd3, 0x62, 0x5e, 0x80,
	0x26, 0x17, 0x81, 0x63, 0x09, 0x13, 0x59, 0xd3, 0x0b, 0x2c, 0x6c, 0x23, 0x13, 0x85, 0xa9, 0x35,
	0x6d, 0x3d, 0x63, 0x5c, 0x8b, 0x02, 0x6a, 0xd2, 0xaf, 0x0f, 0xdc, 0x5b, 0x99, 0xdf, 0x1f, 0x97,
	0xb4, 0x7f, 0x1e, 0x97, 0xb4, 0xf2, 0x1f, 0x1a, 0xe4, 0x47, 0x8b, 0x92, 0x7a, 0x9f, 0x36, 0xda,
	0x66, 0x5f, 0x11, 0xd9, 0x6f, 0x76, 0x73, 0x35, 0x46, 0x3b, 0x94, 0xad, 0x72, 0xe4, 0x5a, 0x95,
	0x7a, 0x2f, 0x68, 0x84, 0x30, 0xda, 0x7d, 0x0f, 0xa9, 0x42, 0x51, 0x11, 0x76, 0x9a, 0x26, 0x9e,
	0x58, 0x6e, 0xc7, 0x46, 0xdb, 0x6c, 0x06, 0x5e, 0xdb, 0x6c, 0x50, 0xeb, 0xb8, 0xe3, 0x17, 0x92,
	0x92, 0xf5, 0x4a, 0x14, 0xb5, 0xdf, 0xd4, 0x55, 0xcc, 0xed, 0xc0, 0x6b, 0x57, 0x65, 0xc4, 0xd6,
	0xdc, 0x2f, 0x8f, 0x4b, 0x89, 0x3e, 0xf9, 0x5f, 0x35, 0x80, 0x1d, 0x8f, 0x71, 0x11, 0x50, 0x87,
	0x09, 0xf2, 0x3e, 0xa4, 0x44, 0xd7, 0x47, 0xc9, 0x33, 0xb7, 0x59, 0x1e, 0x23, 0xef, 0x20, 0xb8,
	0x52, 0xef, 0xfa, 0x68, 0xc8, 0x78, 0x92, 0x87, 0xa9, 0x63, 0xec, 0xca, 0xea, 0xb3, 0x46, 0xf8,
	0x48, 0xae, 0x42, 0xfa, 0x11, 0x75, 0x3b, 0x28, 0x75, 0x9c, 0x35, 0xa2, 0x97, 0xf2, 0x9b, 0x90,
	0x0a, 0xb3, 0xc8, 0x1c, 0x64, 0x0c, 0xfd, 0xc1, 0xe1, 0xbe, 0xa1, 0xef, 0xe6, 0x13, 0x24, 0x07,
	0x70, 0x60, 0x7c, 0xba, 0xb7, 0x5f, 0xdd, 0xaf, 0xeb, 0xbb, 0x79, 0x6d, 0x2b, 0x13, 0x52, 0x94,
	0xf4, 0x7e, 0xd0, 0x60, 0x69, 0x50, 0x91, 0xef, 0x78, 0xec, 0xdb, 0x0e, 0x93, 0x3a, 0x93, 0x1b,
	0x30, 0xc7, 0x3a, 0x6d, 0x33, 0x40, 0xdf, 0x75, 0x2c, 0xaa, 0x46, 0xc9, 0xc8, 0xb2, 0x4e, 0xdb,
	0x50, 0x26, 0xa2, 0x43, 0xd6, 0x1a, 0x24, 0xab, 0x99, 0x59, 0x9d, 0xd8, 0x94, 0x12, 0x3f, 0x9e,
	0x17, 0xa3, 0xf3, 0x0d, 0xcc, 0xdf, 0x43, 0xca, 0xf1, 0x20, 0xc0, 0x26, 0x06, 0xc8, 0x2c, 0x1c,
	0xad, 0xa1, 0xbd, 0x66, 0x8d, 0x94, 0xc4, 0xff, 0x3e, 0x0d, 0x50, 0xf3, 0x29, 0xdb, 0x91, 0xbb,
	0x95, 0xbc, 0x05, 0xf3, 0x01, 0x65, 0x2d, 0x34, 0xdb, 0x0e, 0x33, 0x1b, 0x5d, 0x81, 0x51, 0x97,
	0x53, 0xc6, 0x1b, 0xd2, 0x7c, 0xdf, 0x61, 0xd5, 0xd0, 0x18, 0x8b, 0xa3, 0x27, 0x2a, 0x2e, 0x19,
	0x8f, 0xa3, 0x27, 0x51, 0xdc, 0x5d, 0x98, 0x6d, 0x59, 0xd1, 0x1e, 0xea, 0xca, 0x75, 0xc9, 0x6e,
	0x5e, 0x1f, 0xc3, 0xb4, 0xb7, 0x59, 0xab, 0xf9, 0x90, 0xe7, 0xe9, 0x8b, 0x52, 0x7f, 0xfb, 0x1a,
	0x99, 0x96, 0xa5, 0x06, 0xfc, 0x06, 0xcc, 0xb5, 0x5c, 0xaf, 0x41, 0x5d, 0x33, 0x40, 0x6a, 0xf3,
	0x42, 0x4a, 0x0e, 0x5e, 0x36, 0xb2, 0x19, 0xa1, 0xe9, 0xdc, 0x0a, 0xa5, 0xcf, 0xaf, 0xd0, 0x2a,
	0x40, 0x18, 0xf2, 0xc8, 0x13, 0x18, 0xf0, 0xc2, 0xb4, 0x0c, 0x98, 0x65, 0x9d, 0xf6, 0x67, 0xd2,
	0x40, 0x1e, 0x0c, 0x8b, 0x3b, 0x23, 0xc5, 0xbd, 0x35, 0x51, 0xdc, 0xf8, 0x8c, 0x8c, 0x11, 0x9a,
	0x7c, 0x05, 0x0b, 0xb2, 0x9a, 0x19, 0x07, 0xce, 0xbc, 0x1e, 0x70, 0x5e, 0x22, 0xc5, 0x42, 0xc8,
	0x21, 0x2c, 0xb8, 0xe1, 0x80, 0x98, 0x7e, 0x7f, 0x42, 0x78, 0x61, 0x56, 0xa2, 0x8f, 0xdb, 0x4c,
	0x23, 0xc3, 0xd4, 0x83, 0x75, 0x87, 0xcd, 0x9c, 0xbc, 0x03, 0x0b, 0x72, 0x25, 0x9b, 0x88, 0xb6,
	0x89, 0x8c, 0x36, 0x5c, 0xb4, 0x0b, 0x20, 0x15, 0xcf, 0xf7, 0x1d, 0x7a, 0x64, 0x27, 0x1f, 0x40,
	0x41, 0x1d, 0x0d, 0x66, 0x78, 0x6a, 0x0f, 0x1d, 0x0f, 0x59, 0x99, 0xb3, 0xa8, 0xfc, 0xbb, 0x54,
	0xd0, 0xd8, 0xc9, 0x10, 0xcd, 0xe0, 0xdf, 0x69, 0x58, 0xaa, 0x75, 0xb9, 0xc0, 0xf6, 0x60, 0x12,
	0xeb, 0x34, 0x68, 0xa1, 0x20, 0x5f, 0x43, 0x9e, 0x7b, 0x9d, 0xc0, 0x42, 0x53, 0x20, 0xa3, 0x4c,
	0x98, 0x8e, 0xad, 0x4e, 0xb4, 0x71, 0x63, 0x54, 0x97, 0x31, 0xfb, 0xbb, 0xd5, 0x25, 0x35, 0x46,
	0xb9, 0x9a, 0x4c, 0xee, 0xd9, 0x8d, 0x1c, 0x8f, 0xbf, 0xdb, 0xa4, 0xaa, 0x0e, 0x9f, 0xa4, 0x84,
	0xac, 0x8c, 0x81, 0x1c, 0xcf, 0x2b, 0x76, 0x10, 0xad, 0x34, 0x20, 0x17, 0xe1, 0x7d, 0x82, 0x5d,
	0xee, 0x53, 0x0b, 0xc3, 0xa1, 0xbf, 0x14, 0xdb, 0xfe, 0xd0, 0xf7, 0x79, 0x66, 0x84, 0x62, 0x18,
	0x29, 0xb4, 0xb2, 0x04, 0x39, 0x9d, 0x09, 0x27, 0xc0, 0x5e, 0x0d, 0x65, 0xbf, 0x09, 0xd7, 0xb7,
	0x5d, 0x77, 0xb8, 0x7c, 0xc4, 0x90, 0xd7, 0x50, 0xa8, 0xa0, 0x7f, 0x93, 0xea, 0x08, 0x14, 0x50,
	0xe0, 0x3e, 0x5a, 0x4e, 0xd3, 0xb1, 0x7a, 0x72, 0x1e, 0xab, 0x24, 0x45, 0xf3, 0xc3, 0x4b, 0x28,
	0x30, 0x54, 0x74, 0x2f, 0x61, 0x2c, 0xf5, 0xb0, 0x47, 0xd4, 0xb0, 0x60, 0x1e, 0x25, 0xf7, 0x41,
	0xb1, 0xe4, 0x65, 0x8b, 0x0d, 0x37, 0xbf, 0x97, 0x30, 0x72, 0x38, 0x64, 0x21, 0x3f, 0x6a, 0x50,
	0xa2, 0xae, 0x3b, 0xda, 0x96, 0x29, 0x22, 0x31, 0x4c, 0x8e, 0x42, 0x1d, 0x3f, 0xfa, 0xc5, 0xab,
	0x4e, 0x90, 0x76, 0x2f, 0x61, 0x5c, 0xa7, 0xaf, 0x52, 0xbe, 0x3a, 0x1d, 0x8d, 0x97, 0x1a, 0xf3,
	0xdf, 0x34, 0xc8, 0x9f, 0x1b, 0xf0, 0x77, 0x21, 0x15, 0xde, 0x96, 0x94, 0xfe, 0xd7, 0xc6, 0x91,
	0xf3, 0x29, 0xdb, 0x4b, 0x18, 0x32, 0x8c, 0x34, 0x61, 0x99, 0x4b, 0xb2, 0x66, 0xec, 0x8e, 0xa5,
	0xba, 0x54, 0xb2, 0xde, 0xba, 0x70, 0x83, 0x72, 0xd1, 0xc6, 0x7a, 0xaa, 0x33, 0x90, 0xee, 0x30,
	0xc7, 0x63, 0xe5, 0x9f, 0x35, 0x98, 0x1f, 0x78, 0x75, 0x26, 0x82, 0x2e, 0xd9, 0x86, 0x69, 0x55,
	0x31, 0x92, 0xf4, 0xe6, 0x4b, 0x58, 0x0f, 0x21, 0x46, 0x07, 0x8d, 0x4a, 0x24, 0x1f, 0xc1, 0x74,
	0xc4, 0x5d, 0x91, 0x5e, 0x9d, 0x08, 0xd1, 0x4b, 0x8e, 0x52, 0xee, 0xa6, 0x32, 0x5a, 0x3e, 0x59,
	0x6e, 0xc0, 0xe2, 0x1d, 0x14, 0x83, 0x20, 0x6e, 0xe0, 0x77, 0x1d, 0xe4, 0x82, 0xec, 0xc0, 0x8c,
	0x5a, 0xf6, 0x09, 0x77, 0xb6, 0x97, 0xf0, 0xeb, 0x65, 0xaa, 0x1a, 0x01, 0x2c, 0x8d, 0xd6, 0xe0,
	0xbe, 0xc7, 0x38, 0x92, 0x2f, 0xe0, 0x4a, 0x7c, 0x05, 0x90, 0x89, 0xc0, 0xc1, 0xde, 0xc7, 0xb8,
	0x3c, 0xb1, 0xa0, 0x14, 0x51, 0xd5, 0x5b, 0xe0, 0x43, 0x66, 0x07, 0x79, 0xf9, 0x79, 0x12, 0x0a,
	0x87, 0xbe, 0x4d, 0x05, 0x8e, 0xe9, 0xed, 0x36, 0xcc, 0x0a, 0xcf, 0xb4, 0xd1, 0x45, 0x11, 0xde,
	0x73, 0x2e, 0xd9, 0x5d, 0x46, 0x78, 0xbb, 0x32, 0x95, 0xe8, 0x12, 0xa7, 0xe3, 0x73, 0x0c, 0x44,
	0x21, 0x75, 0x49, 0xd2, 0x19, 0xe1, 0x1d, 0xca, 0x4c, 0x72, 0x1f, 0xa2, 0x2f, 0x87, 0xc9, 0x05,
	0x0d, 0x84, 0xbc, 0x75, 0xca, 0x4f, 0xea, 0x05, 0x2f, 0x9c, 0x39, 0x99, 0x5c, 0x0b, 0x73, 0x43,
	0x17, 0xf9, 0x1c, 0x16, 0x23, 0x38, 0x3c, 0xf1, 0x9d, 0x80, 0xca, 0xfb, 0xb7, 0xc4, 0x4c, 0x5f,
	0x1c, 0xf3, 0x8a, 0x44, 0xd0, 0xfb, 0x00, 0xa1, 0x3f, 0x5a, 0xcd, 0xbb, 0xa9, 0x4c, 0x32, 0x3f,
	0x55, 0xfe, 0x12, 0x96, 0xc7, 0xc8, 0xab, 0x96, 0xf5, 0x63, 0x48, 0xcb, 0xbf, 0x11, 0xb5, 0x1f,
	0xd7, 0x62, 0x15, 0x7b, 0xbf, 0x2b, 0x15, 0x9d, 0x59, 0x9e, 0x8d, 0xb6, 0x1e, 0xbe, 0xab, 0xa2,
	0x51, 0x52, 0xb9, 0x03, 0x6f, 0xdf, 0x41, 0xb1, 0xed, 0xba, 0xa3, 0xfb, 0x8d, 0xd7, 0x8f, 0xa8,
	0xd8, 0xf6, 0x7d, 0xb7, 0xdb, 0x5b, 0xc8, 0xff, 0xf1, 0x1b, 0x51, 0x0e, 0x60, 0xfd, 0xd5, 0x65,
	0x55, 0x83, 0xb7, 0x61, 0x2e, 0x36, 0xb7, 0x93, 0x6e, 0x8f, 0xe7, 0xb6, 0x5f, 0x76, 0x30, 0xab,
	0xbc, 0x7a, 0xeb, 0xc9, 0x5f, 0xc5, 0xc4, 0x93, 0xd3, 0xa2, 0xf6, 0xf4, 0xb4, 0xa8, 0x3d, 0x3b,
	0x2d, 0x6a, 0x7f, 0x9e, 0x16, 0xb5, 0x9f, 0xce, 0x8a, 0x89, 0xa7, 0x67, 0xc5, 0xc4, 0xb3, 0xb3,
	0x62, 0xe2, 0xe1, 0x8c, 0x02, 0x6a, 0x4c, 0xcb, 0x9f, 0xb2, 0xf7, 0xfe, 0x0b, 0x00, 0x00, 0xff,
	0xff, 0xeb, 0x34, 0xe1, 0x30, 0x1f, 0x0e, 0x00, 0x00,
}

func (this *GCPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPolicy)
	if !ok {
		that2, ok := that.(GCPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TTLSeconds != that1.TTLSeconds {
		return false
	}
	if len(this.ProtectionPolicies) != len(that1.ProtectionPolicies) {
		return false
	}
	for i := range this.ProtectionPolicies {
		if !this.ProtectionPolicies[i].Equal(&that1.ProtectionPolicies[i]) {
			return false
		}
	}
	if this.IgnoreStrictEnforcement != that1.IgnoreStrictEnforcement {
		return false
	}
	return true
}
func (this *ProtectionPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectionPolicy)
	if !ok {
		that2, ok := that.(ProtectionPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProtectedTimestamp.Equal(&that1.ProtectedTimestamp) {
		return false
	}
	if this.IgnoreIfExcludedFromBackup != that1.IgnoreIfExcludedFromBackup {
		return false
	}
	return true
}
func (this *Constraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Constraint)
	if !ok {
		that2, ok := that.(Constraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ConstraintsConjunction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintsConjunction)
	if !ok {
		that2, ok := that.(ConstraintsConjunction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumReplicas != that1.NumReplicas {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	return true
}
func (this *LeasePreference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LeasePreference)
	if !ok {
		that2, ok := that.(LeasePreference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	return true
}
func (this *SpanConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpanConfig)
	if !ok {
		that2, ok := that.(SpanConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RangeMinBytes != that1.RangeMinBytes {
		return false
	}
	if this.RangeMaxBytes != that1.RangeMaxBytes {
		return false
	}
	if !this.GCPolicy.Equal(&that1.GCPolicy) {
		return false
	}
	if this.GlobalReads != that1.GlobalReads {
		return false
	}
	if this.NumReplicas != that1.NumReplicas {
		return false
	}
	if this.NumVoters != that1.NumVoters {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	if len(this.VoterConstraints) != len(that1.VoterConstraints) {
		return false
	}
	for i := range this.VoterConstraints {
		if !this.VoterConstraints[i].Equal(&that1.VoterConstraints[i]) {
			return false
		}
	}
	if len(this.LeasePreferences) != len(that1.LeasePreferences) {
		return false
	}
	for i := range this.LeasePreferences {
		if !this.LeasePreferences[i].Equal(&that1.LeasePreferences[i]) {
			return false
		}
	}
	if this.RangefeedEnabled != that1.RangefeedEnabled {
		return false
	}
	if this.ExcludeDataFromBackup != that1.ExcludeDataFromBackup {
		return false
	}
	return true
}
func (this *SystemSpanConfigTarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemSpanConfigTarget)
	if !ok {
		that2, ok := that.(SystemSpanConfigTarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SourceTenantID.Equal(&that1.SourceTenantID) {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *SystemSpanConfigTarget_TenantKeyspace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemSpanConfigTarget_TenantKeyspace)
	if !ok {
		that2, ok := that.(SystemSpanConfigTarget_TenantKeyspace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TenantID.Equal(&that1.TenantID) {
		return false
	}
	return true
}
func (this *SystemSpanConfigTarget_EntireKeyspace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemSpanConfigTarget_EntireKeyspace)
	if !ok {
		that2, ok := that.(SystemSpanConfigTarget_EntireKeyspace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet)
	if !ok {
		that2, ok := that.(SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *SystemSpanConfigTarget_Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemSpanConfigTarget_Type)
	if !ok {
		that2, ok := that.(SystemSpanConfigTarget_Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *SystemSpanConfigTarget_Type_SpecificTenantKeyspace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemSpanConfigTarget_Type_SpecificTenantKeyspace)
	if !ok {
		that2, ok := that.(SystemSpanConfigTarget_Type_SpecificTenantKeyspace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SpecificTenantKeyspace.Equal(that1.SpecificTenantKeyspace) {
		return false
	}
	return true
}
func (this *SystemSpanConfigTarget_Type_EntireKeyspace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemSpanConfigTarget_Type_EntireKeyspace)
	if !ok {
		that2, ok := that.(SystemSpanConfigTarget_Type_EntireKeyspace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EntireKeyspace.Equal(that1.EntireKeyspace) {
		return false
	}
	return true
}
func (this *SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet)
	if !ok {
		that2, ok := that.(SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllTenantKeyspaceTargetsSet.Equal(that1.AllTenantKeyspaceTargetsSet) {
		return false
	}
	return true
}
func (m *GCPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreStrictEnforcement {
		i--
		if m.IgnoreStrictEnforcement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ProtectionPolicies) > 0 {
		for iNdEx := len(m.ProtectionPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtectionPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TTLSeconds != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.TTLSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProtectionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtectionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreIfExcludedFromBackup {
		i--
		if m.IgnoreIfExcludedFromBackup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ProtectedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Constraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Constraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Constraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintSpanConfig(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintSpanConfig(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintsConjunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintsConjunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintsConjunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NumReplicas != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.NumReplicas))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeasePreference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeasePreference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeasePreference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExcludeDataFromBackup {
		i--
		if m.ExcludeDataFromBackup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.RangefeedEnabled {
		i--
		if m.RangefeedEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.LeasePreferences) > 0 {
		for iNdEx := len(m.LeasePreferences) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeasePreferences[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.VoterConstraints) > 0 {
		for iNdEx := len(m.VoterConstraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VoterConstraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.NumVoters != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.NumVoters))
		i--
		dAtA[i] = 0x30
	}
	if m.NumReplicas != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.NumReplicas))
		i--
		dAtA[i] = 0x28
	}
	if m.GlobalReads {
		i--
		if m.GlobalReads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.GCPolicy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RangeMaxBytes != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.RangeMaxBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeMinBytes != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.RangeMinBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SystemSpanConfigTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemSpanConfigTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemSpanConfigTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpanConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.SourceTenantID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SystemSpanConfigTarget_TenantKeyspace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemSpanConfigTarget_TenantKeyspace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemSpanConfigTarget_TenantKeyspace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TenantID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SystemSpanConfigTarget_EntireKeyspace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemSpanConfigTarget_EntireKeyspace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemSpanConfigTarget_EntireKeyspace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SystemSpanConfigTarget_Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemSpanConfigTarget_Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemSpanConfigTarget_Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SystemSpanConfigTarget_Type_SpecificTenantKeyspace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemSpanConfigTarget_Type_SpecificTenantKeyspace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SpecificTenantKeyspace != nil {
		{
			size, err := m.SpecificTenantKeyspace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpanConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SystemSpanConfigTarget_Type_EntireKeyspace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemSpanConfigTarget_Type_EntireKeyspace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EntireKeyspace != nil {
		{
			size, err := m.EntireKeyspace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpanConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllTenantKeyspaceTargetsSet != nil {
		{
			size, err := m.AllTenantKeyspaceTargetsSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpanConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SpanConfigTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Union != nil {
		{
			size := m.Union.Size()
			i -= size
			if _, err := m.Union.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfigTarget_Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigTarget_Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Span != nil {
		{
			size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpanConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SpanConfigTarget_SystemSpanConfigTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigTarget_SystemSpanConfigTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SystemSpanConfigTarget != nil {
		{
			size, err := m.SystemSpanConfigTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpanConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SpanConfigEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *GetSpanConfigsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpanConfigsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpanConfigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpanConfigsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpanConfigsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpanConfigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpanConfigEntries) > 0 {
		for iNdEx := len(m.SpanConfigEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpanConfigEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSpanConfigsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSpanConfigsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSpanConfigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LeaseStartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.LeaseExpirationTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.ToUpsert) > 0 {
		for iNdEx := len(m.ToUpsert) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToUpsert[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ToDelete) > 0 {
		for iNdEx := len(m.ToDelete) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToDelete[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSpanConfigsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSpanConfigsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSpanConfigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetAllSystemSpanConfigsThatApplyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAllSystemSpanConfigsThatApplyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAllSystemSpanConfigsThatApplyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TenantID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetAllSystemSpanConfigsThatApplyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAllSystemSpanConfigsThatApplyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAllSystemSpanConfigsThatApplyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpanConfigs) > 0 {
		for iNdEx := len(m.SpanConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpanConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintSpanConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpanConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedGCPolicy(r randySpanConfig, easy bool) *GCPolicy {
	this := &GCPolicy{}
	this.TTLSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TTLSeconds *= -1
	}
	if r.Intn(5) != 0 {
		v1 := r.Intn(5)
		this.ProtectionPolicies = make([]ProtectionPolicy, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedProtectionPolicy(r, easy)
			this.ProtectionPolicies[i] = *v2
		}
	}
	this.IgnoreStrictEnforcement = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProtectionPolicy(r randySpanConfig, easy bool) *ProtectionPolicy {
	this := &ProtectionPolicy{}
	v3 := hlc.NewPopulatedTimestamp(r, easy)
	this.ProtectedTimestamp = *v3
	this.IgnoreIfExcludedFromBackup = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randySpanConfig interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneSpanConfig(r randySpanConfig) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringSpanConfig(r randySpanConfig) string {
	v4 := r.Intn(100)
	tmps := make([]rune, v4)
	for i := 0; i < v4; i++ {
		tmps[i] = randUTF8RuneSpanConfig(r)
	}
	return string(tmps)
}
func randUnrecognizedSpanConfig(r randySpanConfig, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldSpanConfig(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldSpanConfig(dAtA []byte, r randySpanConfig, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		v5 := r.Int63()
		if r.Intn(2) == 0 {
			v5 *= -1
		}
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(v5))
	case 1:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateSpanConfig(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *GCPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TTLSeconds != 0 {
		n += 1 + sovSpanConfig(uint64(m.TTLSeconds))
	}
	if len(m.ProtectionPolicies) > 0 {
		for _, e := range m.ProtectionPolicies {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if m.IgnoreStrictEnforcement {
		n += 2
	}
	return n
}

func (m *ProtectionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProtectedTimestamp.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	if m.IgnoreIfExcludedFromBackup {
		n += 2
	}
	return n
}

func (m *Constraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSpanConfig(uint64(m.Type))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}

func (m *ConstraintsConjunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumReplicas != 0 {
		n += 1 + sovSpanConfig(uint64(m.NumReplicas))
	}
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *LeasePreference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *SpanConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeMinBytes != 0 {
		n += 1 + sovSpanConfig(uint64(m.RangeMinBytes))
	}
	if m.RangeMaxBytes != 0 {
		n += 1 + sovSpanConfig(uint64(m.RangeMaxBytes))
	}
	l = m.GCPolicy.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	if m.GlobalReads {
		n += 2
	}
	if m.NumReplicas != 0 {
		n += 1 + sovSpanConfig(uint64(m.NumReplicas))
	}
	if m.NumVoters != 0 {
		n += 1 + sovSpanConfig(uint64(m.NumVoters))
	}
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if len(m.VoterConstraints) > 0 {
		for _, e := range m.VoterConstraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if len(m.LeasePreferences) > 0 {
		for _, e := range m.LeasePreferences {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if m.RangefeedEnabled {
		n += 2
	}
	if m.ExcludeDataFromBackup {
		n += 2
	}
	return n
}

func (m *SystemSpanConfigTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SourceTenantID.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}

func (m *SystemSpanConfigTarget_TenantKeyspace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TenantID.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	return n
}

func (m *SystemSpanConfigTarget_EntireKeyspace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SystemSpanConfigTarget_Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *SystemSpanConfigTarget_Type_SpecificTenantKeyspace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpecificTenantKeyspace != nil {
		l = m.SpecificTenantKeyspace.Size()
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}
func (m *SystemSpanConfigTarget_Type_EntireKeyspace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntireKeyspace != nil {
		l = m.EntireKeyspace.Size()
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}
func (m *SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllTenantKeyspaceTargetsSet != nil {
		l = m.AllTenantKeyspaceTargetsSet.Size()
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}
func (m *SpanConfigTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Union != nil {
		n += m.Union.Size()
	}
	return n
}

func (m *SpanConfigTarget_Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Span != nil {
		l = m.Span.Size()
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}
func (m *SpanConfigTarget_SystemSpanConfigTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SystemSpanConfigTarget != nil {
		l = m.SystemSpanConfigTarget.Size()
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}
func (m *SpanConfigEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Config.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	l = m.Target.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	return n
}

func (m *GetSpanConfigsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *GetSpanConfigsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SpanConfigEntries) > 0 {
		for _, e := range m.SpanConfigEntries {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *UpdateSpanConfigsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ToDelete) > 0 {
		for _, e := range m.ToDelete {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if len(m.ToUpsert) > 0 {
		for _, e := range m.ToUpsert {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	l = m.LeaseExpirationTime.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	l = m.LeaseStartTime.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	return n
}

func (m *UpdateSpanConfigsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Error.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	return n
}

func (m *GetAllSystemSpanConfigsThatApplyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TenantID.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	return n
}

func (m *GetAllSystemSpanConfigsThatApplyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SpanConfigs) > 0 {
		for _, e := range m.SpanConfigs {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func sovSpanConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpanConfig(x uint64) (n int) {
	return sovSpanConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GCPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTLSeconds", wireType)
			}
			m.TTLSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTLSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectionPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtectionPolicies = append(m.ProtectionPolicies, ProtectionPolicy{})
			if err := m.ProtectionPolicies[len(m.ProtectionPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreStrictEnforcement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreStrictEnforcement = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtectionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtectionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtectionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProtectedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreIfExcludedFromBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreIfExcludedFromBackup = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Constraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Constraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Constraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Constraint_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintsConjunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintsConjunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintsConjunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			m.NumReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, Constraint{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeasePreference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeasePreference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeasePreference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, Constraint{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMinBytes", wireType)
			}
			m.RangeMinBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeMinBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMaxBytes", wireType)
			}
			m.RangeMaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeMaxBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GCPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalReads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GlobalReads = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			m.NumReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumVoters", wireType)
			}
			m.NumVoters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumVoters |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, ConstraintsConjunction{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoterConstraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoterConstraints = append(m.VoterConstraints, ConstraintsConjunction{})
			if err := m.VoterConstraints[len(m.VoterConstraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePreferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeasePreferences = append(m.LeasePreferences, LeasePreference{})
			if err := m.LeasePreferences[len(m.LeasePreferences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangefeedEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RangefeedEnabled = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeDataFromBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeDataFromBackup = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemSpanConfigTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemSpanConfigTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemSpanConfigTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTenantID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SourceTenantID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &SystemSpanConfigTarget_Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemSpanConfigTarget_TenantKeyspace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantKeyspace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantKeyspace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TenantID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemSpanConfigTarget_EntireKeyspace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntireKeyspace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntireKeyspace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllTenantKeyspaceTargetsSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllTenantKeyspaceTargetsSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemSpanConfigTarget_Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecificTenantKeyspace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SystemSpanConfigTarget_TenantKeyspace{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &SystemSpanConfigTarget_Type_SpecificTenantKeyspace{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntireKeyspace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SystemSpanConfigTarget_EntireKeyspace{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &SystemSpanConfigTarget_Type_EntireKeyspace{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllTenantKeyspaceTargetsSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SystemSpanConfigTarget_AllTenantKeyspaceTargetsSet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &SystemSpanConfigTarget_Type_AllTenantKeyspaceTargetsSet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanConfigTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanConfigTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Span{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &SpanConfigTarget_Span{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemSpanConfigTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SystemSpanConfigTarget{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &SpanConfigTarget_SystemSpanConfigTarget{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanConfigEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanConfigEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpanConfigsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpanConfigsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpanConfigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, SpanConfigTarget{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpanConfigsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpanConfigsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpanConfigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanConfigEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanConfigEntries = append(m.SpanConfigEntries, SpanConfigEntry{})
			if err := m.SpanConfigEntries[len(m.SpanConfigEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSpanConfigsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSpanConfigsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSpanConfigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDelete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToDelete = append(m.ToDelete, SpanConfigTarget{})
			if err := m.ToDelete[len(m.ToDelete)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUpsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToUpsert = append(m.ToUpsert, SpanConfigEntry{})
			if err := m.ToUpsert[len(m.ToUpsert)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseExpirationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeaseExpirationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeaseStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSpanConfigsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSpanConfigsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSpanConfigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAllSystemSpanConfigsThatApplyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAllSystemSpanConfigsThatApplyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAllSystemSpanConfigsThatApplyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TenantID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAllSystemSpanConfigsThatApplyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAllSystemSpanConfigsThatApplyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAllSystemSpanConfigsThatApplyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanConfigs = append(m.SpanConfigs, SpanConfig{})
			if err := m.SpanConfigs[len(m.SpanConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpanConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpanConfig
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpanConfig
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpanConfig
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpanConfig        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpanConfig          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpanConfig = fmt.Errorf("proto: unexpected end of group")
)
