// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/kvserver/loqrecovery/loqrecoverypb/recovery.proto

package loqrecoverypb

import (
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DescriptorChangeType int32

const (
	DescriptorChangeType_Split         DescriptorChangeType = 0
	DescriptorChangeType_Merge         DescriptorChangeType = 1
	DescriptorChangeType_ReplicaChange DescriptorChangeType = 2
)

var DescriptorChangeType_name = map[int32]string{
	0: "Split",
	1: "Merge",
	2: "ReplicaChange",
}

var DescriptorChangeType_value = map[string]int32{
	"Split":         0,
	"Merge":         1,
	"ReplicaChange": 2,
}

func (x DescriptorChangeType) String() string {
	return proto.EnumName(DescriptorChangeType_name, int32(x))
}

func (DescriptorChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{0}
}

// DescriptorChangeInfo future descriptor change info extracted from commit
// triggers in raft log.
type DescriptorChangeInfo struct {
	// Change type.
	ChangeType DescriptorChangeType `protobuf:"varint,1,opt,name=changeType,proto3,enum=cockroach.kv.kvserver.loqrecovery.loqrecoverypb.DescriptorChangeType" json:"changeType,omitempty"`
	// Range descriptor containing new state of for replica change updates and
	// LHS for split and merge operations.
	Desc *roachpb.RangeDescriptor `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	// Optional range descriptor with is populated for split and merge changes
	// and contains RHS descriptor for the operation.
	OtherDesc *roachpb.RangeDescriptor `protobuf:"bytes,3,opt,name=otherDesc,proto3" json:"otherDesc,omitempty"`
}

func (m *DescriptorChangeInfo) Reset()         { *m = DescriptorChangeInfo{} }
func (m *DescriptorChangeInfo) String() string { return proto.CompactTextString(m) }
func (*DescriptorChangeInfo) ProtoMessage()    {}
func (*DescriptorChangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{0}
}
func (m *DescriptorChangeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescriptorChangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DescriptorChangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescriptorChangeInfo.Merge(m, src)
}
func (m *DescriptorChangeInfo) XXX_Size() int {
	return m.Size()
}
func (m *DescriptorChangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DescriptorChangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DescriptorChangeInfo proto.InternalMessageInfo

// ReplicaInfo contains info about state of range replica for the purpose of range
// recovery. This information should be enough for recovery algorithm to pick a
// survivor replica in when not replicas are available.
// Information includes range descriptor as well as parts of raft state.
type ReplicaInfo struct {
	NodeID                   github_com_cockroachdb_cockroach_pkg_roachpb.NodeID  `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	StoreID                  github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,2,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	Desc                     roachpb.RangeDescriptor                              `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc"`
	RaftAppliedIndex         uint64                                               `protobuf:"varint,4,opt,name=raft_applied_index,json=raftAppliedIndex,proto3" json:"raft_applied_index,omitempty"`
	RaftCommittedIndex       uint64                                               `protobuf:"varint,5,opt,name=raft_committed_index,json=raftCommittedIndex,proto3" json:"raft_committed_index,omitempty"`
	RaftLogDescriptorChanges []DescriptorChangeInfo                               `protobuf:"bytes,6,rep,name=raft_log_descriptor_changes,json=raftLogDescriptorChanges,proto3" json:"raft_log_descriptor_changes,omitempty"`
}

func (m *ReplicaInfo) Reset()         { *m = ReplicaInfo{} }
func (m *ReplicaInfo) String() string { return proto.CompactTextString(m) }
func (*ReplicaInfo) ProtoMessage()    {}
func (*ReplicaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{1}
}
func (m *ReplicaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaInfo.Merge(m, src)
}
func (m *ReplicaInfo) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaInfo proto.InternalMessageInfo

// Collection of replica information gathered from a collect-info run on a single node.
type NodeReplicaInfo struct {
	Replicas []ReplicaInfo `protobuf:"bytes,1,rep,name=replicas,proto3" json:"replicas"`
}

func (m *NodeReplicaInfo) Reset()         { *m = NodeReplicaInfo{} }
func (m *NodeReplicaInfo) String() string { return proto.CompactTextString(m) }
func (*NodeReplicaInfo) ProtoMessage()    {}
func (*NodeReplicaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{2}
}
func (m *NodeReplicaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeReplicaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeReplicaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeReplicaInfo.Merge(m, src)
}
func (m *NodeReplicaInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeReplicaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeReplicaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeReplicaInfo proto.InternalMessageInfo

// ReplicaUpdate contains information that needs to be updated on replica on the node
// to make it a designated survivor so that replica could act as a source of truth when
// doing loss of quorum recovery.
type ReplicaUpdate struct {
	RangeID       github_com_cockroachdb_cockroach_pkg_roachpb.RangeID   `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty" yaml:"RangeID"`
	StartKey      RecoveryKey                                            `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3,casttype=RecoveryKey" json:"start_key,omitempty" yaml:"StartKey"`
	OldReplicaID  github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,3,opt,name=old_replica_id,json=oldReplicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"old_replica_id,omitempty" yaml:"OldReplicaID"`
	NewReplica    roachpb.ReplicaDescriptor                              `protobuf:"bytes,4,opt,name=new_replica,json=newReplica,proto3" json:"new_replica" yaml:"NewReplica"`
	NextReplicaID github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,5,opt,name=next_replica_id,json=nextReplicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"next_replica_id,omitempty" yaml:"NextReplicaID"`
}

func (m *ReplicaUpdate) Reset()      { *m = ReplicaUpdate{} }
func (*ReplicaUpdate) ProtoMessage() {}
func (*ReplicaUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{3}
}
func (m *ReplicaUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaUpdate.Merge(m, src)
}
func (m *ReplicaUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaUpdate proto.InternalMessageInfo

// ReplicaUpdatePlan Collection of updates for all recoverable replicas in the cluster.
type ReplicaUpdatePlan struct {
	Updates []ReplicaUpdate `protobuf:"bytes,1,rep,name=updates,proto3" json:"updates"`
}

func (m *ReplicaUpdatePlan) Reset()         { *m = ReplicaUpdatePlan{} }
func (m *ReplicaUpdatePlan) String() string { return proto.CompactTextString(m) }
func (*ReplicaUpdatePlan) ProtoMessage()    {}
func (*ReplicaUpdatePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{4}
}
func (m *ReplicaUpdatePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaUpdatePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaUpdatePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaUpdatePlan.Merge(m, src)
}
func (m *ReplicaUpdatePlan) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaUpdatePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaUpdatePlan.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaUpdatePlan proto.InternalMessageInfo

// ReplicaRecoveryRecord is a struct that loss of quorum recovery commands
// write to the store locally when replicas are rewritten to preserve information
// about changes. This records are then consumed on startup to post data to
// appropriate destinations like log, rangelog etc.
// This struct is a union of all necessary information that is needed by all
// downstream destinations.
type ReplicaRecoveryRecord struct {
	// Timestamp of loss of quorum recovery application phase. Timestamp is chosen by process
	// rewriting changes before any replica is rewritten. All events created by single process
	// will share the same timestamp. Different processes updating different stores will
	// produce different timestamps even if updates originated from the same recovery plan.
	// Expressed as nanoseconds since the Unix epoch.
	Timestamp       int64                                                  `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	RangeID         github_com_cockroachdb_cockroach_pkg_roachpb.RangeID   `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty" yaml:"RangeID"`
	StartKey        RecoveryKey                                            `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3,casttype=RecoveryKey" json:"start_key,omitempty" yaml:"StartKey"`
	EndKey          RecoveryKey                                            `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3,casttype=RecoveryKey" json:"end_key,omitempty" yaml:"StartKey"`
	OldReplicaID    github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,5,opt,name=old_replica_id,json=oldReplicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"old_replica_id,omitempty" yaml:"OldReplicaID"`
	NewReplica      roachpb.ReplicaDescriptor                              `protobuf:"bytes,6,opt,name=new_replica,json=newReplica,proto3" json:"new_replica" yaml:"NewReplica"`
	RangeDescriptor roachpb.RangeDescriptor                                `protobuf:"bytes,7,opt,name=range_descriptor,json=rangeDescriptor,proto3" json:"range_descriptor" yaml:"RangeDescriptor"`
}

func (m *ReplicaRecoveryRecord) Reset()         { *m = ReplicaRecoveryRecord{} }
func (m *ReplicaRecoveryRecord) String() string { return proto.CompactTextString(m) }
func (*ReplicaRecoveryRecord) ProtoMessage()    {}
func (*ReplicaRecoveryRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a2cc96948b3cab0, []int{5}
}
func (m *ReplicaRecoveryRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaRecoveryRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicaRecoveryRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaRecoveryRecord.Merge(m, src)
}
func (m *ReplicaRecoveryRecord) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaRecoveryRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaRecoveryRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaRecoveryRecord proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.kv.kvserver.loqrecovery.loqrecoverypb.DescriptorChangeType", DescriptorChangeType_name, DescriptorChangeType_value)
	proto.RegisterType((*DescriptorChangeInfo)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.DescriptorChangeInfo")
	proto.RegisterType((*ReplicaInfo)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ReplicaInfo")
	proto.RegisterType((*NodeReplicaInfo)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.NodeReplicaInfo")
	proto.RegisterType((*ReplicaUpdate)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ReplicaUpdate")
	proto.RegisterType((*ReplicaUpdatePlan)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ReplicaUpdatePlan")
	proto.RegisterType((*ReplicaRecoveryRecord)(nil), "cockroach.kv.kvserver.loqrecovery.loqrecoverypb.ReplicaRecoveryRecord")
}

func init() {
	proto.RegisterFile("kv/kvserver/loqrecovery/loqrecoverypb/recovery.proto", fileDescriptor_5a2cc96948b3cab0)
}

var fileDescriptor_5a2cc96948b3cab0 = []byte{
	// 889 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcf, 0x8f, 0xdb, 0x44,
	0x14, 0x8e, 0x37, 0x4e, 0xb2, 0x3b, 0xd9, 0x1f, 0xd9, 0x21, 0x54, 0xa6, 0x20, 0x3b, 0xb2, 0x40,
	0x8a, 0x50, 0xb1, 0xd1, 0xb6, 0xea, 0xa1, 0x54, 0x94, 0x66, 0x97, 0x43, 0x54, 0x58, 0x90, 0x97,
	0x5e, 0x7a, 0xd8, 0xe0, 0x78, 0xa6, 0x8e, 0x15, 0xdb, 0xe3, 0x8e, 0xa7, 0xe9, 0xe6, 0xc6, 0x8d,
	0x03, 0x17, 0x8e, 0x5c, 0x90, 0xf8, 0x1f, 0xf8, 0x0f, 0x38, 0xed, 0xb1, 0xc7, 0x9e, 0x2c, 0xf0,
	0xde, 0x38, 0xee, 0x05, 0x89, 0x13, 0x9a, 0xb1, 0x1d, 0x3b, 0xe5, 0x87, 0x92, 0xb2, 0x42, 0x9c,
	0x32, 0xf3, 0xde, 0xfb, 0xbe, 0xf7, 0xde, 0xbc, 0x6f, 0x9c, 0x01, 0xb7, 0xa6, 0x33, 0x73, 0x3a,
	0x8b, 0x31, 0x9d, 0x61, 0x6a, 0xfa, 0xe4, 0x09, 0xc5, 0x0e, 0x99, 0x61, 0x3a, 0xaf, 0xae, 0xa3,
	0xb1, 0x59, 0x2c, 0x8d, 0x88, 0x12, 0x46, 0xa0, 0xe9, 0x10, 0x67, 0x4a, 0x89, 0xed, 0x4c, 0x8c,
	0xe9, 0xcc, 0x28, 0xf0, 0x46, 0x05, 0x63, 0x2c, 0xe1, 0xaf, 0x5f, 0x13, 0xc1, 0xd1, 0xd8, 0x0c,
	0x30, 0xb3, 0x91, 0xcd, 0xec, 0x8c, 0xe8, 0x7a, 0xd7, 0x25, 0x2e, 0x11, 0x4b, 0x93, 0xaf, 0x32,
	0xab, 0xfe, 0x9b, 0x04, 0xba, 0x47, 0x38, 0x76, 0xa8, 0x17, 0x31, 0x42, 0x0f, 0x27, 0x76, 0xe8,
	0xe2, 0x61, 0xf8, 0x98, 0x40, 0x0c, 0x80, 0x23, 0x76, 0x5f, 0xcc, 0x23, 0xac, 0x48, 0x3d, 0xa9,
	0xbf, 0x7b, 0xf0, 0xb1, 0xb1, 0x66, 0x31, 0xc6, 0xcb, 0xd4, 0x9c, 0xcc, 0xaa, 0x10, 0xc3, 0xdb,
	0x40, 0x46, 0x38, 0x76, 0x94, 0x8d, 0x9e, 0xd4, 0x6f, 0x1f, 0xe8, 0x95, 0x04, 0x79, 0x1b, 0x86,
	0xc5, 0x63, 0x4b, 0x1e, 0x4b, 0xc4, 0xc3, 0x8f, 0xc0, 0x16, 0x61, 0x13, 0x4c, 0xb9, 0x43, 0xa9,
	0xaf, 0x0c, 0x2e, 0x41, 0xfa, 0xf7, 0x32, 0x68, 0x5b, 0x38, 0xf2, 0x3d, 0xc7, 0x16, 0x0d, 0x3f,
	0x02, 0xad, 0x90, 0x20, 0x3c, 0xf2, 0x90, 0xe8, 0xb6, 0x31, 0xb8, 0x9f, 0x26, 0x5a, 0xf3, 0x98,
	0x20, 0x3c, 0x3c, 0xfa, 0x3d, 0xd1, 0x6e, 0xba, 0x1e, 0x9b, 0x3c, 0x1d, 0x1b, 0x0e, 0x09, 0xca,
	0x91, 0xa0, 0x71, 0xb9, 0x36, 0xa3, 0xa9, 0x6b, 0x16, 0x79, 0x33, 0x98, 0xd5, 0xe4, 0x8c, 0x43,
	0x04, 0x4f, 0xc1, 0x66, 0xcc, 0x08, 0x15, 0xe4, 0x1b, 0x82, 0xfc, 0x30, 0x4d, 0xb4, 0xd6, 0x09,
	0xb7, 0x09, 0xf6, 0x5b, 0x6b, 0xb1, 0xe7, 0x38, 0xab, 0x25, 0x48, 0x87, 0x08, 0xde, 0xcd, 0x4f,
	0x71, 0xe5, 0x83, 0x18, 0xc8, 0xe7, 0x89, 0x56, 0xcb, 0xcf, 0xf2, 0x06, 0x80, 0xd4, 0x7e, 0xcc,
	0x46, 0x76, 0x14, 0xf9, 0x1e, 0x46, 0x23, 0x2f, 0x44, 0xf8, 0x4c, 0x91, 0x7b, 0x52, 0x5f, 0xb6,
	0x3a, 0xdc, 0x73, 0x3f, 0x73, 0x0c, 0xb9, 0x1d, 0xbe, 0x0f, 0xba, 0x22, 0xda, 0x21, 0x41, 0xe0,
	0x31, 0xb6, 0x88, 0x6f, 0x88, 0x78, 0xc1, 0x74, 0x58, 0xb8, 0x32, 0xc4, 0x8f, 0x12, 0x78, 0x53,
	0x40, 0x7c, 0xe2, 0x8e, 0xd0, 0xa2, 0x86, 0x51, 0x26, 0x83, 0x58, 0x69, 0xf6, 0xea, 0xfd, 0xf6,
	0x15, 0x88, 0x8b, 0x8f, 0x71, 0xf0, 0x1e, 0x6f, 0xec, 0xd7, 0x44, 0x7b, 0xe7, 0x1f, 0x32, 0xde,
	0x20, 0x81, 0xc7, 0x70, 0x10, 0xb1, 0xb9, 0xa5, 0xf0, 0xb0, 0x4f, 0x88, 0xfb, 0x32, 0x57, 0xac,
	0x3f, 0x01, 0x7b, 0x7c, 0x8a, 0x55, 0x89, 0x9c, 0x82, 0x4d, 0x9a, 0x6d, 0x63, 0x45, 0x12, 0x45,
	0xdf, 0x5d, 0xbb, 0xe8, 0x0a, 0x5f, 0x3e, 0x84, 0x05, 0xa7, 0xfe, 0x93, 0x0c, 0x76, 0x72, 0xff,
	0xc3, 0x08, 0xd9, 0x0c, 0xc3, 0x08, 0x6c, 0x52, 0x5e, 0x4e, 0xa1, 0xca, 0xfa, 0xe0, 0x21, 0x17,
	0x8e, 0x98, 0xe6, 0xf0, 0xe8, 0x32, 0xd1, 0x76, 0xe7, 0x76, 0xe0, 0xdf, 0xd1, 0x73, 0x83, 0xbe,
	0xb6, 0x94, 0x72, 0xa0, 0xd5, 0x12, 0x69, 0x86, 0x08, 0xde, 0x03, 0x5b, 0x31, 0xb3, 0x29, 0x1b,
	0x4d, 0xf1, 0x5c, 0x68, 0x75, 0x7b, 0xa0, 0x5f, 0x26, 0xda, 0x5e, 0x96, 0xe7, 0x84, 0xbb, 0x1e,
	0xe0, 0x39, 0x4f, 0xd4, 0xb6, 0xf2, 0xae, 0x1e, 0xe0, 0xb9, 0xb5, 0x19, 0xe7, 0x1e, 0xf8, 0xb5,
	0x04, 0x76, 0x89, 0x8f, 0x46, 0x79, 0x57, 0xbc, 0xf2, 0xba, 0x90, 0xbc, 0x9d, 0x26, 0xda, 0xf6,
	0x67, 0x3e, 0x2a, 0x4e, 0x80, 0x97, 0xff, 0x5a, 0x46, 0x5b, 0xb5, 0x72, 0xea, 0xdb, 0xeb, 0xf5,
	0x50, 0x40, 0xad, 0x6d, 0x52, 0x12, 0x21, 0xf8, 0x25, 0x68, 0x87, 0xf8, 0x59, 0x51, 0x88, 0x10,
	0x74, 0xfb, 0xe0, 0xed, 0xbf, 0xba, 0x1c, 0x59, 0x44, 0xe5, 0x7a, 0xbc, 0xc1, 0x27, 0x73, 0x99,
	0x68, 0xfb, 0x59, 0x7d, 0xc7, 0xf8, 0x59, 0x1e, 0xa3, 0x5b, 0x20, 0x5c, 0x6c, 0xe0, 0x37, 0x12,
	0xd8, 0x0b, 0xf1, 0x19, 0xab, 0x36, 0xdb, 0x10, 0xcd, 0x3a, 0x69, 0xa2, 0xed, 0x1c, 0xe3, 0x33,
	0x56, 0xed, 0xb6, 0x5b, 0xb0, 0x55, 0xcc, 0xff, 0xa6, 0xdd, 0x9d, 0xb0, 0xc2, 0x84, 0xee, 0xc8,
	0xdf, 0xfd, 0xa0, 0xd5, 0xf4, 0x18, 0xec, 0x2f, 0x69, 0xe8, 0x73, 0xdf, 0x0e, 0xe1, 0x29, 0x68,
	0x3d, 0x15, 0xbb, 0x42, 0xb8, 0x1f, 0xbe, 0xaa, 0x70, 0x33, 0xd2, 0x5c, 0xba, 0x05, 0xa9, 0xfe,
	0x55, 0x03, 0xbc, 0x9e, 0x07, 0x14, 0xaa, 0xe0, 0xbf, 0x14, 0xc1, 0xb7, 0xc0, 0x16, 0xf3, 0x02,
	0x1c, 0x33, 0x3b, 0x88, 0x32, 0x09, 0x5b, 0xa5, 0x61, 0x49, 0xdf, 0x1b, 0xff, 0xbd, 0xbe, 0xeb,
	0xaf, 0xa0, 0xef, 0x0f, 0x40, 0x0b, 0x87, 0x48, 0xc0, 0xe5, 0x95, 0xe1, 0x4d, 0x1c, 0xa2, 0xbf,
	0xb9, 0x1c, 0x8d, 0xff, 0xc5, 0xe5, 0x68, 0x5e, 0xfd, 0xe5, 0x08, 0x40, 0x27, 0x9b, 0x6d, 0xf9,
	0x01, 0x56, 0x5a, 0x2b, 0xff, 0x41, 0xa9, 0x79, 0x92, 0x6b, 0x15, 0x01, 0x94, 0x6e, 0xdd, 0xda,
	0xa3, 0xcb, 0x96, 0x77, 0xef, 0xfd, 0xf9, 0x21, 0x23, 0x5e, 0x18, 0x5b, 0xa0, 0x71, 0x12, 0xf9,
	0x1e, 0xeb, 0xd4, 0xf8, 0xf2, 0x53, 0x4c, 0x5d, 0xdc, 0x91, 0xe0, 0xfe, 0xe2, 0x4b, 0x9b, 0x85,
	0x76, 0x36, 0x06, 0xe6, 0xf9, 0x2f, 0x6a, 0xed, 0x3c, 0x55, 0xa5, 0xe7, 0xa9, 0x2a, 0xbd, 0x48,
	0x55, 0xe9, 0xe7, 0x54, 0x95, 0xbe, 0xbd, 0x50, 0x6b, 0xcf, 0x2f, 0xd4, 0xda, 0x8b, 0x0b, 0xb5,
	0xf6, 0x68, 0x67, 0xe9, 0x46, 0x8c, 0x9b, 0xe2, 0x09, 0x75, 0xf3, 0x8f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xda, 0x47, 0xb6, 0x49, 0xd9, 0x09, 0x00, 0x00,
}

func (m *DescriptorChangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorChangeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescriptorChangeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OtherDesc != nil {
		{
			size, err := m.OtherDesc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecovery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecovery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ChangeType != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RaftLogDescriptorChanges) > 0 {
		for iNdEx := len(m.RaftLogDescriptorChanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RaftLogDescriptorChanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecovery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.RaftCommittedIndex != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.RaftCommittedIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.RaftAppliedIndex != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.RaftAppliedIndex))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.StoreID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeReplicaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeReplicaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeReplicaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecovery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextReplicaID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.NextReplicaID))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.NewReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.OldReplicaID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.OldReplicaID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.RangeID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaUpdatePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaUpdatePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaUpdatePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecovery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaRecoveryRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaRecoveryRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaRecoveryRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RangeDescriptor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.NewReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRecovery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.OldReplicaID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.OldReplicaID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintRecovery(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RangeID != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintRecovery(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRecovery(dAtA []byte, offset int, v uint64) int {
	offset -= sovRecovery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DescriptorChangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChangeType != 0 {
		n += 1 + sovRecovery(uint64(m.ChangeType))
	}
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovRecovery(uint64(l))
	}
	if m.OtherDesc != nil {
		l = m.OtherDesc.Size()
		n += 1 + l + sovRecovery(uint64(l))
	}
	return n
}

func (m *ReplicaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovRecovery(uint64(m.NodeID))
	}
	if m.StoreID != 0 {
		n += 1 + sovRecovery(uint64(m.StoreID))
	}
	l = m.Desc.Size()
	n += 1 + l + sovRecovery(uint64(l))
	if m.RaftAppliedIndex != 0 {
		n += 1 + sovRecovery(uint64(m.RaftAppliedIndex))
	}
	if m.RaftCommittedIndex != 0 {
		n += 1 + sovRecovery(uint64(m.RaftCommittedIndex))
	}
	if len(m.RaftLogDescriptorChanges) > 0 {
		for _, e := range m.RaftLogDescriptorChanges {
			l = e.Size()
			n += 1 + l + sovRecovery(uint64(l))
		}
	}
	return n
}

func (m *NodeReplicaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovRecovery(uint64(l))
		}
	}
	return n
}

func (m *ReplicaUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovRecovery(uint64(m.RangeID))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	if m.OldReplicaID != 0 {
		n += 1 + sovRecovery(uint64(m.OldReplicaID))
	}
	l = m.NewReplica.Size()
	n += 1 + l + sovRecovery(uint64(l))
	if m.NextReplicaID != 0 {
		n += 1 + sovRecovery(uint64(m.NextReplicaID))
	}
	return n
}

func (m *ReplicaUpdatePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovRecovery(uint64(l))
		}
	}
	return n
}

func (m *ReplicaRecoveryRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovRecovery(uint64(m.Timestamp))
	}
	if m.RangeID != 0 {
		n += 1 + sovRecovery(uint64(m.RangeID))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovRecovery(uint64(l))
	}
	if m.OldReplicaID != 0 {
		n += 1 + sovRecovery(uint64(m.OldReplicaID))
	}
	l = m.NewReplica.Size()
	n += 1 + l + sovRecovery(uint64(l))
	l = m.RangeDescriptor.Size()
	n += 1 + l + sovRecovery(uint64(l))
	return n
}

func sovRecovery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRecovery(x uint64) (n int) {
	return sovRecovery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DescriptorChangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorChangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorChangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= DescriptorChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &roachpb.RangeDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtherDesc == nil {
				m.OtherDesc = &roachpb.RangeDescriptor{}
			}
			if err := m.OtherDesc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAppliedIndex", wireType)
			}
			m.RaftAppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftAppliedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftCommittedIndex", wireType)
			}
			m.RaftCommittedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftCommittedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLogDescriptorChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftLogDescriptorChanges = append(m.RaftLogDescriptorChanges, DescriptorChangeInfo{})
			if err := m.RaftLogDescriptorChanges[len(m.RaftLogDescriptorChanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeReplicaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeReplicaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeReplicaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, ReplicaInfo{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldReplicaID", wireType)
			}
			m.OldReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextReplicaID", wireType)
			}
			m.NextReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaUpdatePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaUpdatePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaUpdatePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, ReplicaUpdate{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaRecoveryRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaRecoveryRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaRecoveryRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldReplicaID", wireType)
			}
			m.OldReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRecovery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRecovery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecovery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRecovery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRecovery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRecovery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRecovery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRecovery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRecovery = fmt.Errorf("proto: unexpected end of group")
)
