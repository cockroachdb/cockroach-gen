// Code generated by optgen; DO NOT EDIT.

package explain

import (
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/colinfo"
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	"github.com/cockroachdb/cockroach/pkg/sql/inverted"
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/cat"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/constraint"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/exec"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
)

func (f *Factory) ConstructScan(
	table cat.Table,
	index cat.Index,
	params exec.ScanParams,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	args := &scanArgs{
		Table:       table,
		Index:       index,
		Params:      params,
		ReqOrdering: reqOrdering,
	}
	_n, err := newNode(scanOp, args, reqOrdering)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructScan(
		table,
		index,
		params,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructValues(
	rows [][]tree.TypedExpr,
	columns colinfo.ResultColumns,
) (exec.Node, error) {
	args := &valuesArgs{
		Rows:    rows,
		Columns: columns,
	}
	_n, err := newNode(valuesOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructValues(
		rows,
		columns,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructFilter(
	input exec.Node,
	filter tree.TypedExpr,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &filterArgs{
		Input:       inputNode,
		Filter:      filter,
		ReqOrdering: reqOrdering,
	}
	_n, err := newNode(filterOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructFilter(
		inputNode.WrappedNode(),
		filter,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructInvertedFilter(
	input exec.Node,
	invFilter *inverted.SpanExpression,
	preFiltererExpr tree.TypedExpr,
	preFiltererType *types.T,
	invColumn exec.NodeColumnOrdinal,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &invertedFilterArgs{
		Input:           inputNode,
		InvFilter:       invFilter,
		PreFiltererExpr: preFiltererExpr,
		PreFiltererType: preFiltererType,
		InvColumn:       invColumn,
	}
	_n, err := newNode(invertedFilterOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructInvertedFilter(
		inputNode.WrappedNode(),
		invFilter,
		preFiltererExpr,
		preFiltererType,
		invColumn,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSimpleProject(
	input exec.Node,
	cols []exec.NodeColumnOrdinal,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &simpleProjectArgs{
		Input:       inputNode,
		Cols:        cols,
		ReqOrdering: reqOrdering,
	}
	_n, err := newNode(simpleProjectOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSimpleProject(
		inputNode.WrappedNode(),
		cols,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSerializingProject(
	input exec.Node,
	cols []exec.NodeColumnOrdinal,
	colNames []string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &serializingProjectArgs{
		Input:    inputNode,
		Cols:     cols,
		ColNames: colNames,
	}
	_n, err := newNode(serializingProjectOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSerializingProject(
		inputNode.WrappedNode(),
		cols,
		colNames,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructRender(
	input exec.Node,
	columns colinfo.ResultColumns,
	exprs tree.TypedExprs,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &renderArgs{
		Input:       inputNode,
		Columns:     columns,
		Exprs:       exprs,
		ReqOrdering: reqOrdering,
	}
	_n, err := newNode(renderOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructRender(
		inputNode.WrappedNode(),
		columns,
		exprs,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructApplyJoin(
	joinType descpb.JoinType,
	left exec.Node,
	rightColumns colinfo.ResultColumns,
	onCond tree.TypedExpr,
	planRightSideFn exec.ApplyJoinPlanRightSideFn,
) (exec.Node, error) {
	leftNode := left.(*Node)
	args := &applyJoinArgs{
		JoinType:        joinType,
		Left:            leftNode,
		RightColumns:    rightColumns,
		OnCond:          onCond,
		PlanRightSideFn: planRightSideFn,
	}
	_n, err := newNode(applyJoinOp, args, nil /* ordering */, leftNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructApplyJoin(
		joinType,
		leftNode.WrappedNode(),
		rightColumns,
		onCond,
		planRightSideFn,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructHashJoin(
	joinType descpb.JoinType,
	left exec.Node,
	right exec.Node,
	leftEqCols []exec.NodeColumnOrdinal,
	rightEqCols []exec.NodeColumnOrdinal,
	leftEqColsAreKey bool,
	rightEqColsAreKey bool,
	extraOnCond tree.TypedExpr,
) (exec.Node, error) {
	leftNode := left.(*Node)
	rightNode := right.(*Node)
	args := &hashJoinArgs{
		JoinType:          joinType,
		Left:              leftNode,
		Right:             rightNode,
		LeftEqCols:        leftEqCols,
		RightEqCols:       rightEqCols,
		LeftEqColsAreKey:  leftEqColsAreKey,
		RightEqColsAreKey: rightEqColsAreKey,
		ExtraOnCond:       extraOnCond,
	}
	_n, err := newNode(hashJoinOp, args, nil /* ordering */, leftNode, rightNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructHashJoin(
		joinType,
		leftNode.WrappedNode(),
		rightNode.WrappedNode(),
		leftEqCols,
		rightEqCols,
		leftEqColsAreKey,
		rightEqColsAreKey,
		extraOnCond,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructMergeJoin(
	joinType descpb.JoinType,
	left exec.Node,
	right exec.Node,
	onCond tree.TypedExpr,
	leftOrdering colinfo.ColumnOrdering,
	rightOrdering colinfo.ColumnOrdering,
	reqOrdering exec.OutputOrdering,
	leftEqColsAreKey bool,
	rightEqColsAreKey bool,
) (exec.Node, error) {
	leftNode := left.(*Node)
	rightNode := right.(*Node)
	args := &mergeJoinArgs{
		JoinType:          joinType,
		Left:              leftNode,
		Right:             rightNode,
		OnCond:            onCond,
		LeftOrdering:      leftOrdering,
		RightOrdering:     rightOrdering,
		ReqOrdering:       reqOrdering,
		LeftEqColsAreKey:  leftEqColsAreKey,
		RightEqColsAreKey: rightEqColsAreKey,
	}
	_n, err := newNode(mergeJoinOp, args, reqOrdering, leftNode, rightNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructMergeJoin(
		joinType,
		leftNode.WrappedNode(),
		rightNode.WrappedNode(),
		onCond,
		leftOrdering,
		rightOrdering,
		reqOrdering,
		leftEqColsAreKey,
		rightEqColsAreKey,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructGroupBy(
	input exec.Node,
	groupCols []exec.NodeColumnOrdinal,
	// If set, the input is guaranteed to have this ordering and a "streaming"
	// aggregation is performed (i.e. aggregation happens separately for each
	// distinct set of values on the set of columns in the ordering).
	groupColOrdering colinfo.ColumnOrdering,
	aggregations []exec.AggInfo,
	// If set, the output must have this ordering, but it is guaranteed that
	// ReqOrdering is a prefix of GroupColOrdering.
	reqOrdering exec.OutputOrdering,
	// The grouping column order type (Streaming, PartialStreaming, or
	// NoStreaming).
	groupingOrderType exec.GroupingOrderType,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &groupByArgs{
		Input:             inputNode,
		GroupCols:         groupCols,
		GroupColOrdering:  groupColOrdering,
		Aggregations:      aggregations,
		ReqOrdering:       reqOrdering,
		groupingOrderType: groupingOrderType,
	}
	_n, err := newNode(groupByOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructGroupBy(
		inputNode.WrappedNode(),
		groupCols,
		groupColOrdering,
		aggregations,
		reqOrdering,
		groupingOrderType,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructScalarGroupBy(
	input exec.Node,
	aggregations []exec.AggInfo,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &scalarGroupByArgs{
		Input:        inputNode,
		Aggregations: aggregations,
	}
	_n, err := newNode(scalarGroupByOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructScalarGroupBy(
		inputNode.WrappedNode(),
		aggregations,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructDistinct(
	input exec.Node,
	distinctCols exec.NodeColumnOrdinalSet,
	orderedCols exec.NodeColumnOrdinalSet,
	reqOrdering exec.OutputOrdering,
	nullsAreDistinct bool,
	errorOnDup string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &distinctArgs{
		Input:            inputNode,
		DistinctCols:     distinctCols,
		OrderedCols:      orderedCols,
		ReqOrdering:      reqOrdering,
		NullsAreDistinct: nullsAreDistinct,
		ErrorOnDup:       errorOnDup,
	}
	_n, err := newNode(distinctOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructDistinct(
		inputNode.WrappedNode(),
		distinctCols,
		orderedCols,
		reqOrdering,
		nullsAreDistinct,
		errorOnDup,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructHashSetOp(
	typ tree.UnionType,
	all bool,
	left exec.Node,
	right exec.Node,
) (exec.Node, error) {
	leftNode := left.(*Node)
	rightNode := right.(*Node)
	args := &hashSetOpArgs{
		Typ:   typ,
		All:   all,
		Left:  leftNode,
		Right: rightNode,
	}
	_n, err := newNode(hashSetOpOp, args, nil /* ordering */, leftNode, rightNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructHashSetOp(
		typ,
		all,
		leftNode.WrappedNode(),
		rightNode.WrappedNode(),
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructStreamingSetOp(
	typ tree.UnionType,
	all bool,
	left exec.Node,
	right exec.Node,
	streamingOrdering colinfo.ColumnOrdering,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	leftNode := left.(*Node)
	rightNode := right.(*Node)
	args := &streamingSetOpArgs{
		Typ:               typ,
		All:               all,
		Left:              leftNode,
		Right:             rightNode,
		StreamingOrdering: streamingOrdering,
		ReqOrdering:       reqOrdering,
	}
	_n, err := newNode(streamingSetOpOp, args, reqOrdering, leftNode, rightNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructStreamingSetOp(
		typ,
		all,
		leftNode.WrappedNode(),
		rightNode.WrappedNode(),
		streamingOrdering,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructUnionAll(
	left exec.Node,
	right exec.Node,
	reqOrdering exec.OutputOrdering,
	hardLimit uint64,
) (exec.Node, error) {
	leftNode := left.(*Node)
	rightNode := right.(*Node)
	args := &unionAllArgs{
		Left:        leftNode,
		Right:       rightNode,
		ReqOrdering: reqOrdering,
		HardLimit:   hardLimit,
	}
	_n, err := newNode(unionAllOp, args, reqOrdering, leftNode, rightNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructUnionAll(
		leftNode.WrappedNode(),
		rightNode.WrappedNode(),
		reqOrdering,
		hardLimit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSort(
	input exec.Node,
	ordering exec.OutputOrdering,
	alreadyOrderedPrefix int,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &sortArgs{
		Input:                inputNode,
		Ordering:             ordering,
		AlreadyOrderedPrefix: alreadyOrderedPrefix,
	}
	_n, err := newNode(sortOp, args, ordering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSort(
		inputNode.WrappedNode(),
		ordering,
		alreadyOrderedPrefix,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructOrdinality(
	input exec.Node,
	colName string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &ordinalityArgs{
		Input:   inputNode,
		ColName: colName,
	}
	_n, err := newNode(ordinalityOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructOrdinality(
		inputNode.WrappedNode(),
		colName,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructIndexJoin(
	input exec.Node,
	table cat.Table,
	keyCols []exec.NodeColumnOrdinal,
	tableCols exec.TableColumnOrdinalSet,
	reqOrdering exec.OutputOrdering,
	locking opt.Locking,
	limitHint int64,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &indexJoinArgs{
		Input:       inputNode,
		Table:       table,
		KeyCols:     keyCols,
		TableCols:   tableCols,
		ReqOrdering: reqOrdering,
		Locking:     locking,
		LimitHint:   limitHint,
	}
	_n, err := newNode(indexJoinOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructIndexJoin(
		inputNode.WrappedNode(),
		table,
		keyCols,
		tableCols,
		reqOrdering,
		locking,
		limitHint,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructLookupJoin(
	joinType descpb.JoinType,
	input exec.Node,
	table cat.Table,
	index cat.Index,
	eqCols []exec.NodeColumnOrdinal,
	eqColsAreKey bool,
	lookupExpr tree.TypedExpr,
	remoteLookupExpr tree.TypedExpr,
	lookupCols exec.TableColumnOrdinalSet,
	onCond tree.TypedExpr,
	isFirstJoinInPairedJoiner bool,
	isSecondJoinInPairedJoiner bool,
	reqOrdering exec.OutputOrdering,
	locking opt.Locking,
	limitHint int64,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &lookupJoinArgs{
		JoinType:                   joinType,
		Input:                      inputNode,
		Table:                      table,
		Index:                      index,
		EqCols:                     eqCols,
		EqColsAreKey:               eqColsAreKey,
		LookupExpr:                 lookupExpr,
		RemoteLookupExpr:           remoteLookupExpr,
		LookupCols:                 lookupCols,
		OnCond:                     onCond,
		IsFirstJoinInPairedJoiner:  isFirstJoinInPairedJoiner,
		IsSecondJoinInPairedJoiner: isSecondJoinInPairedJoiner,
		ReqOrdering:                reqOrdering,
		Locking:                    locking,
		LimitHint:                  limitHint,
	}
	_n, err := newNode(lookupJoinOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructLookupJoin(
		joinType,
		inputNode.WrappedNode(),
		table,
		index,
		eqCols,
		eqColsAreKey,
		lookupExpr,
		remoteLookupExpr,
		lookupCols,
		onCond,
		isFirstJoinInPairedJoiner,
		isSecondJoinInPairedJoiner,
		reqOrdering,
		locking,
		limitHint,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructInvertedJoin(
	joinType descpb.JoinType,
	invertedExpr tree.TypedExpr,
	input exec.Node,
	table cat.Table,
	index cat.Index,
	prefixEqCols []exec.NodeColumnOrdinal,
	lookupCols exec.TableColumnOrdinalSet,
	onCond tree.TypedExpr,
	isFirstJoinInPairedJoiner bool,
	reqOrdering exec.OutputOrdering,
	locking opt.Locking,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &invertedJoinArgs{
		JoinType:                  joinType,
		InvertedExpr:              invertedExpr,
		Input:                     inputNode,
		Table:                     table,
		Index:                     index,
		PrefixEqCols:              prefixEqCols,
		LookupCols:                lookupCols,
		OnCond:                    onCond,
		IsFirstJoinInPairedJoiner: isFirstJoinInPairedJoiner,
		ReqOrdering:               reqOrdering,
		Locking:                   locking,
	}
	_n, err := newNode(invertedJoinOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructInvertedJoin(
		joinType,
		invertedExpr,
		inputNode.WrappedNode(),
		table,
		index,
		prefixEqCols,
		lookupCols,
		onCond,
		isFirstJoinInPairedJoiner,
		reqOrdering,
		locking,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructZigzagJoin(
	// Left table and index.
	leftTable cat.Table,
	leftIndex cat.Index,
	// leftCols are the columns that are scanned from the left index.
	leftCols exec.TableColumnOrdinalSet,
	// leftFixedVals contains values for the fixed columns (a prefix of the
	// index columns).
	leftFixedVals []tree.TypedExpr,
	// leftEqCols are the left table columns that have equality constraints,
	// corresponding 1-1 to RightEqCols.
	leftEqCols []exec.TableColumnOrdinal,
	// Left row-level locking properties.
	leftLocking opt.Locking,
	// Right table and index.
	rightTable cat.Table,
	rightIndex cat.Index,
	// rightCols are the columns that are scanned from the right index.
	rightCols exec.TableColumnOrdinalSet,
	// rightFixedVals contains values for the fixed columns (a prefix of the
	// index columns).
	rightFixedVals []tree.TypedExpr,
	// rightEqCols are the right table columns that have equality constraints,
	// corresponding 1-1 to LeftEqCols.
	rightEqCols []exec.TableColumnOrdinal,
	// Right row-level locking properties.
	rightLocking opt.Locking,
	// onCond is an extra filter that is evaluated on the results.
	// TODO(radu): remove this (it can be a separate Select).
	onCond tree.TypedExpr,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	args := &zigzagJoinArgs{
		LeftTable:      leftTable,
		LeftIndex:      leftIndex,
		LeftCols:       leftCols,
		LeftFixedVals:  leftFixedVals,
		LeftEqCols:     leftEqCols,
		LeftLocking:    leftLocking,
		RightTable:     rightTable,
		RightIndex:     rightIndex,
		RightCols:      rightCols,
		RightFixedVals: rightFixedVals,
		RightEqCols:    rightEqCols,
		RightLocking:   rightLocking,
		OnCond:         onCond,
		ReqOrdering:    reqOrdering,
	}
	_n, err := newNode(zigzagJoinOp, args, reqOrdering)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructZigzagJoin(
		leftTable,
		leftIndex,
		leftCols,
		leftFixedVals,
		leftEqCols,
		leftLocking,
		rightTable,
		rightIndex,
		rightCols,
		rightFixedVals,
		rightEqCols,
		rightLocking,
		onCond,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructLimit(
	input exec.Node,
	limit tree.TypedExpr,
	offset tree.TypedExpr,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &limitArgs{
		Input:  inputNode,
		Limit:  limit,
		Offset: offset,
	}
	_n, err := newNode(limitOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructLimit(
		inputNode.WrappedNode(),
		limit,
		offset,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructTopK(
	input exec.Node,
	k int64,
	ordering exec.OutputOrdering,
	alreadyOrderedPrefix int,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &topKArgs{
		Input:                inputNode,
		K:                    k,
		Ordering:             ordering,
		AlreadyOrderedPrefix: alreadyOrderedPrefix,
	}
	_n, err := newNode(topKOp, args, ordering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructTopK(
		inputNode.WrappedNode(),
		k,
		ordering,
		alreadyOrderedPrefix,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructMax1Row(
	input exec.Node,
	errorText string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &max1RowArgs{
		Input:     inputNode,
		ErrorText: errorText,
	}
	_n, err := newNode(max1RowOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructMax1Row(
		inputNode.WrappedNode(),
		errorText,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructProjectSet(
	input exec.Node,
	exprs tree.TypedExprs,
	zipCols colinfo.ResultColumns,
	numColsPerGen []int,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &projectSetArgs{
		Input:         inputNode,
		Exprs:         exprs,
		ZipCols:       zipCols,
		NumColsPerGen: numColsPerGen,
	}
	_n, err := newNode(projectSetOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructProjectSet(
		inputNode.WrappedNode(),
		exprs,
		zipCols,
		numColsPerGen,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructWindow(
	input exec.Node,
	window exec.WindowInfo,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &windowArgs{
		Input:  inputNode,
		Window: window,
	}
	_n, err := newNode(windowOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructWindow(
		inputNode.WrappedNode(),
		window,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructExplainOpt(
	plan string,
	envOpts exec.ExplainEnvData,
) (exec.Node, error) {
	args := &explainOptArgs{
		Plan:    plan,
		EnvOpts: envOpts,
	}
	_n, err := newNode(explainOptOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructExplainOpt(
		plan,
		envOpts,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructExplain(
	options *tree.ExplainOptions,
	stmtType tree.StatementReturnType,
	buildFn exec.BuildPlanForExplainFn,
) (exec.Node, error) {
	args := &explainArgs{
		Options:  options,
		StmtType: stmtType,
		BuildFn:  buildFn,
	}
	_n, err := newNode(explainOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructExplain(
		options,
		stmtType,
		buildFn,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructShowTrace(
	typ tree.ShowTraceType,
	compact bool,
) (exec.Node, error) {
	args := &showTraceArgs{
		Typ:     typ,
		Compact: compact,
	}
	_n, err := newNode(showTraceOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructShowTrace(
		typ,
		compact,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructInsert(
	input exec.Node,
	table cat.Table,
	arbiterIndexes cat.IndexOrdinals,
	arbiterConstraints cat.UniqueOrdinals,
	insertCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	checkCols exec.CheckOrdinalSet,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction, or there are
	// multiple mutations in a statement, or the output of the mutation is
	// processed through side-effecting expressions.
	autoCommit bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &insertArgs{
		Input:              inputNode,
		Table:              table,
		ArbiterIndexes:     arbiterIndexes,
		ArbiterConstraints: arbiterConstraints,
		InsertCols:         insertCols,
		ReturnCols:         returnCols,
		CheckCols:          checkCols,
		AutoCommit:         autoCommit,
	}
	_n, err := newNode(insertOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructInsert(
		inputNode.WrappedNode(),
		table,
		arbiterIndexes,
		arbiterConstraints,
		insertCols,
		returnCols,
		checkCols,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructInsertFastPath(
	rows [][]tree.TypedExpr,
	table cat.Table,
	insertCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	checkCols exec.CheckOrdinalSet,
	fkChecks []exec.InsertFastPathFKCheck,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction.
	autoCommit bool,
) (exec.Node, error) {
	args := &insertFastPathArgs{
		Rows:       rows,
		Table:      table,
		InsertCols: insertCols,
		ReturnCols: returnCols,
		CheckCols:  checkCols,
		FkChecks:   fkChecks,
		AutoCommit: autoCommit,
	}
	_n, err := newNode(insertFastPathOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructInsertFastPath(
		rows,
		table,
		insertCols,
		returnCols,
		checkCols,
		fkChecks,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructUpdate(
	input exec.Node,
	table cat.Table,
	fetchCols exec.TableColumnOrdinalSet,
	updateCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	checks exec.CheckOrdinalSet,
	passthrough colinfo.ResultColumns,
	// If set, the operator will commit the transaction as part of its execution.
	autoCommit bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &updateArgs{
		Input:       inputNode,
		Table:       table,
		FetchCols:   fetchCols,
		UpdateCols:  updateCols,
		ReturnCols:  returnCols,
		Checks:      checks,
		Passthrough: passthrough,
		AutoCommit:  autoCommit,
	}
	_n, err := newNode(updateOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructUpdate(
		inputNode.WrappedNode(),
		table,
		fetchCols,
		updateCols,
		returnCols,
		checks,
		passthrough,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructUpsert(
	input exec.Node,
	table cat.Table,
	arbiterIndexes cat.IndexOrdinals,
	arbiterConstraints cat.UniqueOrdinals,
	canaryCol exec.NodeColumnOrdinal,
	insertCols exec.TableColumnOrdinalSet,
	fetchCols exec.TableColumnOrdinalSet,
	updateCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	checks exec.CheckOrdinalSet,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction, or there are
	// multiple mutations in a statement, or the output of the mutation is
	// processed through side-effecting expressions.
	autoCommit bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &upsertArgs{
		Input:              inputNode,
		Table:              table,
		ArbiterIndexes:     arbiterIndexes,
		ArbiterConstraints: arbiterConstraints,
		CanaryCol:          canaryCol,
		InsertCols:         insertCols,
		FetchCols:          fetchCols,
		UpdateCols:         updateCols,
		ReturnCols:         returnCols,
		Checks:             checks,
		AutoCommit:         autoCommit,
	}
	_n, err := newNode(upsertOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructUpsert(
		inputNode.WrappedNode(),
		table,
		arbiterIndexes,
		arbiterConstraints,
		canaryCol,
		insertCols,
		fetchCols,
		updateCols,
		returnCols,
		checks,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructDelete(
	input exec.Node,
	table cat.Table,
	fetchCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction, or there are
	// multiple mutations in a statement, or the output of the mutation is
	// processed through side-effecting expressions.
	autoCommit bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &deleteArgs{
		Input:      inputNode,
		Table:      table,
		FetchCols:  fetchCols,
		ReturnCols: returnCols,
		AutoCommit: autoCommit,
	}
	_n, err := newNode(deleteOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructDelete(
		inputNode.WrappedNode(),
		table,
		fetchCols,
		returnCols,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructDeleteRange(
	table cat.Table,
	needed exec.TableColumnOrdinalSet,
	indexConstraint *constraint.Constraint,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction, or there are
	// multiple mutations in a statement, or the output of the mutation is
	// processed through side-effecting expressions, or the operation might
	// process too many rows.
	autoCommit bool,
) (exec.Node, error) {
	args := &deleteRangeArgs{
		Table:           table,
		Needed:          needed,
		IndexConstraint: indexConstraint,
		AutoCommit:      autoCommit,
	}
	_n, err := newNode(deleteRangeOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructDeleteRange(
		table,
		needed,
		indexConstraint,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCreateTable(
	schema cat.Schema,
	ct *tree.CreateTable,
) (exec.Node, error) {
	args := &createTableArgs{
		Schema: schema,
		Ct:     ct,
	}
	_n, err := newNode(createTableOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCreateTable(
		schema,
		ct,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCreateTableAs(
	input exec.Node,
	schema cat.Schema,
	ct *tree.CreateTable,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &createTableAsArgs{
		Input:  inputNode,
		Schema: schema,
		Ct:     ct,
	}
	_n, err := newNode(createTableAsOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCreateTableAs(
		inputNode.WrappedNode(),
		schema,
		ct,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCreateView(
	schema cat.Schema,
	viewName *cat.DataSourceName,
	ifNotExists bool,
	replace bool,
	persistence tree.Persistence,
	materialized bool,
	viewQuery string,
	columns colinfo.ResultColumns,
	deps opt.SchemaDeps,
	typeDeps opt.SchemaTypeDeps,
	withData bool,
) (exec.Node, error) {
	args := &createViewArgs{
		Schema:       schema,
		ViewName:     viewName,
		IfNotExists:  ifNotExists,
		Replace:      replace,
		Persistence:  persistence,
		Materialized: materialized,
		ViewQuery:    viewQuery,
		Columns:      columns,
		deps:         deps,
		typeDeps:     typeDeps,
		withData:     withData,
	}
	_n, err := newNode(createViewOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCreateView(
		schema,
		viewName,
		ifNotExists,
		replace,
		persistence,
		materialized,
		viewQuery,
		columns,
		deps,
		typeDeps,
		withData,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSequenceSelect(
	sequence cat.Sequence,
) (exec.Node, error) {
	args := &sequenceSelectArgs{
		Sequence: sequence,
	}
	_n, err := newNode(sequenceSelectOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSequenceSelect(
		sequence,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSaveTable(
	input exec.Node,
	table *cat.DataSourceName,
	colNames []string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &saveTableArgs{
		Input:    inputNode,
		Table:    table,
		ColNames: colNames,
	}
	_n, err := newNode(saveTableOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSaveTable(
		inputNode.WrappedNode(),
		table,
		colNames,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructErrorIfRows(
	input exec.Node,
	// mkErr is used to create the error; it is passed an input row.
	mkErr exec.MkErrFn,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &errorIfRowsArgs{
		Input: inputNode,
		MkErr: mkErr,
	}
	_n, err := newNode(errorIfRowsOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructErrorIfRows(
		inputNode.WrappedNode(),
		mkErr,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructOpaque(
	metadata opt.OpaqueMetadata,
) (exec.Node, error) {
	args := &opaqueArgs{
		Metadata: metadata,
	}
	_n, err := newNode(opaqueOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructOpaque(
		metadata,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructAlterTableSplit(
	index cat.Index,
	input exec.Node,
	expiration tree.TypedExpr,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &alterTableSplitArgs{
		Index:      index,
		Input:      inputNode,
		Expiration: expiration,
	}
	_n, err := newNode(alterTableSplitOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructAlterTableSplit(
		index,
		inputNode.WrappedNode(),
		expiration,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructAlterTableUnsplit(
	index cat.Index,
	input exec.Node,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &alterTableUnsplitArgs{
		Index: index,
		Input: inputNode,
	}
	_n, err := newNode(alterTableUnsplitOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructAlterTableUnsplit(
		index,
		inputNode.WrappedNode(),
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructAlterTableUnsplitAll(
	index cat.Index,
) (exec.Node, error) {
	args := &alterTableUnsplitAllArgs{
		Index: index,
	}
	_n, err := newNode(alterTableUnsplitAllOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructAlterTableUnsplitAll(
		index,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructAlterTableRelocate(
	index cat.Index,
	input exec.Node,
	subjectReplicas tree.RelocateSubject,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &alterTableRelocateArgs{
		Index:           index,
		input:           inputNode,
		subjectReplicas: subjectReplicas,
	}
	_n, err := newNode(alterTableRelocateOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructAlterTableRelocate(
		index,
		inputNode.WrappedNode(),
		subjectReplicas,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructBuffer(
	input exec.Node,
	label string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &bufferArgs{
		Input: inputNode,
		Label: label,
	}
	_n, err := newNode(bufferOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructBuffer(
		inputNode.WrappedNode(),
		label,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructScanBuffer(
	ref exec.Node,
	label string,
) (exec.Node, error) {
	refNode := ref.(*Node)
	args := &scanBufferArgs{
		Ref:   refNode,
		Label: label,
	}
	_n, err := newNode(scanBufferOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructScanBuffer(
		refNode.WrappedNode(),
		label,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructRecursiveCTE(
	initial exec.Node,
	fn exec.RecursiveCTEIterationFn,
	label string,
	deduplicate bool,
) (exec.Node, error) {
	initialNode := initial.(*Node)
	args := &recursiveCTEArgs{
		Initial:     initialNode,
		Fn:          fn,
		Label:       label,
		Deduplicate: deduplicate,
	}
	_n, err := newNode(recursiveCTEOp, args, nil /* ordering */, initialNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructRecursiveCTE(
		initialNode.WrappedNode(),
		fn,
		label,
		deduplicate,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructControlJobs(
	command tree.JobCommand,
	input exec.Node,
	reason tree.TypedExpr,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &controlJobsArgs{
		Command: command,
		input:   inputNode,
		Reason:  reason,
	}
	_n, err := newNode(controlJobsOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructControlJobs(
		command,
		inputNode.WrappedNode(),
		reason,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructControlSchedules(
	command tree.ScheduleCommand,
	input exec.Node,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &controlSchedulesArgs{
		Command: command,
		input:   inputNode,
	}
	_n, err := newNode(controlSchedulesOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructControlSchedules(
		command,
		inputNode.WrappedNode(),
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCancelQueries(
	input exec.Node,
	ifExists bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &cancelQueriesArgs{
		Input:    inputNode,
		IfExists: ifExists,
	}
	_n, err := newNode(cancelQueriesOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCancelQueries(
		inputNode.WrappedNode(),
		ifExists,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCancelSessions(
	input exec.Node,
	ifExists bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &cancelSessionsArgs{
		Input:    inputNode,
		IfExists: ifExists,
	}
	_n, err := newNode(cancelSessionsOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCancelSessions(
		inputNode.WrappedNode(),
		ifExists,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCreateStatistics(
	cs *tree.CreateStats,
) (exec.Node, error) {
	args := &createStatisticsArgs{
		Cs: cs,
	}
	_n, err := newNode(createStatisticsOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCreateStatistics(
		cs,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructExport(
	input exec.Node,
	fileName tree.TypedExpr,
	fileFormat string,
	options []exec.KVOption,
	notNullCols exec.NodeColumnOrdinalSet,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &exportArgs{
		Input:       inputNode,
		FileName:    fileName,
		FileFormat:  fileFormat,
		Options:     options,
		NotNullCols: notNullCols,
	}
	_n, err := newNode(exportOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructExport(
		inputNode.WrappedNode(),
		fileName,
		fileFormat,
		options,
		notNullCols,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructAlterRangeRelocate(
	input exec.Node,
	subjectReplicas tree.RelocateSubject,
	toStoreID tree.TypedExpr,
	fromStoreID tree.TypedExpr,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &alterRangeRelocateArgs{
		input:           inputNode,
		subjectReplicas: subjectReplicas,
		toStoreID:       toStoreID,
		fromStoreID:     fromStoreID,
	}
	_n, err := newNode(alterRangeRelocateOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructAlterRangeRelocate(
		inputNode.WrappedNode(),
		subjectReplicas,
		toStoreID,
		fromStoreID,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCreateFunction(
	schema cat.Schema,
	cf *tree.CreateFunction,
	deps opt.SchemaDeps,
	typeDeps opt.SchemaTypeDeps,
) (exec.Node, error) {
	args := &createFunctionArgs{
		Schema:   schema,
		Cf:       cf,
		Deps:     deps,
		TypeDeps: typeDeps,
	}
	_n, err := newNode(createFunctionOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCreateFunction(
		schema,
		cf,
		deps,
		typeDeps,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructLiteralValues(
	rows tree.ExprContainer,
	columns colinfo.ResultColumns,
) (exec.Node, error) {
	args := &literalValuesArgs{
		Rows:    rows,
		Columns: columns,
	}
	_n, err := newNode(literalValuesOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructLiteralValues(
		rows,
		columns,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

type execOperator int

const (
	unknownOp execOperator = iota
	scanOp
	valuesOp
	filterOp
	invertedFilterOp
	simpleProjectOp
	serializingProjectOp
	renderOp
	applyJoinOp
	hashJoinOp
	mergeJoinOp
	groupByOp
	scalarGroupByOp
	distinctOp
	hashSetOpOp
	streamingSetOpOp
	unionAllOp
	sortOp
	ordinalityOp
	indexJoinOp
	lookupJoinOp
	invertedJoinOp
	zigzagJoinOp
	limitOp
	topKOp
	max1RowOp
	projectSetOp
	windowOp
	explainOptOp
	explainOp
	showTraceOp
	insertOp
	insertFastPathOp
	updateOp
	upsertOp
	deleteOp
	deleteRangeOp
	createTableOp
	createTableAsOp
	createViewOp
	sequenceSelectOp
	saveTableOp
	errorIfRowsOp
	opaqueOp
	alterTableSplitOp
	alterTableUnsplitOp
	alterTableUnsplitAllOp
	alterTableRelocateOp
	bufferOp
	scanBufferOp
	recursiveCTEOp
	controlJobsOp
	controlSchedulesOp
	cancelQueriesOp
	cancelSessionsOp
	createStatisticsOp
	exportOp
	alterRangeRelocateOp
	createFunctionOp
	literalValuesOp
	numOperators
)

type scanArgs struct {
	Table       cat.Table
	Index       cat.Index
	Params      exec.ScanParams
	ReqOrdering exec.OutputOrdering
}

type valuesArgs struct {
	Rows    [][]tree.TypedExpr
	Columns colinfo.ResultColumns
}

type filterArgs struct {
	Input       *Node
	Filter      tree.TypedExpr
	ReqOrdering exec.OutputOrdering
}

type invertedFilterArgs struct {
	Input           *Node
	InvFilter       *inverted.SpanExpression
	PreFiltererExpr tree.TypedExpr
	PreFiltererType *types.T
	InvColumn       exec.NodeColumnOrdinal
}

type simpleProjectArgs struct {
	Input       *Node
	Cols        []exec.NodeColumnOrdinal
	ReqOrdering exec.OutputOrdering
}

type serializingProjectArgs struct {
	Input    *Node
	Cols     []exec.NodeColumnOrdinal
	ColNames []string
}

type renderArgs struct {
	Input       *Node
	Columns     colinfo.ResultColumns
	Exprs       tree.TypedExprs
	ReqOrdering exec.OutputOrdering
}

type applyJoinArgs struct {
	JoinType        descpb.JoinType
	Left            *Node
	RightColumns    colinfo.ResultColumns
	OnCond          tree.TypedExpr
	PlanRightSideFn exec.ApplyJoinPlanRightSideFn
}

type hashJoinArgs struct {
	JoinType          descpb.JoinType
	Left              *Node
	Right             *Node
	LeftEqCols        []exec.NodeColumnOrdinal
	RightEqCols       []exec.NodeColumnOrdinal
	LeftEqColsAreKey  bool
	RightEqColsAreKey bool
	ExtraOnCond       tree.TypedExpr
}

type mergeJoinArgs struct {
	JoinType          descpb.JoinType
	Left              *Node
	Right             *Node
	OnCond            tree.TypedExpr
	LeftOrdering      colinfo.ColumnOrdering
	RightOrdering     colinfo.ColumnOrdering
	ReqOrdering       exec.OutputOrdering
	LeftEqColsAreKey  bool
	RightEqColsAreKey bool
}

type groupByArgs struct {
	Input             *Node
	GroupCols         []exec.NodeColumnOrdinal
	GroupColOrdering  colinfo.ColumnOrdering
	Aggregations      []exec.AggInfo
	ReqOrdering       exec.OutputOrdering
	groupingOrderType exec.GroupingOrderType
}

type scalarGroupByArgs struct {
	Input        *Node
	Aggregations []exec.AggInfo
}

type distinctArgs struct {
	Input            *Node
	DistinctCols     exec.NodeColumnOrdinalSet
	OrderedCols      exec.NodeColumnOrdinalSet
	ReqOrdering      exec.OutputOrdering
	NullsAreDistinct bool
	ErrorOnDup       string
}

type hashSetOpArgs struct {
	Typ   tree.UnionType
	All   bool
	Left  *Node
	Right *Node
}

type streamingSetOpArgs struct {
	Typ               tree.UnionType
	All               bool
	Left              *Node
	Right             *Node
	StreamingOrdering colinfo.ColumnOrdering
	ReqOrdering       exec.OutputOrdering
}

type unionAllArgs struct {
	Left        *Node
	Right       *Node
	ReqOrdering exec.OutputOrdering
	HardLimit   uint64
}

type sortArgs struct {
	Input                *Node
	Ordering             exec.OutputOrdering
	AlreadyOrderedPrefix int
}

type ordinalityArgs struct {
	Input   *Node
	ColName string
}

type indexJoinArgs struct {
	Input       *Node
	Table       cat.Table
	KeyCols     []exec.NodeColumnOrdinal
	TableCols   exec.TableColumnOrdinalSet
	ReqOrdering exec.OutputOrdering
	Locking     opt.Locking
	LimitHint   int64
}

type lookupJoinArgs struct {
	JoinType                   descpb.JoinType
	Input                      *Node
	Table                      cat.Table
	Index                      cat.Index
	EqCols                     []exec.NodeColumnOrdinal
	EqColsAreKey               bool
	LookupExpr                 tree.TypedExpr
	RemoteLookupExpr           tree.TypedExpr
	LookupCols                 exec.TableColumnOrdinalSet
	OnCond                     tree.TypedExpr
	IsFirstJoinInPairedJoiner  bool
	IsSecondJoinInPairedJoiner bool
	ReqOrdering                exec.OutputOrdering
	Locking                    opt.Locking
	LimitHint                  int64
}

type invertedJoinArgs struct {
	JoinType                  descpb.JoinType
	InvertedExpr              tree.TypedExpr
	Input                     *Node
	Table                     cat.Table
	Index                     cat.Index
	PrefixEqCols              []exec.NodeColumnOrdinal
	LookupCols                exec.TableColumnOrdinalSet
	OnCond                    tree.TypedExpr
	IsFirstJoinInPairedJoiner bool
	ReqOrdering               exec.OutputOrdering
	Locking                   opt.Locking
}

type zigzagJoinArgs struct {
	LeftTable      cat.Table
	LeftIndex      cat.Index
	LeftCols       exec.TableColumnOrdinalSet
	LeftFixedVals  []tree.TypedExpr
	LeftEqCols     []exec.TableColumnOrdinal
	LeftLocking    opt.Locking
	RightTable     cat.Table
	RightIndex     cat.Index
	RightCols      exec.TableColumnOrdinalSet
	RightFixedVals []tree.TypedExpr
	RightEqCols    []exec.TableColumnOrdinal
	RightLocking   opt.Locking
	OnCond         tree.TypedExpr
	ReqOrdering    exec.OutputOrdering
}

type limitArgs struct {
	Input  *Node
	Limit  tree.TypedExpr
	Offset tree.TypedExpr
}

type topKArgs struct {
	Input                *Node
	K                    int64
	Ordering             exec.OutputOrdering
	AlreadyOrderedPrefix int
}

type max1RowArgs struct {
	Input     *Node
	ErrorText string
}

type projectSetArgs struct {
	Input         *Node
	Exprs         tree.TypedExprs
	ZipCols       colinfo.ResultColumns
	NumColsPerGen []int
}

type windowArgs struct {
	Input  *Node
	Window exec.WindowInfo
}

type explainOptArgs struct {
	Plan    string
	EnvOpts exec.ExplainEnvData
}

type explainArgs struct {
	Options  *tree.ExplainOptions
	StmtType tree.StatementReturnType
	BuildFn  exec.BuildPlanForExplainFn
}

type showTraceArgs struct {
	Typ     tree.ShowTraceType
	Compact bool
}

type insertArgs struct {
	Input              *Node
	Table              cat.Table
	ArbiterIndexes     cat.IndexOrdinals
	ArbiterConstraints cat.UniqueOrdinals
	InsertCols         exec.TableColumnOrdinalSet
	ReturnCols         exec.TableColumnOrdinalSet
	CheckCols          exec.CheckOrdinalSet
	AutoCommit         bool
}

type insertFastPathArgs struct {
	Rows       [][]tree.TypedExpr
	Table      cat.Table
	InsertCols exec.TableColumnOrdinalSet
	ReturnCols exec.TableColumnOrdinalSet
	CheckCols  exec.CheckOrdinalSet
	FkChecks   []exec.InsertFastPathFKCheck
	AutoCommit bool
}

type updateArgs struct {
	Input       *Node
	Table       cat.Table
	FetchCols   exec.TableColumnOrdinalSet
	UpdateCols  exec.TableColumnOrdinalSet
	ReturnCols  exec.TableColumnOrdinalSet
	Checks      exec.CheckOrdinalSet
	Passthrough colinfo.ResultColumns
	AutoCommit  bool
}

type upsertArgs struct {
	Input              *Node
	Table              cat.Table
	ArbiterIndexes     cat.IndexOrdinals
	ArbiterConstraints cat.UniqueOrdinals
	CanaryCol          exec.NodeColumnOrdinal
	InsertCols         exec.TableColumnOrdinalSet
	FetchCols          exec.TableColumnOrdinalSet
	UpdateCols         exec.TableColumnOrdinalSet
	ReturnCols         exec.TableColumnOrdinalSet
	Checks             exec.CheckOrdinalSet
	AutoCommit         bool
}

type deleteArgs struct {
	Input      *Node
	Table      cat.Table
	FetchCols  exec.TableColumnOrdinalSet
	ReturnCols exec.TableColumnOrdinalSet
	AutoCommit bool
}

type deleteRangeArgs struct {
	Table           cat.Table
	Needed          exec.TableColumnOrdinalSet
	IndexConstraint *constraint.Constraint
	AutoCommit      bool
}

type createTableArgs struct {
	Schema cat.Schema
	Ct     *tree.CreateTable
}

type createTableAsArgs struct {
	Input  *Node
	Schema cat.Schema
	Ct     *tree.CreateTable
}

type createViewArgs struct {
	Schema       cat.Schema
	ViewName     *cat.DataSourceName
	IfNotExists  bool
	Replace      bool
	Persistence  tree.Persistence
	Materialized bool
	ViewQuery    string
	Columns      colinfo.ResultColumns
	deps         opt.SchemaDeps
	typeDeps     opt.SchemaTypeDeps
	withData     bool
}

type sequenceSelectArgs struct {
	Sequence cat.Sequence
}

type saveTableArgs struct {
	Input    *Node
	Table    *cat.DataSourceName
	ColNames []string
}

type errorIfRowsArgs struct {
	Input *Node
	MkErr exec.MkErrFn
}

type opaqueArgs struct {
	Metadata opt.OpaqueMetadata
}

type alterTableSplitArgs struct {
	Index      cat.Index
	Input      *Node
	Expiration tree.TypedExpr
}

type alterTableUnsplitArgs struct {
	Index cat.Index
	Input *Node
}

type alterTableUnsplitAllArgs struct {
	Index cat.Index
}

type alterTableRelocateArgs struct {
	Index           cat.Index
	input           *Node
	subjectReplicas tree.RelocateSubject
}

type bufferArgs struct {
	Input *Node
	Label string
}

type scanBufferArgs struct {
	Ref   *Node
	Label string
}

type recursiveCTEArgs struct {
	Initial     *Node
	Fn          exec.RecursiveCTEIterationFn
	Label       string
	Deduplicate bool
}

type controlJobsArgs struct {
	Command tree.JobCommand
	input   *Node
	Reason  tree.TypedExpr
}

type controlSchedulesArgs struct {
	Command tree.ScheduleCommand
	input   *Node
}

type cancelQueriesArgs struct {
	Input    *Node
	IfExists bool
}

type cancelSessionsArgs struct {
	Input    *Node
	IfExists bool
}

type createStatisticsArgs struct {
	Cs *tree.CreateStats
}

type exportArgs struct {
	Input       *Node
	FileName    tree.TypedExpr
	FileFormat  string
	Options     []exec.KVOption
	NotNullCols exec.NodeColumnOrdinalSet
}

type alterRangeRelocateArgs struct {
	input           *Node
	subjectReplicas tree.RelocateSubject
	toStoreID       tree.TypedExpr
	fromStoreID     tree.TypedExpr
}

type createFunctionArgs struct {
	Schema   cat.Schema
	Cf       *tree.CreateFunction
	Deps     opt.SchemaDeps
	TypeDeps opt.SchemaTypeDeps
}

type literalValuesArgs struct {
	Rows    tree.ExprContainer
	Columns colinfo.ResultColumns
}
