// Code generated by optgen; DO NOT EDIT.

package explain

import (
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/colinfo"
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/cat"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/constraint"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/exec"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/invertedexpr"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

func (f *Factory) ConstructScan(
	table cat.Table,
	index cat.Index,
	params exec.ScanParams,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	args := &scanArgs{
		Table:       table,
		Index:       index,
		Params:      params,
		ReqOrdering: reqOrdering,
	}
	_n, err := f.newNode(scanOp, args, reqOrdering)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructScan(
		table,
		index,
		params,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructValues(
	rows [][]tree.TypedExpr,
	columns colinfo.ResultColumns,
) (exec.Node, error) {
	args := &valuesArgs{
		Rows:    rows,
		Columns: columns,
	}
	_n, err := f.newNode(valuesOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructValues(
		rows,
		columns,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructFilter(
	input exec.Node,
	filter tree.TypedExpr,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &filterArgs{
		Input:       inputNode,
		Filter:      filter,
		ReqOrdering: reqOrdering,
	}
	_n, err := f.newNode(filterOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructFilter(
		inputNode.WrappedNode(),
		filter,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructInvertedFilter(
	input exec.Node,
	invFilter *invertedexpr.SpanExpression,
	invColumn exec.NodeColumnOrdinal,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &invertedFilterArgs{
		Input:     inputNode,
		InvFilter: invFilter,
		InvColumn: invColumn,
	}
	_n, err := f.newNode(invertedFilterOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructInvertedFilter(
		inputNode.WrappedNode(),
		invFilter,
		invColumn,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSimpleProject(
	input exec.Node,
	cols []exec.NodeColumnOrdinal,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &simpleProjectArgs{
		Input:       inputNode,
		Cols:        cols,
		ReqOrdering: reqOrdering,
	}
	_n, err := f.newNode(simpleProjectOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSimpleProject(
		inputNode.WrappedNode(),
		cols,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSerializingProject(
	input exec.Node,
	cols []exec.NodeColumnOrdinal,
	colNames []string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &serializingProjectArgs{
		Input:    inputNode,
		Cols:     cols,
		ColNames: colNames,
	}
	_n, err := f.newNode(serializingProjectOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSerializingProject(
		inputNode.WrappedNode(),
		cols,
		colNames,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructRender(
	input exec.Node,
	columns colinfo.ResultColumns,
	exprs tree.TypedExprs,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &renderArgs{
		Input:       inputNode,
		Columns:     columns,
		Exprs:       exprs,
		ReqOrdering: reqOrdering,
	}
	_n, err := f.newNode(renderOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructRender(
		inputNode.WrappedNode(),
		columns,
		exprs,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructApplyJoin(
	joinType descpb.JoinType,
	left exec.Node,
	rightColumns colinfo.ResultColumns,
	onCond tree.TypedExpr,
	planRightSideFn exec.ApplyJoinPlanRightSideFn,
) (exec.Node, error) {
	leftNode := left.(*Node)
	args := &applyJoinArgs{
		JoinType:        joinType,
		Left:            leftNode,
		RightColumns:    rightColumns,
		OnCond:          onCond,
		PlanRightSideFn: planRightSideFn,
	}
	_n, err := f.newNode(applyJoinOp, args, nil /* ordering */, leftNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructApplyJoin(
		joinType,
		leftNode.WrappedNode(),
		rightColumns,
		onCond,
		planRightSideFn,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructHashJoin(
	joinType descpb.JoinType,
	left exec.Node,
	right exec.Node,
	leftEqCols []exec.NodeColumnOrdinal,
	rightEqCols []exec.NodeColumnOrdinal,
	leftEqColsAreKey bool,
	rightEqColsAreKey bool,
	extraOnCond tree.TypedExpr,
) (exec.Node, error) {
	leftNode := left.(*Node)
	rightNode := right.(*Node)
	args := &hashJoinArgs{
		JoinType:          joinType,
		Left:              leftNode,
		Right:             rightNode,
		LeftEqCols:        leftEqCols,
		RightEqCols:       rightEqCols,
		LeftEqColsAreKey:  leftEqColsAreKey,
		RightEqColsAreKey: rightEqColsAreKey,
		ExtraOnCond:       extraOnCond,
	}
	_n, err := f.newNode(hashJoinOp, args, nil /* ordering */, leftNode, rightNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructHashJoin(
		joinType,
		leftNode.WrappedNode(),
		rightNode.WrappedNode(),
		leftEqCols,
		rightEqCols,
		leftEqColsAreKey,
		rightEqColsAreKey,
		extraOnCond,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructMergeJoin(
	joinType descpb.JoinType,
	left exec.Node,
	right exec.Node,
	onCond tree.TypedExpr,
	leftOrdering colinfo.ColumnOrdering,
	rightOrdering colinfo.ColumnOrdering,
	reqOrdering exec.OutputOrdering,
	leftEqColsAreKey bool,
	rightEqColsAreKey bool,
) (exec.Node, error) {
	leftNode := left.(*Node)
	rightNode := right.(*Node)
	args := &mergeJoinArgs{
		JoinType:          joinType,
		Left:              leftNode,
		Right:             rightNode,
		OnCond:            onCond,
		LeftOrdering:      leftOrdering,
		RightOrdering:     rightOrdering,
		ReqOrdering:       reqOrdering,
		LeftEqColsAreKey:  leftEqColsAreKey,
		RightEqColsAreKey: rightEqColsAreKey,
	}
	_n, err := f.newNode(mergeJoinOp, args, reqOrdering, leftNode, rightNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructMergeJoin(
		joinType,
		leftNode.WrappedNode(),
		rightNode.WrappedNode(),
		onCond,
		leftOrdering,
		rightOrdering,
		reqOrdering,
		leftEqColsAreKey,
		rightEqColsAreKey,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructInterleavedJoin(
	joinType descpb.JoinType,
	leftTable cat.Table,
	leftIndex cat.Index,
	leftParams exec.ScanParams,
	leftFilter tree.TypedExpr,
	rightTable cat.Table,
	rightIndex cat.Index,
	rightParams exec.ScanParams,
	rightFilter tree.TypedExpr,
	leftIsAncestor bool,
	onCond tree.TypedExpr,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	args := &interleavedJoinArgs{
		JoinType:       joinType,
		LeftTable:      leftTable,
		LeftIndex:      leftIndex,
		LeftParams:     leftParams,
		LeftFilter:     leftFilter,
		RightTable:     rightTable,
		RightIndex:     rightIndex,
		RightParams:    rightParams,
		RightFilter:    rightFilter,
		LeftIsAncestor: leftIsAncestor,
		OnCond:         onCond,
		ReqOrdering:    reqOrdering,
	}
	_n, err := f.newNode(interleavedJoinOp, args, reqOrdering)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructInterleavedJoin(
		joinType,
		leftTable,
		leftIndex,
		leftParams,
		leftFilter,
		rightTable,
		rightIndex,
		rightParams,
		rightFilter,
		leftIsAncestor,
		onCond,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructGroupBy(
	input exec.Node,
	groupCols []exec.NodeColumnOrdinal,
	// If set, the input is guaranteed to have this ordering and a "streaming"
	// aggregation is performed (i.e. aggregation happens separately for each
	// distinct set of values on the set of columns in the ordering).
	groupColOrdering colinfo.ColumnOrdering,
	aggregations []exec.AggInfo,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &groupByArgs{
		Input:            inputNode,
		GroupCols:        groupCols,
		GroupColOrdering: groupColOrdering,
		Aggregations:     aggregations,
		ReqOrdering:      reqOrdering,
	}
	_n, err := f.newNode(groupByOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructGroupBy(
		inputNode.WrappedNode(),
		groupCols,
		groupColOrdering,
		aggregations,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructScalarGroupBy(
	input exec.Node,
	aggregations []exec.AggInfo,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &scalarGroupByArgs{
		Input:        inputNode,
		Aggregations: aggregations,
	}
	_n, err := f.newNode(scalarGroupByOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructScalarGroupBy(
		inputNode.WrappedNode(),
		aggregations,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructDistinct(
	input exec.Node,
	distinctCols exec.NodeColumnOrdinalSet,
	orderedCols exec.NodeColumnOrdinalSet,
	reqOrdering exec.OutputOrdering,
	nullsAreDistinct bool,
	errorOnDup string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &distinctArgs{
		Input:            inputNode,
		DistinctCols:     distinctCols,
		OrderedCols:      orderedCols,
		ReqOrdering:      reqOrdering,
		NullsAreDistinct: nullsAreDistinct,
		ErrorOnDup:       errorOnDup,
	}
	_n, err := f.newNode(distinctOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructDistinct(
		inputNode.WrappedNode(),
		distinctCols,
		orderedCols,
		reqOrdering,
		nullsAreDistinct,
		errorOnDup,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSetOp(
	typ tree.UnionType,
	all bool,
	left exec.Node,
	right exec.Node,
) (exec.Node, error) {
	leftNode := left.(*Node)
	rightNode := right.(*Node)
	args := &setOpArgs{
		Typ:   typ,
		All:   all,
		Left:  leftNode,
		Right: rightNode,
	}
	_n, err := f.newNode(setOpOp, args, nil /* ordering */, leftNode, rightNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSetOp(
		typ,
		all,
		leftNode.WrappedNode(),
		rightNode.WrappedNode(),
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSort(
	input exec.Node,
	ordering exec.OutputOrdering,
	alreadyOrderedPrefix int,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &sortArgs{
		Input:                inputNode,
		Ordering:             ordering,
		AlreadyOrderedPrefix: alreadyOrderedPrefix,
	}
	_n, err := f.newNode(sortOp, args, ordering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSort(
		inputNode.WrappedNode(),
		ordering,
		alreadyOrderedPrefix,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructOrdinality(
	input exec.Node,
	colName string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &ordinalityArgs{
		Input:   inputNode,
		ColName: colName,
	}
	_n, err := f.newNode(ordinalityOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructOrdinality(
		inputNode.WrappedNode(),
		colName,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructIndexJoin(
	input exec.Node,
	table cat.Table,
	keyCols []exec.NodeColumnOrdinal,
	tableCols exec.TableColumnOrdinalSet,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &indexJoinArgs{
		Input:       inputNode,
		Table:       table,
		KeyCols:     keyCols,
		TableCols:   tableCols,
		ReqOrdering: reqOrdering,
	}
	_n, err := f.newNode(indexJoinOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructIndexJoin(
		inputNode.WrappedNode(),
		table,
		keyCols,
		tableCols,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructLookupJoin(
	joinType descpb.JoinType,
	input exec.Node,
	table cat.Table,
	index cat.Index,
	eqCols []exec.NodeColumnOrdinal,
	eqColsAreKey bool,
	lookupCols exec.TableColumnOrdinalSet,
	onCond tree.TypedExpr,
	reqOrdering exec.OutputOrdering,
	locking *tree.LockingItem,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &lookupJoinArgs{
		JoinType:     joinType,
		Input:        inputNode,
		Table:        table,
		Index:        index,
		EqCols:       eqCols,
		EqColsAreKey: eqColsAreKey,
		LookupCols:   lookupCols,
		OnCond:       onCond,
		ReqOrdering:  reqOrdering,
		Locking:      locking,
	}
	_n, err := f.newNode(lookupJoinOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructLookupJoin(
		joinType,
		inputNode.WrappedNode(),
		table,
		index,
		eqCols,
		eqColsAreKey,
		lookupCols,
		onCond,
		reqOrdering,
		locking,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructInvertedJoin(
	joinType descpb.JoinType,
	invertedExpr tree.TypedExpr,
	input exec.Node,
	table cat.Table,
	index cat.Index,
	lookupCols exec.TableColumnOrdinalSet,
	onCond tree.TypedExpr,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &invertedJoinArgs{
		JoinType:     joinType,
		InvertedExpr: invertedExpr,
		Input:        inputNode,
		Table:        table,
		Index:        index,
		LookupCols:   lookupCols,
		OnCond:       onCond,
		ReqOrdering:  reqOrdering,
	}
	_n, err := f.newNode(invertedJoinOp, args, reqOrdering, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructInvertedJoin(
		joinType,
		invertedExpr,
		inputNode.WrappedNode(),
		table,
		index,
		lookupCols,
		onCond,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructZigzagJoin(
	// Left table and index.
	leftTable cat.Table,
	leftIndex cat.Index,
	// leftCols are the columns that are scanned from the left index.
	leftCols exec.TableColumnOrdinalSet,
	// leftFixedVals contains values for the fixed columns (a prefix of the
	// index columns).
	leftFixedVals []tree.TypedExpr,
	// leftEqCols are the left table columns that have equality constraints,
	// corresponding 1-1 to RightEqCols.
	leftEqCols []exec.TableColumnOrdinal,
	// Right table and index.
	rightTable cat.Table,
	rightIndex cat.Index,
	// rightCols are the columns that are scanned from the right index.
	rightCols exec.TableColumnOrdinalSet,
	// rightFixedVals contains values for the fixed columns (a prefix of the
	// index columns).
	rightFixedVals []tree.TypedExpr,
	// rightEqCols are the right table columns that have equality constraints,
	// corresponding 1-1 to LeftEqCols.
	rightEqCols []exec.TableColumnOrdinal,
	// onCond is an extra filter that is evaluated on the results.
	// TODO(radu): remove this (it can be a separate Select).
	onCond tree.TypedExpr,
	reqOrdering exec.OutputOrdering,
) (exec.Node, error) {
	args := &zigzagJoinArgs{
		LeftTable:      leftTable,
		LeftIndex:      leftIndex,
		LeftCols:       leftCols,
		LeftFixedVals:  leftFixedVals,
		LeftEqCols:     leftEqCols,
		RightTable:     rightTable,
		RightIndex:     rightIndex,
		RightCols:      rightCols,
		RightFixedVals: rightFixedVals,
		RightEqCols:    rightEqCols,
		OnCond:         onCond,
		ReqOrdering:    reqOrdering,
	}
	_n, err := f.newNode(zigzagJoinOp, args, reqOrdering)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructZigzagJoin(
		leftTable,
		leftIndex,
		leftCols,
		leftFixedVals,
		leftEqCols,
		rightTable,
		rightIndex,
		rightCols,
		rightFixedVals,
		rightEqCols,
		onCond,
		reqOrdering,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructLimit(
	input exec.Node,
	limit tree.TypedExpr,
	offset tree.TypedExpr,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &limitArgs{
		Input:  inputNode,
		Limit:  limit,
		Offset: offset,
	}
	_n, err := f.newNode(limitOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructLimit(
		inputNode.WrappedNode(),
		limit,
		offset,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructMax1Row(
	input exec.Node,
	errorText string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &max1RowArgs{
		Input:     inputNode,
		ErrorText: errorText,
	}
	_n, err := f.newNode(max1RowOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructMax1Row(
		inputNode.WrappedNode(),
		errorText,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructProjectSet(
	input exec.Node,
	exprs tree.TypedExprs,
	zipCols colinfo.ResultColumns,
	numColsPerGen []int,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &projectSetArgs{
		Input:         inputNode,
		Exprs:         exprs,
		ZipCols:       zipCols,
		NumColsPerGen: numColsPerGen,
	}
	_n, err := f.newNode(projectSetOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructProjectSet(
		inputNode.WrappedNode(),
		exprs,
		zipCols,
		numColsPerGen,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructWindow(
	input exec.Node,
	window exec.WindowInfo,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &windowArgs{
		Input:  inputNode,
		Window: window,
	}
	_n, err := f.newNode(windowOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructWindow(
		inputNode.WrappedNode(),
		window,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructExplainOpt(
	plan string,
	envOpts exec.ExplainEnvData,
) (exec.Node, error) {
	args := &explainOptArgs{
		Plan:    plan,
		EnvOpts: envOpts,
	}
	_n, err := f.newNode(explainOptOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructExplainOpt(
		plan,
		envOpts,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructExplain(
	options *tree.ExplainOptions,
	stmtType tree.StatementType,
	plan exec.Plan,
) (exec.Node, error) {
	args := &explainArgs{
		Options:  options,
		StmtType: stmtType,
		Plan:     plan,
	}
	_n, err := f.newNode(explainOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructExplain(
		options,
		stmtType,
		plan.(*Plan).WrappedPlan,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructExplainPlan(
	options *tree.ExplainOptions,
	buildFn exec.BuildPlanForExplainFn,
) (exec.Node, error) {
	args := &explainPlanArgs{
		Options: options,
		BuildFn: buildFn,
	}
	_n, err := f.newNode(explainPlanOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructExplainPlan(
		options,
		buildFn,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructShowTrace(
	typ tree.ShowTraceType,
	compact bool,
) (exec.Node, error) {
	args := &showTraceArgs{
		Typ:     typ,
		Compact: compact,
	}
	_n, err := f.newNode(showTraceOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructShowTrace(
		typ,
		compact,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructInsert(
	input exec.Node,
	table cat.Table,
	arbiters cat.IndexOrdinals,
	insertCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	checkCols exec.CheckOrdinalSet,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction, or there are
	// multiple mutations in a statement, or the output of the mutation is
	// processed through side-effecting expressions.
	autoCommit bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &insertArgs{
		Input:      inputNode,
		Table:      table,
		Arbiters:   arbiters,
		InsertCols: insertCols,
		ReturnCols: returnCols,
		CheckCols:  checkCols,
		AutoCommit: autoCommit,
	}
	_n, err := f.newNode(insertOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructInsert(
		inputNode.WrappedNode(),
		table,
		arbiters,
		insertCols,
		returnCols,
		checkCols,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructInsertFastPath(
	rows [][]tree.TypedExpr,
	table cat.Table,
	insertCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	checkCols exec.CheckOrdinalSet,
	fkChecks []exec.InsertFastPathFKCheck,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction.
	autoCommit bool,
) (exec.Node, error) {
	args := &insertFastPathArgs{
		Rows:       rows,
		Table:      table,
		InsertCols: insertCols,
		ReturnCols: returnCols,
		CheckCols:  checkCols,
		FkChecks:   fkChecks,
		AutoCommit: autoCommit,
	}
	_n, err := f.newNode(insertFastPathOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructInsertFastPath(
		rows,
		table,
		insertCols,
		returnCols,
		checkCols,
		fkChecks,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructUpdate(
	input exec.Node,
	table cat.Table,
	fetchCols exec.TableColumnOrdinalSet,
	updateCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	checks exec.CheckOrdinalSet,
	passthrough colinfo.ResultColumns,
	// If set, the operator will commit the transaction as part of its execution.
	autoCommit bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &updateArgs{
		Input:       inputNode,
		Table:       table,
		FetchCols:   fetchCols,
		UpdateCols:  updateCols,
		ReturnCols:  returnCols,
		Checks:      checks,
		Passthrough: passthrough,
		AutoCommit:  autoCommit,
	}
	_n, err := f.newNode(updateOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructUpdate(
		inputNode.WrappedNode(),
		table,
		fetchCols,
		updateCols,
		returnCols,
		checks,
		passthrough,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructUpsert(
	input exec.Node,
	table cat.Table,
	arbiters cat.IndexOrdinals,
	canaryCol exec.NodeColumnOrdinal,
	insertCols exec.TableColumnOrdinalSet,
	fetchCols exec.TableColumnOrdinalSet,
	updateCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	checks exec.CheckOrdinalSet,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction, or there are
	// multiple mutations in a statement, or the output of the mutation is
	// processed through side-effecting expressions.
	autoCommit bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &upsertArgs{
		Input:      inputNode,
		Table:      table,
		Arbiters:   arbiters,
		CanaryCol:  canaryCol,
		InsertCols: insertCols,
		FetchCols:  fetchCols,
		UpdateCols: updateCols,
		ReturnCols: returnCols,
		Checks:     checks,
		AutoCommit: autoCommit,
	}
	_n, err := f.newNode(upsertOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructUpsert(
		inputNode.WrappedNode(),
		table,
		arbiters,
		canaryCol,
		insertCols,
		fetchCols,
		updateCols,
		returnCols,
		checks,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructDelete(
	input exec.Node,
	table cat.Table,
	fetchCols exec.TableColumnOrdinalSet,
	returnCols exec.TableColumnOrdinalSet,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction, or there are
	// multiple mutations in a statement, or the output of the mutation is
	// processed through side-effecting expressions.
	autoCommit bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &deleteArgs{
		Input:      inputNode,
		Table:      table,
		FetchCols:  fetchCols,
		ReturnCols: returnCols,
		AutoCommit: autoCommit,
	}
	_n, err := f.newNode(deleteOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructDelete(
		inputNode.WrappedNode(),
		table,
		fetchCols,
		returnCols,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructDeleteRange(
	table cat.Table,
	needed exec.TableColumnOrdinalSet,
	indexConstraint *constraint.Constraint,
	interleavedTables []cat.Table,
	// If set, the operator will commit the transaction as part of its execution.
	// This is false when executing inside an explicit transaction, or there are
	// multiple mutations in a statement, or the output of the mutation is
	// processed through side-effecting expressions, or the operation might
	// process too many rows.
	autoCommit bool,
) (exec.Node, error) {
	args := &deleteRangeArgs{
		Table:             table,
		Needed:            needed,
		IndexConstraint:   indexConstraint,
		InterleavedTables: interleavedTables,
		AutoCommit:        autoCommit,
	}
	_n, err := f.newNode(deleteRangeOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructDeleteRange(
		table,
		needed,
		indexConstraint,
		interleavedTables,
		autoCommit,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCreateTable(
	schema cat.Schema,
	ct *tree.CreateTable,
) (exec.Node, error) {
	args := &createTableArgs{
		Schema: schema,
		Ct:     ct,
	}
	_n, err := f.newNode(createTableOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCreateTable(
		schema,
		ct,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCreateTableAs(
	input exec.Node,
	schema cat.Schema,
	ct *tree.CreateTable,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &createTableAsArgs{
		Input:  inputNode,
		Schema: schema,
		Ct:     ct,
	}
	_n, err := f.newNode(createTableAsOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCreateTableAs(
		inputNode.WrappedNode(),
		schema,
		ct,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCreateView(
	schema cat.Schema,
	viewName *cat.DataSourceName,
	ifNotExists bool,
	replace bool,
	persistence tree.Persistence,
	materialized bool,
	viewQuery string,
	columns colinfo.ResultColumns,
	deps opt.ViewDeps,
) (exec.Node, error) {
	args := &createViewArgs{
		Schema:       schema,
		ViewName:     viewName,
		IfNotExists:  ifNotExists,
		Replace:      replace,
		Persistence:  persistence,
		Materialized: materialized,
		ViewQuery:    viewQuery,
		Columns:      columns,
		deps:         deps,
	}
	_n, err := f.newNode(createViewOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCreateView(
		schema,
		viewName,
		ifNotExists,
		replace,
		persistence,
		materialized,
		viewQuery,
		columns,
		deps,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSequenceSelect(
	sequence cat.Sequence,
) (exec.Node, error) {
	args := &sequenceSelectArgs{
		Sequence: sequence,
	}
	_n, err := f.newNode(sequenceSelectOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSequenceSelect(
		sequence,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructSaveTable(
	input exec.Node,
	table *cat.DataSourceName,
	colNames []string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &saveTableArgs{
		Input:    inputNode,
		Table:    table,
		ColNames: colNames,
	}
	_n, err := f.newNode(saveTableOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructSaveTable(
		inputNode.WrappedNode(),
		table,
		colNames,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructErrorIfRows(
	input exec.Node,
	// mkErr is used to create the error; it is passed an input row.
	mkErr exec.MkErrFn,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &errorIfRowsArgs{
		Input: inputNode,
		MkErr: mkErr,
	}
	_n, err := f.newNode(errorIfRowsOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructErrorIfRows(
		inputNode.WrappedNode(),
		mkErr,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructOpaque(
	metadata opt.OpaqueMetadata,
) (exec.Node, error) {
	args := &opaqueArgs{
		Metadata: metadata,
	}
	_n, err := f.newNode(opaqueOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructOpaque(
		metadata,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructAlterTableSplit(
	index cat.Index,
	input exec.Node,
	expiration tree.TypedExpr,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &alterTableSplitArgs{
		Index:      index,
		Input:      inputNode,
		Expiration: expiration,
	}
	_n, err := f.newNode(alterTableSplitOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructAlterTableSplit(
		index,
		inputNode.WrappedNode(),
		expiration,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructAlterTableUnsplit(
	index cat.Index,
	input exec.Node,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &alterTableUnsplitArgs{
		Index: index,
		Input: inputNode,
	}
	_n, err := f.newNode(alterTableUnsplitOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructAlterTableUnsplit(
		index,
		inputNode.WrappedNode(),
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructAlterTableUnsplitAll(
	index cat.Index,
) (exec.Node, error) {
	args := &alterTableUnsplitAllArgs{
		Index: index,
	}
	_n, err := f.newNode(alterTableUnsplitAllOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructAlterTableUnsplitAll(
		index,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructAlterTableRelocate(
	index cat.Index,
	input exec.Node,
	relocateLease bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &alterTableRelocateArgs{
		Index:         index,
		input:         inputNode,
		relocateLease: relocateLease,
	}
	_n, err := f.newNode(alterTableRelocateOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructAlterTableRelocate(
		index,
		inputNode.WrappedNode(),
		relocateLease,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructBuffer(
	input exec.Node,
	label string,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &bufferArgs{
		Input: inputNode,
		Label: label,
	}
	_n, err := f.newNode(bufferOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructBuffer(
		inputNode.WrappedNode(),
		label,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructScanBuffer(
	ref exec.Node,
	label string,
) (exec.Node, error) {
	refNode := ref.(*Node)
	args := &scanBufferArgs{
		Ref:   refNode,
		Label: label,
	}
	_n, err := f.newNode(scanBufferOp, args, nil /* ordering */)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructScanBuffer(
		refNode.WrappedNode(),
		label,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructRecursiveCTE(
	initial exec.Node,
	fn exec.RecursiveCTEIterationFn,
	label string,
) (exec.Node, error) {
	initialNode := initial.(*Node)
	args := &recursiveCTEArgs{
		Initial: initialNode,
		Fn:      fn,
		Label:   label,
	}
	_n, err := f.newNode(recursiveCTEOp, args, nil /* ordering */, initialNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructRecursiveCTE(
		initialNode.WrappedNode(),
		fn,
		label,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructControlJobs(
	command tree.JobCommand,
	input exec.Node,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &controlJobsArgs{
		Command: command,
		input:   inputNode,
	}
	_n, err := f.newNode(controlJobsOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructControlJobs(
		command,
		inputNode.WrappedNode(),
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructControlSchedules(
	command tree.ScheduleCommand,
	input exec.Node,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &controlSchedulesArgs{
		Command: command,
		input:   inputNode,
	}
	_n, err := f.newNode(controlSchedulesOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructControlSchedules(
		command,
		inputNode.WrappedNode(),
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCancelQueries(
	input exec.Node,
	ifExists bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &cancelQueriesArgs{
		Input:    inputNode,
		IfExists: ifExists,
	}
	_n, err := f.newNode(cancelQueriesOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCancelQueries(
		inputNode.WrappedNode(),
		ifExists,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructCancelSessions(
	input exec.Node,
	ifExists bool,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &cancelSessionsArgs{
		Input:    inputNode,
		IfExists: ifExists,
	}
	_n, err := f.newNode(cancelSessionsOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructCancelSessions(
		inputNode.WrappedNode(),
		ifExists,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

func (f *Factory) ConstructExport(
	input exec.Node,
	fileName tree.TypedExpr,
	fileFormat string,
	options []exec.KVOption,
) (exec.Node, error) {
	inputNode := input.(*Node)
	args := &exportArgs{
		Input:      inputNode,
		FileName:   fileName,
		FileFormat: fileFormat,
		Options:    options,
	}
	_n, err := f.newNode(exportOp, args, nil /* ordering */, inputNode)
	if err != nil {
		return nil, err
	}
	// Build the "real" node.
	wrapped, err := f.wrappedFactory.ConstructExport(
		inputNode.WrappedNode(),
		fileName,
		fileFormat,
		options,
	)
	if err != nil {
		return nil, err
	}
	_n.wrappedNode = wrapped
	return _n, nil
}

type execOperator int

const (
	unknownOp execOperator = iota
	scanOp
	valuesOp
	filterOp
	invertedFilterOp
	simpleProjectOp
	serializingProjectOp
	renderOp
	applyJoinOp
	hashJoinOp
	mergeJoinOp
	interleavedJoinOp
	groupByOp
	scalarGroupByOp
	distinctOp
	setOpOp
	sortOp
	ordinalityOp
	indexJoinOp
	lookupJoinOp
	invertedJoinOp
	zigzagJoinOp
	limitOp
	max1RowOp
	projectSetOp
	windowOp
	explainOptOp
	explainOp
	explainPlanOp
	showTraceOp
	insertOp
	insertFastPathOp
	updateOp
	upsertOp
	deleteOp
	deleteRangeOp
	createTableOp
	createTableAsOp
	createViewOp
	sequenceSelectOp
	saveTableOp
	errorIfRowsOp
	opaqueOp
	alterTableSplitOp
	alterTableUnsplitOp
	alterTableUnsplitAllOp
	alterTableRelocateOp
	bufferOp
	scanBufferOp
	recursiveCTEOp
	controlJobsOp
	controlSchedulesOp
	cancelQueriesOp
	cancelSessionsOp
	exportOp
)

type scanArgs struct {
	Table       cat.Table
	Index       cat.Index
	Params      exec.ScanParams
	ReqOrdering exec.OutputOrdering
}

type valuesArgs struct {
	Rows    [][]tree.TypedExpr
	Columns colinfo.ResultColumns
}

type filterArgs struct {
	Input       *Node
	Filter      tree.TypedExpr
	ReqOrdering exec.OutputOrdering
}

type invertedFilterArgs struct {
	Input     *Node
	InvFilter *invertedexpr.SpanExpression
	InvColumn exec.NodeColumnOrdinal
}

type simpleProjectArgs struct {
	Input       *Node
	Cols        []exec.NodeColumnOrdinal
	ReqOrdering exec.OutputOrdering
}

type serializingProjectArgs struct {
	Input    *Node
	Cols     []exec.NodeColumnOrdinal
	ColNames []string
}

type renderArgs struct {
	Input       *Node
	Columns     colinfo.ResultColumns
	Exprs       tree.TypedExprs
	ReqOrdering exec.OutputOrdering
}

type applyJoinArgs struct {
	JoinType        descpb.JoinType
	Left            *Node
	RightColumns    colinfo.ResultColumns
	OnCond          tree.TypedExpr
	PlanRightSideFn exec.ApplyJoinPlanRightSideFn
}

type hashJoinArgs struct {
	JoinType          descpb.JoinType
	Left              *Node
	Right             *Node
	LeftEqCols        []exec.NodeColumnOrdinal
	RightEqCols       []exec.NodeColumnOrdinal
	LeftEqColsAreKey  bool
	RightEqColsAreKey bool
	ExtraOnCond       tree.TypedExpr
}

type mergeJoinArgs struct {
	JoinType          descpb.JoinType
	Left              *Node
	Right             *Node
	OnCond            tree.TypedExpr
	LeftOrdering      colinfo.ColumnOrdering
	RightOrdering     colinfo.ColumnOrdering
	ReqOrdering       exec.OutputOrdering
	LeftEqColsAreKey  bool
	RightEqColsAreKey bool
}

type interleavedJoinArgs struct {
	JoinType       descpb.JoinType
	LeftTable      cat.Table
	LeftIndex      cat.Index
	LeftParams     exec.ScanParams
	LeftFilter     tree.TypedExpr
	RightTable     cat.Table
	RightIndex     cat.Index
	RightParams    exec.ScanParams
	RightFilter    tree.TypedExpr
	LeftIsAncestor bool
	OnCond         tree.TypedExpr
	ReqOrdering    exec.OutputOrdering
}

type groupByArgs struct {
	Input            *Node
	GroupCols        []exec.NodeColumnOrdinal
	GroupColOrdering colinfo.ColumnOrdering
	Aggregations     []exec.AggInfo
	ReqOrdering      exec.OutputOrdering
}

type scalarGroupByArgs struct {
	Input        *Node
	Aggregations []exec.AggInfo
}

type distinctArgs struct {
	Input            *Node
	DistinctCols     exec.NodeColumnOrdinalSet
	OrderedCols      exec.NodeColumnOrdinalSet
	ReqOrdering      exec.OutputOrdering
	NullsAreDistinct bool
	ErrorOnDup       string
}

type setOpArgs struct {
	Typ   tree.UnionType
	All   bool
	Left  *Node
	Right *Node
}

type sortArgs struct {
	Input                *Node
	Ordering             exec.OutputOrdering
	AlreadyOrderedPrefix int
}

type ordinalityArgs struct {
	Input   *Node
	ColName string
}

type indexJoinArgs struct {
	Input       *Node
	Table       cat.Table
	KeyCols     []exec.NodeColumnOrdinal
	TableCols   exec.TableColumnOrdinalSet
	ReqOrdering exec.OutputOrdering
}

type lookupJoinArgs struct {
	JoinType     descpb.JoinType
	Input        *Node
	Table        cat.Table
	Index        cat.Index
	EqCols       []exec.NodeColumnOrdinal
	EqColsAreKey bool
	LookupCols   exec.TableColumnOrdinalSet
	OnCond       tree.TypedExpr
	ReqOrdering  exec.OutputOrdering
	Locking      *tree.LockingItem
}

type invertedJoinArgs struct {
	JoinType     descpb.JoinType
	InvertedExpr tree.TypedExpr
	Input        *Node
	Table        cat.Table
	Index        cat.Index
	LookupCols   exec.TableColumnOrdinalSet
	OnCond       tree.TypedExpr
	ReqOrdering  exec.OutputOrdering
}

type zigzagJoinArgs struct {
	LeftTable      cat.Table
	LeftIndex      cat.Index
	LeftCols       exec.TableColumnOrdinalSet
	LeftFixedVals  []tree.TypedExpr
	LeftEqCols     []exec.TableColumnOrdinal
	RightTable     cat.Table
	RightIndex     cat.Index
	RightCols      exec.TableColumnOrdinalSet
	RightFixedVals []tree.TypedExpr
	RightEqCols    []exec.TableColumnOrdinal
	OnCond         tree.TypedExpr
	ReqOrdering    exec.OutputOrdering
}

type limitArgs struct {
	Input  *Node
	Limit  tree.TypedExpr
	Offset tree.TypedExpr
}

type max1RowArgs struct {
	Input     *Node
	ErrorText string
}

type projectSetArgs struct {
	Input         *Node
	Exprs         tree.TypedExprs
	ZipCols       colinfo.ResultColumns
	NumColsPerGen []int
}

type windowArgs struct {
	Input  *Node
	Window exec.WindowInfo
}

type explainOptArgs struct {
	Plan    string
	EnvOpts exec.ExplainEnvData
}

type explainArgs struct {
	Options  *tree.ExplainOptions
	StmtType tree.StatementType
	Plan     exec.Plan
}

type explainPlanArgs struct {
	Options *tree.ExplainOptions
	BuildFn exec.BuildPlanForExplainFn
}

type showTraceArgs struct {
	Typ     tree.ShowTraceType
	Compact bool
}

type insertArgs struct {
	Input      *Node
	Table      cat.Table
	Arbiters   cat.IndexOrdinals
	InsertCols exec.TableColumnOrdinalSet
	ReturnCols exec.TableColumnOrdinalSet
	CheckCols  exec.CheckOrdinalSet
	AutoCommit bool
}

type insertFastPathArgs struct {
	Rows       [][]tree.TypedExpr
	Table      cat.Table
	InsertCols exec.TableColumnOrdinalSet
	ReturnCols exec.TableColumnOrdinalSet
	CheckCols  exec.CheckOrdinalSet
	FkChecks   []exec.InsertFastPathFKCheck
	AutoCommit bool
}

type updateArgs struct {
	Input       *Node
	Table       cat.Table
	FetchCols   exec.TableColumnOrdinalSet
	UpdateCols  exec.TableColumnOrdinalSet
	ReturnCols  exec.TableColumnOrdinalSet
	Checks      exec.CheckOrdinalSet
	Passthrough colinfo.ResultColumns
	AutoCommit  bool
}

type upsertArgs struct {
	Input      *Node
	Table      cat.Table
	Arbiters   cat.IndexOrdinals
	CanaryCol  exec.NodeColumnOrdinal
	InsertCols exec.TableColumnOrdinalSet
	FetchCols  exec.TableColumnOrdinalSet
	UpdateCols exec.TableColumnOrdinalSet
	ReturnCols exec.TableColumnOrdinalSet
	Checks     exec.CheckOrdinalSet
	AutoCommit bool
}

type deleteArgs struct {
	Input      *Node
	Table      cat.Table
	FetchCols  exec.TableColumnOrdinalSet
	ReturnCols exec.TableColumnOrdinalSet
	AutoCommit bool
}

type deleteRangeArgs struct {
	Table             cat.Table
	Needed            exec.TableColumnOrdinalSet
	IndexConstraint   *constraint.Constraint
	InterleavedTables []cat.Table
	AutoCommit        bool
}

type createTableArgs struct {
	Schema cat.Schema
	Ct     *tree.CreateTable
}

type createTableAsArgs struct {
	Input  *Node
	Schema cat.Schema
	Ct     *tree.CreateTable
}

type createViewArgs struct {
	Schema       cat.Schema
	ViewName     *cat.DataSourceName
	IfNotExists  bool
	Replace      bool
	Persistence  tree.Persistence
	Materialized bool
	ViewQuery    string
	Columns      colinfo.ResultColumns
	deps         opt.ViewDeps
}

type sequenceSelectArgs struct {
	Sequence cat.Sequence
}

type saveTableArgs struct {
	Input    *Node
	Table    *cat.DataSourceName
	ColNames []string
}

type errorIfRowsArgs struct {
	Input *Node
	MkErr exec.MkErrFn
}

type opaqueArgs struct {
	Metadata opt.OpaqueMetadata
}

type alterTableSplitArgs struct {
	Index      cat.Index
	Input      *Node
	Expiration tree.TypedExpr
}

type alterTableUnsplitArgs struct {
	Index cat.Index
	Input *Node
}

type alterTableUnsplitAllArgs struct {
	Index cat.Index
}

type alterTableRelocateArgs struct {
	Index         cat.Index
	input         *Node
	relocateLease bool
}

type bufferArgs struct {
	Input *Node
	Label string
}

type scanBufferArgs struct {
	Ref   *Node
	Label string
}

type recursiveCTEArgs struct {
	Initial *Node
	Fn      exec.RecursiveCTEIterationFn
	Label   string
}

type controlJobsArgs struct {
	Command tree.JobCommand
	input   *Node
}

type controlSchedulesArgs struct {
	Command tree.ScheduleCommand
	input   *Node
}

type cancelQueriesArgs struct {
	Input    *Node
	IfExists bool
}

type cancelSessionsArgs struct {
	Input    *Node
	IfExists bool
}

type exportArgs struct {
	Input      *Node
	FileName   tree.TypedExpr
	FileFormat string
	Options    []exec.KVOption
}
