// Code generated by optgen; DO NOT EDIT.

package opt

const (
	UnknownOp Operator = iota

	// AggDistinct is used as a modifier that wraps an aggregate function. It causes
	// the respective aggregation to only process each distinct value once.
	AggDistinctOp

	// AggFilter is used as a modifier that wraps an aggregate function (or an
	// AggDistinct operator that wraps an aggregate function). It causes only rows
	// for which the filter expression is true to be processed. AggFilter should
	// always occur on top of AggDistinct if they are both present.
	AggFilterOp

	// Aggregations is a set of AggregationsItem expressions that specify the
	// ColumnIDs and aggregation expression for output columns projected by a
	// containing grouping operator (GroupBy, ScalarGroupBy, or DistinctOn). It is
	// legal for the set to be empty. See the AggregationsItem header for more
	// details.
	AggregationsOp

	// AggregationsItem encapsulates the information for constructing an aggregate
	// output column, including its ColumnID and the aggregate expression that
	// produces its value. In addition, the AggregationsItem caches a set of scalar
	// properties that are lazily calculated by traversing the Agg scalar expression.
	// This allows the properties for the aggregate expression to be calculated once
	// and then repeatedly reused.
	//
	// The aggregate expression can only consist of aggregate functions, variable
	// references, and modifiers like AggDistinct. Examples of valid expressions:
	//
	//   (Min (Variable 1))
	//   (Count (AggDistinct (Variable 1)))
	//
	// More complex arguments must be formulated using a Project operator as input to
	// the grouping operator.
	AggregationsItemOp

	// AlterRangeRelocate represents an `ALTER RANGE .. RELOCATE ..` statement.
	AlterRangeRelocateOp

	AlterRangeRelocatePrivateOp

	// AlterTableRelocate represents an `ALTER TABLE/INDEX .. SPLIT AT ..` statement.
	AlterTableRelocateOp

	AlterTableRelocatePrivateOp

	// AlterTableSplit represents an `ALTER TABLE/INDEX .. SPLIT AT ..` statement.
	AlterTableSplitOp

	AlterTableSplitPrivateOp

	// AlterTableUnsplit represents an `ALTER TABLE/INDEX .. UNSPLIT AT ..`
	// statement.
	AlterTableUnsplitOp

	// AlterTableUnsplit represents an `ALTER TABLE/INDEX .. UNSPLIT ALL` statement.
	AlterTableUnsplitAllOp

	// And is the boolean conjunction operator that evaluates to true only if both of
	// its conditions evaluate to true.
	AndOp

	AntiJoinOp

	AntiJoinApplyOp

	// Any is a SQL operator that applies a comparison to every row of an input
	// subquery and returns true if any of the comparisons are true, else returns
	// null if any of the comparisons are null, else returns false. The following
	// transformations map from various SQL operators into the Any operator:
	//
	//   <scalar> IN (<subquery>)
	//   ==> (Any <subquery> <scalar> EqOp)
	//
	//   <scalar> NOT IN (<subquery>)
	//   ==> (Not (Any <subquery> <scalar> EqOp))
	//
	//   <scalar> <cmp> {SOME|ANY}(<subquery>)
	//   ==> (Any <subquery> <scalar> <cmp>)
	//
	//   <scalar> <cmp> ALL(<subquery>)
	//   ==> (Not (Any <subquery> <scalar> <negated-cmp>))
	//
	// Any expects the input subquery to return a single column of any data type. The
	// scalar value is compared with that column using the specified comparison
	// operator.
	AnyOp

	// AnyNotNullAgg returns any non-NULL value it receives, with no other guarantees.
	// If it does not receive any values, it returns NULL.
	//
	// AnyNotNullAgg is not part of SQL, but it's used internally to rewrite
	// correlated subqueries into an efficient and convenient form.
	AnyNotNullAggOp

	// AnyScalar is the form of ANY which refers to an ANY operation on a
	// tuple or array, as opposed to Any which operates on a subquery.
	AnyScalarOp

	// Array is an ARRAY literal of the form ARRAY[<expr1>, <expr2>, ..., <exprN>].
	ArrayOp

	ArrayAggOp

	// ArrayFlatten is an ARRAY(<subquery>) expression. ArrayFlatten takes as input
	// a subquery which returns a single column and constructs a scalar array as the
	// output. Any NULLs are included in the results, and if the subquery has an
	// ORDER BY clause that ordering will be respected by the resulting array.
	ArrayFlattenOp

	// AssignmentCast is similar to CastExpr, but is performed in the context of an
	// INSERT, UPDATE, or UPSERT to match the type of a mutation value to the type of
	// the target column. An expression separate from CastExpr is required because it
	// behaves slightly differently than an explicit cast. For example, while an
	// explicit cast will truncate a value to fit the width of a type, an assignment
	// cast will error instead if the value does not fit the type. See
	// tree.CastContext for more details.
	//
	// An assignment cast is represented as a distinct expression within the
	// optimizer, but is built into a crdb_internal.assignment_cast function call in
	// execbuilder.
	AssignmentCastOp

	AvgOp

	// BBoxCovers is the ~ operator when used with geometry or bounding box
	// operands. It maps to tree.RegMatch.
	BBoxCoversOp

	// BBoxIntersects is the && operator when used with geometry or bounding box
	// operands. It maps to tree.Overlaps.
	BBoxIntersectsOp

	BitAndAggOp

	BitOrAggOp

	BitandOp

	BitorOp

	BitxorOp

	BoolAndOp

	BoolOrOp

	CancelPrivateOp

	// CancelQueries represents a `CANCEL QUERIES` statement.
	CancelQueriesOp

	// CancelSessions represents a `CANCEL SESSIONS` statement.
	CancelSessionsOp

	// Case is a CASE statement of the form:
	//
	//   CASE [ <Input> ]
	//       WHEN <condval1> THEN <expr1>
	//     [ WHEN <condval2> THEN <expr2> ] ...
	//     [ ELSE <expr> ]
	//   END
	//
	// The Case operator evaluates <Input> (if not provided, Input is set to True),
	// then picks the WHEN branch where <condval> is equal to <Input>, then evaluates
	// and returns the corresponding THEN expression. If no WHEN branch matches, the
	// ELSE expression is evaluated and returned, if any. Otherwise, NULL is
	// returned.
	//
	// Note that the Whens list inside Case is used to represent all the WHEN
	// branches. It is of the form:
	//
	//   [(When <condval1> <expr1>),(When <condval2> <expr2>),...]
	//
	CaseOp

	// Cast converts the input expression into an expression of the target type. Note
	// that the conversion may cause truncation based on the target types' width,
	// such as in this example:
	//
	//   'hello'::VARCHAR(2)
	//
	// That expression has the effect of truncating the string to just 'he', since
	// the target data type allows a maximum of two characters. This is one example
	// of a "lossy" cast.
	CastOp

	CoalesceOp

	// Collate is an expression of the form
	//
	//     x COLLATE y
	//
	// Where x is a "string type" (meaning either a normal string or a collated string),
	// and y is a locale. It evaluates to the string collated to the given locale.
	CollateOp

	// ColumnAccess is a scalar expression that returns a column from the given
	// input expression (which is assumed to be of type Tuple). Idx is the ordinal
	// index of the column in Input.
	ColumnAccessOp

	ConcatOp

	ConcatAggOp

	// Const is a typed scalar constant value. The Value field is a tree.Datum value
	// having any datum type that's legal in the expression's context. Do NOT call
	// ConstructConst directly; use ConstructConstVal instead.
	ConstOp

	// ConstAgg is used in the special case when the value of a column is known to be
	// constant within a grouping set; it returns that value. If there are no rows
	// in the grouping set, then ConstAgg returns NULL.
	//
	// ConstAgg is not part of SQL, but it's used internally to rewrite correlated
	// subqueries into an efficient and convenient form.
	ConstAggOp

	// ConstNotNullAgg is used in the special case when the value of a column is
	// known to be constant within a grouping set, except on some rows where it can
	// have a NULL value; it returns the non-NULL constant value. If there are no
	// rows in the grouping set, or all rows have a NULL value, then ConstNotNullAgg
	// returns NULL.
	//
	// ConstNotNullAgg is not part of SQL, but it's used internally to rewrite
	// correlated subqueries into an efficient and convenient form.
	ConstNotNullAggOp

	ContainedByOp

	ContainsOp

	// ControlJobs represents a `PAUSE/CANCEL/RESUME JOBS` statement.
	ControlJobsOp

	ControlJobsPrivateOp

	// ControlSchedules represents a `PAUSE/CANCEL/RESUME SCHEDULES` statement.
	ControlSchedulesOp

	ControlSchedulesPrivateOp

	CorrOp

	CountOp

	CountRowsOp

	CovarPopOp

	CovarSampOp

	// CreateFunction represents a CREATE FUNCTION statement.
	CreateFunctionOp

	CreateFunctionPrivateOp

	// CreateStatistics represents a CREATE STATISTICS or ANALYZE statement.
	CreateStatisticsOp

	CreateStatisticsPrivateOp

	// CreateTable represents a CREATE TABLE statement.
	CreateTableOp

	CreateTablePrivateOp

	CreateViewOp

	CreateViewPrivateOp

	// CumeDist is the relative rank of the current row:
	// (number of rows preceding or peer with current row) / (total rows)
	CumeDistOp

	// Delete is an operator used to delete all rows that are selected by a
	// relational input expression:
	//
	//   DELETE FROM abc WHERE a>0 ORDER BY b LIMIT 10
	//
	DeleteOp

	// DenseRank is like Rank, but without gaps. Instead of 1, 1, 3, it gives 1, 1, 2.
	DenseRankOp

	// DistinctOn filters out rows that are identical on the set of grouping columns;
	// only the first row (according to an ordering) is kept for each set of possible
	// values. It is roughly equivalent with a GroupBy on the same grouping columns
	// except that it uses FirstAgg functions that ensure the value on the first row
	// is chosen (across all aggregations).
	//
	// In addition, the value on that first row must be chosen for all the grouping
	// columns as well; this is relevant in the case of equal but non-identical
	// values, like decimals. For example, if we have rows (1, 2.0) and (1.0, 2) and
	// we are grouping on these two columns, the values output can be either (1, 2.0)
	// or (1.0, 2), but not (1.0, 2.0).
	//
	// The execution of DistinctOn resembles that of Select more than that of
	// GroupBy: each row is tested against a map of what groups we have seen already,
	// and is either passed through or discarded. In particular, note that this
	// preserves the input ordering.
	//
	// The ordering in the GroupingPrivate field will be required of the input; it
	// determines which row can get "chosen" for each group of values on the grouping
	// columns. There is no restriction on the ordering; but note that grouping
	// columns are inconsequential - they can appear anywhere in the ordering and
	// they won't change the results (other than the result ordering).
	//
	// Currently when we build DistinctOn, we set all grouping columns as optional
	// cols in Ordering (but this is not required by the operator).
	//
	// TODO(radu): in the future we may want an exploration transform to try out more
	// specific interesting orderings because execution is more efficient when we can
	// rely on an ordering on the grouping columns (or a subset of them).
	//
	// DistinctOn uses an Aggregations child and the GroupingPrivate struct so that
	// it's polymorphic with GroupBy and can be used in the same rules (when
	// appropriate). In the DistinctOn case, the aggregations can be only FirstAgg or
	// ConstAgg.
	DistinctOnOp

	// Distribute enforces the physical distribution of rows returned by its input
	// expression. Currently, it is only used to re-distribute data across different
	// sets of regions in a multi-region cluster. For example, if rows are spread
	// across multiple regions, a Distribute enforcer can be used to route the rows
	// to the gateway region. See the Distribution field in the PhysicalProps struct.
	// TODO(rytaft): We should probably include the input distribution here so we can
	// accurately cost the Distribute operator. This will likely require calculating
	// "interesting distributions", similar to "interesting orderings".
	DistributeOp

	DivOp

	// EnsureDistinctOn is a variation on DistinctOn that is only used to replace a
	// Max1Row operator in a decorrelation attempt. It raises an error if any
	// distinct grouping contains more than one row. Or in other words, it "ensures"
	// that the input is distinct on the grouping columns.
	//
	// EnsureDistinctOn is used when nulls are not considered distinct for grouping
	// purposes and an error should be raised when duplicates are detected.
	//
	// Rules should only "push through" or eliminate an EnsureDistinctOn if they
	// preserve the expected error behavior. For example, it would be invalid to
	// push a Select filter into an EnsureDistinctOn, as it might eliminate rows
	// that would otherwise trigger the EnsureDistinctOn error.
	EnsureDistinctOnOp

	// EnsureUpsertDistinctOn is a variation on UpsertDistinctOn that is only used
	// with UPSERT and INSERT..ON CONFLICT statements. Like UpsertDistinctOn,
	// EnsureUpsertDistinctOn treats NULL values as not equal to one another for
	// purposes of grouping. Unlike UpsertDistinctOn, it raises an error if any
	// distinct grouping contains more than one row. Or in other words, it "ensures"
	// that the input is distinct on the grouping columns.
	//
	// EnsureUpsertDistinctOn is used when nulls are considered distinct for grouping
	// purposes and an error should be raised when duplicates are detected.
	//
	// Rules should only "push through" or eliminate an EnsureUpsertDistinctOn if
	// they preserve the expected error behavior. For example, it would be invalid to
	// push a Select filter into an EnsureUpsertDistinctOn, as it might eliminate
	// rows that would otherwise trigger the EnsureUpsertDistinctOn error.
	EnsureUpsertDistinctOnOp

	EqOp

	// Except is an operator used to perform a set difference between the Left and
	// Right input relations. The result consists only of rows in the Left relation
	// that are not present in the Right relation. Duplicate rows are discarded.
	// The SetPrivate field matches columns from the Left and Right inputs of the Except
	// with the output columns. See the comment above SetPrivate for more details.
	ExceptOp

	// ExceptAll is an operator used to perform a set difference between the Left
	// and Right input relations. The result consists only of rows in the Left
	// relation that do not have a corresponding row in the Right relation.
	// Duplicate rows are not discarded. This effectively creates a one-to-one
	// mapping between the Left and Right rows. For example:
	//   SELECT x FROM xx EXCEPT ALL SELECT y FROM yy
	//     x       y         out
	//   -----   -----      -----
	//     1       1    ->    1
	//     1       1          4
	//     1       2
	//     2       2
	//     2       3
	//     4
	//
	// The SetPrivate field matches columns from the Left and Right inputs of the
	// ExceptAll with the output columns. See the comment above SetPrivate for more
	// details.
	ExceptAllOp

	// Exists takes a relational query as its input, and evaluates to true if the
	// query returns at least one row.
	ExistsOp

	// Explain returns information about the execution plan of the "input"
	// expression.
	ExplainOp

	ExplainPrivateOp

	// Export represents an `EXPORT` statement.
	ExportOp

	ExportPrivateOp

	// FKChecks is a list of foreign key check queries, to be run after the main
	// query.
	FKChecksOp

	// FKChecksItem is a foreign key check query, to be run after the main query.
	// An execution error will be generated if the query returns any results.
	FKChecksItemOp

	FKChecksItemPrivateOp

	// FakeRel is a mock relational operator used for testing and as a dummy binding
	// relation for building cascades; its logical properties are pre-determined and
	// stored in the private. It can be used as the child of an operator for which we
	// are calculating properties or statistics.
	FakeRelOp

	FakeRelPrivateOp

	// False is the boolean false value that is equivalent to the tree.DBoolFalse
	// datum value. It is a separate operator to make matching and replacement
	// simpler and more efficient, as patterns can contain (False) expressions.
	FalseOp

	FetchTextOp

	FetchTextPathOp

	FetchValOp

	FetchValPathOp

	// Filters is a set of FiltersItem expressions that specify a set of conjuncts
	// that filter rows selected by a containing Select or Join operator. A row is
	// filtered only if all conditions evaluate to true. If the set is empty, then
	// it never filters rows. See the Select and FiltersItem headers for more
	// details.
	FiltersOp

	// FiltersItem contains a filter condition that's evaluated to determine whether
	// Select or Join rows should be filtered. In addition, the FiltersItem caches a
	// set of scalar properties that are calculated by traversing the Condition
	// scalar expression. This allows the properties for the entire expression
	// subtree to be calculated once and then repeatedly reused.
	FiltersItemOp

	// FirstAgg is used only by DistinctOn; it returns the value on the first row
	// according to an ordering; if the ordering is unspecified (or partially
	// specified), it is an arbitrary ordering but it must be the same across all
	// FirstAggs in a DistinctOn.
	FirstAggOp

	// FirstValue returns Value evaluated at the first row in the row's frame.
	// TODO(justin): can this be unified with FirstAgg?
	FirstValueOp

	FloorDivOp

	FullJoinOp

	// Function invokes a builtin SQL function like CONCAT or NOW, passing the given
	// arguments. The FunctionPrivate field contains the name of the function as well
	// as pointers to its type and properties.
	FunctionOp

	FunctionPrivateOp

	GeOp

	// GroupBy computes aggregate functions over groups of input rows. Input rows
	// that are equal on the grouping columns are grouped together. The set of
	// computed aggregate functions is described by the Aggregations field (which is
	// always an Aggregations operator).
	//
	// The arguments of the aggregate functions are columns from the input
	// (i.e. Variables), possibly wrapped in aggregate modifiers like AggDistinct.
	//
	// If the set of input rows is empty, then the output of the GroupBy operator
	// will also be empty. If the grouping columns are empty, then all input rows
	// form a single group. GroupBy is used for queries with aggregate functions,
	// HAVING clauses and/or GROUP BY expressions.
	//
	// The GroupingPrivate field contains an ordering; this ordering serves a
	// dual-purpose:
	//  - if we ignore any grouping columns, the remaining columns indicate an
	//    intra-group ordering; this is useful if there is an order-dependent
	//    aggregation (like ARRAY_AGG).
	//  - any prefix containing only grouping columns is used to execute the
	//    aggregation in a streaming fashion.
	//
	// Currently, the initially built GroupBy has all grouping columns as "optional"
	// in the ordering (we call this the "canonical" variant). Subsequently, the
	// GenerateStreamingGroupBy exploration rule can add more variants, based on
	// interesting orderings.
	GroupByOp

	// GroupingPrivate is shared between the grouping-related operators: GroupBy
	// ScalarGroupBy, DistinctOn, EnsureDistinctOn, UpsertDistinctOn, and
	// EnsureUpsertDistinctOn. This allows the operators to be treated
	// polymorphically.
	GroupingPrivateOp

	GtOp

	ILikeOp

	// IfErr is roughly a runtime try-catch operator. It has different semantics
	// depending on which of its fields are set.
	//
	// If ErrCode is set, only errors which match the given error code will be
	// caught. If ErrCode is not set, all errors will be caught.
	//
	// If OrElse is not set, IfErr evaluates to true or false indicating whether an
	// error was caught.  If OrElse is set, IfErr evaluates to Cond if no error was
	// caught and to OrElse if an error was caught.
	//
	// TODO(justin): The implementation here is a hack: ErrCode and OrElse are
	// optional, so we repurpose lists as an optional field (since it's not
	// valid to use nil). If this comes up again, we might want to consider
	// adding an explicit Option type.
	IfErrOp

	InOp

	// IndexJoin represents an inner join between an input expression and a primary
	// index. It is a special case of LookupJoin where the input columns are the PK
	// columns of the table we are looking up into, and every input row results in
	// exactly one output row.
	//
	// IndexJoin operators are created from Scan operators (unlike lookup joins which
	// are created from Join operators).
	IndexJoinOp

	IndexJoinPrivateOp

	// Indirection is a subscripting expression of the form <expr>[<index>].
	// Input must be an Array type and Index must be an int. Multiple indirections
	// and slicing are not supported.
	IndirectionOp

	// InnerJoin creates a result set that combines columns from its left and right
	// inputs, based upon its "on" join predicate. Rows which do not match the
	// predicate are filtered. While expressions in the predicate can refer to
	// columns projected by either the left or right inputs, the inputs are not
	// allowed to refer to the other's projected columns.
	InnerJoinOp

	// InnerJoinApply has the same join semantics as InnerJoin. However, unlike
	// InnerJoin, it allows the right input to refer to columns projected by the
	// left input.
	InnerJoinApplyOp

	// Insert evaluates a relational input expression, and inserts values from it
	// into a target table. The input may be an arbitrarily complex expression:
	//
	//   INSERT INTO ab SELECT x, y+1 FROM xy ORDER BY y
	//
	// It can also be a simple VALUES clause:
	//
	//   INSERT INTO ab VALUES (1, 2)
	//
	// It may also return rows, which can be further composed:
	//
	//   SELECT a + b FROM [INSERT INTO ab VALUES (1, 2) RETURNING a, b]
	//
	// The Insert operator is capable of inserting values into computed columns and
	// mutation columns, which are not writable (or even visible in the case of
	// mutation columns) by SQL users.
	InsertOp

	// Intersect is an operator used to perform an intersection between the Left
	// and Right input relations. The result consists only of rows in the Left
	// relation that are also present in the Right relation. Duplicate rows are
	// discarded.
	// The SetPrivate field matches columns from the Left and Right inputs of the
	// Intersect with the output columns. See the comment above SetPrivate for more
	// details.
	// Note that Intersect is symmetric in most cases, but there are exceptions:
	// some types allow values that are equal but not identical (e.g. collated
	// strings) in which case it could be visible which side a row is coming from.
	IntersectOp

	// IntersectAll is an operator used to perform an intersection between the Left
	// and Right input relations. The result consists only of rows in the Left
	// relation that have a corresponding row in the Right relation. Duplicate rows
	// are not discarded. This effectively creates a one-to-one mapping between the
	// Left and Right rows. For example:
	//
	//   SELECT x FROM xx INTERSECT ALL SELECT y FROM yy
	//     x       y         out
	//   -----   -----      -----
	//     1       1          1
	//     1       1    ->    1
	//     1       2          2
	//     2       2          2
	//     2       3
	//     4
	//
	// The SetPrivate field matches columns from the Left and Right inputs of the
	// IntersectAll with the output columns. See the comment above SetPrivate for more
	// details.
	// Note that IntersectAll is symmetric in most cases, but there are exceptions:
	// some types allow values that are equal but not identical (e.g. collated
	// strings) in which case it could be visible which side a row is coming from.
	IntersectAllOp

	// InvertedFilter filters rows from its input result set, based on the
	// InvertedExpression predicate (which is defined in InvertedFilterPrivate).
	// Rows which do not match the filter are discarded. The input should be a
	// constrained scan of an inverted index, possibly wrapped in other operators
	// such as Select.
	InvertedFilterOp

	InvertedFilterPrivateOp

	// InvertedJoin represents a join between an input expression and an inverted
	// index. The type of join is in the InvertedJoinPrivate field.
	InvertedJoinOp

	InvertedJoinPrivateOp

	// Is maps to the IS NOT DISTINCT FROM operator which is equivalent to IS for
	// non-tuples. See IsTupleNull for the tuple-specific IS NULL operator.
	IsOp

	// IsNot is the inverse of Is. It maps to the IS DISTINCT FROM operator which is
	// equivalent to IS NOT for non-tuples. See IsTupleNotNull for the
	// tuple-specific IS NOT NULL operator.
	IsNotOp

	// IsTupleNotNull is the boolean expression with a tuple input that evaluates to
	// true if the tuple is not null and all elements in the tuple are not null.
	IsTupleNotNullOp

	// IsTupleNull is the boolean expression with a tuple input that evaluates to
	// true if the tuple is null or all elements in the tuple are null.
	IsTupleNullOp

	// JoinPrivate is shared between the various join operators including apply
	// variants, but excluding IndexJoin, LookupJoin, MergeJoin.
	JoinPrivateOp

	JsonAggOp

	JsonAllExistsOp

	JsonExistsOp

	JsonObjectAggOp

	JsonSomeExistsOp

	JsonbAggOp

	JsonbObjectAggOp

	// KVOptions is a set of KVOptionItems that specify arbitrary keys and values
	// that are used as modifiers for various statements (see tree.KVOptions). The
	// key is a constant string but the value can be a scalar expression.
	KVOptionsOp

	// KVOptionsItem is the key and value of an option (see tree.KVOption). For keys
	// that don't have values, the value is Null.
	KVOptionsItemOp

	LShiftOp

	// Lag returns Value evaluated at the row Offset rows before this one. If no
	// such row exists, returns Def.
	LagOp

	// LastValue returns Value evaluated at the last row in the row's frame.
	LastValueOp

	LeOp

	// Lead returns Value evaluated at the row Offset rows after this one. If no
	// such row exists, returns Def.
	LeadOp

	LeftJoinOp

	LeftJoinApplyOp

	LikeOp

	// Limit returns a limited subset of the results in the input relation. The limit
	// expression is a scalar value; the operator returns at most this many rows. The
	// Ordering field is a physical.OrderingChoice which indicates the row ordering
	// required from the input (the first rows with respect to this ordering are
	// returned).
	LimitOp

	// LiteralValues is a version of values where the exprs have already been type checked
	// and are real Datums that don't need evaluation.
	LiteralValuesOp

	// LocalityOptimizedSearch is similar to UnionAll, but it is designed to avoid
	// communicating with remote nodes (relative to the gateway region) if at all
	// possible. LocalityOptimizedSearch can be planned when a scan is known to
	// produce at most one row, but it is not known which region contains that row
	// (if any). In this case, the scan can be split in two, and the resulting scans
	// will become the children of the LocalityOptimizedSearch operator. The left
	// scan should only contain spans targeting partitions on local nodes, and the
	// right scan should contain the remaining spans. The LocalityOptimizedSearch
	// operator ensures that the right child (containing remote spans) is only
	// executed if the left child (containing local spans) does not return any rows.
	//
	// This is a useful optimization if there is locality of access in the workload,
	// such that rows tend to be accessed from the region where they are located.
	// If there is no locality of access, using LocalityOptimizedSearch could be a
	// slight pessimization, since rows residing in remote regions will be fetched
	// slightly more slowly than they would be otherwise.
	//
	// For example, suppose we have a multi-region database with regions 'us-east1',
	// 'us-west1' and 'europe-west1', and we have the following table and query,
	// issued from 'us-east1':
	//
	//   CREATE TABLE tab (
	//     k INT PRIMARY KEY,
	//     v INT
	//   ) LOCALITY REGIONAL BY ROW;
	//
	//   SELECT * FROM tab WHERE k = 10;
	//
	// Normally, this would produce the following plan:
	//
	//   scan tab
	//    └── constraint: /3/1
	//         ├── [/'europe-west1'/10 - /'europe-west1'/10]
	//         ├── [/'us-east1'/10 - /'us-east1'/10]
	//         └── [/'us-west1'/10 - /'us-west1'/10]
	//
	// but if the session setting locality_optimized_partitioned_index_scan is enabled,
	// the optimizer will produce this plan, using locality optimized search:
	//
	//   locality-optimized-search
	//    ├── scan tab
	//    │    └── constraint: /9/7: [/'us-east1'/10 - /'us-east1'/10]
	//    └── scan tab
	//         └── constraint: /14/12
	//              ├── [/'europe-west1'/10 - /'europe-west1'/10]
	//              └── [/'us-west1'/10 - /'us-west1'/10]
	//
	// As long as k = 10 is located in 'us-east1', the second plan will be much faster.
	// But if k = 10 is located in one of the other regions, the first plan would be
	// slightly faster.
	LocalityOptimizedSearchOp

	// LookupJoin represents a join between an input expression and an index. The
	// type of join is in the LookupJoinPrivate field.
	LookupJoinOp

	LookupJoinPrivateOp

	LtOp

	MaxOp

	// Max1Row enforces that its input must return at most one row. If the input
	// has more than one row, Max1Row raises an error with the specified error text.
	//
	// Max1Row is most often used as input to the Subquery operator. See the comment
	// above Subquery for more details.
	Max1RowOp

	// MemoCycleTestRel is a relational expression for testing that memo cycles are
	// detected by the optimizer and a stack overflow is prevented. A cycle in the
	// memo occurs when there is a path from a group member's children back to the
	// group member's group. MemoCycleTestRel is similar in structure to the Select
	// expression, but matches a rule, MemoCycleTestRelRule, that creates a memo
	// cycle.
	MemoCycleTestRelOp

	// MergeJoin represents a join that is executed using merge-join.
	// MergeOn is a scalar which contains the ON condition and merge-join ordering
	// information; see the MergeOn scalar operator.
	// It can be any type of join (identified in the MergeJoinPrivate field).
	MergeJoinOp

	MergeJoinPrivateOp

	MinOp

	MinusOp

	ModOp

	MultOp

	MutationPrivateOp

	NeOp

	// NormCycleTestRel is a relational operator for testing that normalization rule
	// cycles are detected by the Factory and a stack overflow is prevented. Two
	// rules for this expression, NormCycleTestRelTrueToFalse and
	// NormCycleTestRelFalseToTrue, create a normalization rule cycle. See the cycle
	// test file for tests that use this expression.
	NormCycleTestRelOp

	// Not is the boolean negation operator that evaluates to true if its input
	// evaluates to false.
	NotOp

	NotILikeOp

	NotInOp

	NotLikeOp

	NotRegIMatchOp

	NotRegMatchOp

	NotSimilarToOp

	// NthValue returns Value evaluated at the nth row in the row's frame.
	// Out-of-bounds references evaluate to NULL.
	NthValueOp

	// Ntile builds a histogram with the specified number of buckets and evaluates
	// to which bucket the row falls in.
	NtileOp

	// Null is the constant SQL null value that has "unknown value" semantics. If
	// the Typ field is not types.Unknown, then the value is known to be in the
	// domain of that type. This is important for preserving correct types in
	// replacement patterns. For example:
	//   (Plus (Function ...) (Const 1))
	//
	// If the function in that expression has a static type of Int, but then it gets
	// constant folded to (Null), then its type must remain as Int. Any other type
	// violates logical equivalence of the expression, breaking type inference and
	// possibly changing the results of execution. The solution is to tag the null
	// with the correct type:
	//   (Plus (Null (Int)) (Const 1))
	//
	// Null is its own operator rather than a Const datum in order to make matching
	// and replacement easier and more efficient, as patterns can contain (Null)
	// expressions.
	NullOp

	// Offset filters out the first Offset rows of the input relation; used in
	// conjunction with Limit.
	OffsetOp

	// OpaqueMutation is a variant of OpaqueRel for operators that cause a schema
	// change and cannot be executed following a mutation in the same transaction.
	OpaqueDDLOp

	// OpaqueMutation is a variant of OpaqueRel for operators that can mutate data as
	// part of the transaction.
	OpaqueMutationOp

	// OpaqueRel is an opaque relational operator which is planned outside of the
	// optimizer. The operator contains an opaque metadata which is passed to the
	// exec factory.
	//
	// This is used for statements that are not directly supported by the optimizer,
	// and which don't use the result of other relational expressions (in other
	// words, they are a "leaf" operator).
	//
	// OpaqueRel can produce data and can be used as a data source as part of a
	// larger enclosing query.
	OpaqueRelOp

	OpaqueRelPrivateOp

	// Or is the boolean disjunction operator that evaluates to true if either one of
	// its conditions evaluates to true.
	OrOp

	// Ordinality adds a column to each row in its input containing a unique,
	// increasing number.
	OrdinalityOp

	OrdinalityPrivateOp

	OverlapsOp

	// PercentRank is (rank - 1) / (total rows - 1).
	PercentRankOp

	// PercentileCont returns a value such that N% of values are below it
	// in a given window, interpolating values if needed. Ignores nulls in the
	// input.
	PercentileContOp

	// PercentileDisc returns a value such that N% of values are below it
	// in a given window. Ignores nulls in the input.
	PercentileDiscOp

	PlaceholderOp

	// PlaceholderScan is a special variant of Scan. It scans exactly one span of a
	// non-inverted index, and the span has the same start and end key. The values
	// for the span key are child scalar operators which are either constants or
	// placeholders. This operator evaluates the placeholders at execbuild time.
	//
	// PlaceholderScan cannot have a Constraint or InvertedConstraint.
	PlaceholderScanOp

	PlusOp

	PowOp

	// Project modifies the set of columns returned by the input result set. Columns
	// can be removed, reordered, or renamed. In addition, new columns can be
	// synthesized.
	//
	// Projections describes the synthesized columns constructed by Project, and
	// Passthrough describes the input columns that are passed through as Project
	// output columns.
	ProjectOp

	// ProjectSet represents a relational operator which zips through a list of
	// generators for every row of the input.
	//
	// As a reminder, a functional zip over generators a,b,c returns tuples of
	// values from a,b,c picked "simultaneously". NULLs are used when a generator is
	// "shorter" than another.  For example:
	//
	//    zip([1,2,3], ['a','b']) = [(1,'a'), (2,'b'), (3, null)]
	//
	// ProjectSet corresponds to a relational operator project(R, a, b, c, ...)
	// which, for each row in R, produces all the rows produced by zip(a, b, c, ...)
	// with the values of R prefixed. Formally, this performs a lateral cross join
	// of R with zip(a,b,c).
	//
	// See the Zip header for more details.
	ProjectSetOp

	// Projections is a set of ProjectionsItem expressions that specify the ColumnIDs
	// and scalar expressions for the synthesized output columns projected by a
	// containing Project operator. It is legal for the set to be empty. See the
	// Project and ProjectionsItem headers for more details.
	ProjectionsOp

	// ProjectionsItem encapsulates the information needed to synthesize an output
	// column, including its ColumnID and the scalar expression that produces its
	// value. In addition, the ProjectionsItem caches a set of scalar properties that
	// are lazily calculated by traversing the Element scalar expression. This allows
	// the properties for the entire expression subtree to be calculated once and
	// then repeatedly reused.
	//
	// The Element scalar expression cannot contain a simple VariableOp with the same
	// ColumnID as the one stored in the Col field, since that would make it a
	// pass-through column. Pass-through columns are always stored on the containing
	// Project operator instead. However, the Element field can contain a VariableOp
	// when a new ColumnID is being assigned, such as in the case of an outer column
	// reference.
	ProjectionsItemOp

	RShiftOp

	// Range contains an And expression that constrains a single variable to a
	// range. For example, the And expression might be x > 5 AND x < 10. The
	// children of the And expression can be arbitrary expressions (including nested
	// And expressions), but they must all constrain the same variable, and the
	// constraints must be tight.
	//
	// Currently, Range expressions are only created by the ConsolidateSelectFilters
	// normalization rule.
	RangeOp

	// Rank computes the position of a row relative to an ordering, with same-valued
	// rows receiving the same value.
	RankOp

	// RecursiveCTE implements the logic of a recursive CTE:
	//  * the Initial query is evaluated; the results are emitted and also saved into
	//    a "working table".
	//  * so long as the working table is not empty:
	//    - the Recursive query (which refers to the working table using a specific
	//      WithID) is evaluated; the results are emitted and also saved into a new
	//      "working table" for the next iteration.
	RecursiveCTEOp

	RecursiveCTEPrivateOp

	RegIMatchOp

	RegMatchOp

	RegressionAvgXOp

	RegressionAvgYOp

	RegressionCountOp

	RegressionInterceptOp

	RegressionR2Op

	RegressionSXXOp

	RegressionSXYOp

	RegressionSYYOp

	RegressionSlopeOp

	RightJoinOp

	// RowNumber computes the position of a row relative to an ordering, with
	// same-valued rows having ties broken arbitrarily.
	RowNumberOp

	STCollectOp

	STExtentOp

	STMakeLineOp

	STUnionOp

	// ScalarGroupBy computes aggregate functions over the complete set of input
	// rows. This is similar to GroupBy with empty grouping columns, where all input
	// rows form a single group. However, there is an important difference. If the
	// input set is empty, then the output of the ScalarGroupBy operator will have a
	// single row containing default values for each aggregate function (typically
	// null or zero, depending on the function). ScalarGroupBy always returns exactly
	// one row - either the single-group aggregates or the default aggregate values.
	//
	// ScalarGroupBy uses the GroupingPrivate struct so that it's polymorphic with
	// GroupBy and can be used in the same rules (when appropriate). In the
	// ScalarGroupBy case, the grouping column field in GroupingPrivate is always
	// empty.
	ScalarGroupByOp

	// ScalarList is a list expression that has scalar expression items of type
	// opt.ScalarExpr. opt.ScalarExpr is an external type that is defined outside of
	// Optgen. It is hard-coded in the code generator to be the item type for
	// ScalarList.
	//
	// TODO(andyk): Consider adding Optgen syntax like:
	//                define ScalarList []ScalarExpr
	ScalarListOp

	// Scan returns a result set containing every row in a table by scanning one of
	// the table's indexes according to its ordering. The ScanPrivate field
	// identifies the table and index to scan, as well as the subset of columns to
	// project from it.
	//
	// The scan can be constrained and/or have an internal row limit. A scan can be
	// executed either as a forward or as a reverse scan (except when it has a limit,
	// in which case the direction is fixed).
	ScanOp

	ScanPrivateOp

	// Select filters rows from its input result set, based on the boolean filter
	// predicate expression. Rows which do not match the filter are discarded. While
	// the Filter operand can be any boolean expression, normalization rules will
	// typically convert it to a Filters operator in order to make conjunction list
	// matching easier.
	SelectOp

	SemiJoinOp

	SemiJoinApplyOp

	// SequenceSelect represents a read from a sequence as a data source. It always returns
	// three columns, last_value, log_cnt, and is_called, with a single row. last_value is
	// the most recent value returned from the sequence and log_cnt and is_called are
	// always 0 and true, respectively.
	SequenceSelectOp

	SequenceSelectPrivateOp

	// SetPrivate contains fields used by the relational set operators: Union,
	// Intersect, Except, UnionAll, IntersectAll, ExceptAll, and
	// LocalityOptimizedSearch. It matches columns from the left and right inputs of
	// the operator with the output columns, since OutputCols are not ordered and may
	// not correspond to each other.
	//
	// For example, consider the following query:
	//   SELECT y, x FROM xy UNION SELECT b, a FROM ab
	//
	// Given:
	//   col  index
	//   x    1
	//   y    2
	//   a    3
	//   b    4
	//
	// SetPrivate will contain the following values:
	//   Left:  [2, 1]
	//   Right: [4, 3]
	//   Out:   [5, 6]  <-- synthesized output columns
	//
	// To make normalization rules and execution simpler, both inputs to the set op
	// must have matching types.
	//
	// SetPrivate can also contain an optional ordering, allowing for more efficient
	// streaming execution.
	SetPrivateOp

	// ShowTraceForSession returns the current session traces.
	ShowTraceForSessionOp

	ShowTracePrivateOp

	SimilarToOp

	// Sort enforces the ordering of rows returned by its input expression. Rows can
	// be sorted by one or more of the input columns, each of which can be sorted in
	// either ascending or descending order. See the Ordering field in the
	// PhysicalProps struct.
	SortOp

	SqrDiffOp

	StdDevOp

	StdDevPopOp

	StringAggOp

	// Subquery is a subquery in a single-row context. Here are some examples:
	//
	//   SELECT 1 = (SELECT 1)
	//   SELECT (1, 'a') = (SELECT 1, 'a')`
	//
	// In a single-row context, the outer query is only valid if the subquery returns
	// at most one row. Subqueries in a multi-row context can be transformed to a
	// single row context using the Any operator. See the comment above the Any
	// operator for more details.
	//
	// The Input field contains the subquery itself, which should be wrapped in a
	// Max1Row operator to enforce that the subquery can return at most one row
	// (Max1Row may be removed by the optimizer later if it can determine statically
	// that the subquery will always return at most one row). In addition, the
	// subquery must project exactly one output column. If the subquery returns one
	// row, then that column is bound to the single column value in that row. If the
	// subquery returns zero rows, then that column is bound to NULL.
	SubqueryOp

	// SubqueryPrivate contains information related to a subquery (Subquery, Any,
	// Exists). It is shared between the operators so that the same rules can be used
	// across all the subquery operators.
	SubqueryPrivateOp

	SumOp

	SumIntOp

	// TopK returns the top K, where K is a constant, rows from the input set
	// according to its sort ordering, discarding the remaining rows. The Limit is a
	// constant positive integer; the operator returns at most Limit rows. Rows can
	// be sorted by one or more of the input columns, each of which can be sorted in
	// either ascending or descending order. See the Ordering field in the
	// PhysicalProps struct.
	//
	// Unlike the Limit relational operator, TopK does not require its input to be
	// ordered. However, if the input is known to have a partial ordering of the
	// required ordering, TopK can take advantage of optimizations. TopK can be used
	// to substitute a Limit that requires its input to be ordered and performs best
	// when the input is not already fully ordered. TopK scans the input, storing the
	// K rows that best meet the ordering requirement in a max heap, then sorts the K
	// rows.
	TopKOp

	TopKPrivateOp

	// True is the boolean true value that is equivalent to the tree.DBoolTrue datum
	// value. It is a separate operator to make matching and replacement simpler and
	// more efficient, as patterns can contain (True) expressions.
	TrueOp

	TupleOp

	// UDF invokes a user-defined function. The UDFPrivate field contains details
	// about the UDF including the name of the function, the statements in the
	// function body, and a pointer to its type.
	UDFOp

	UDFPrivateOp

	UnaryCbrtOp

	UnaryComplementOp

	UnaryMinusOp

	UnaryPlusOp

	UnarySqrtOp

	// Union is an operator used to combine the Left and Right input relations into
	// a single set containing rows from both inputs. Duplicate rows are discarded.
	// The SetPrivate field matches columns from the Left and Right inputs of the
	// Union with the output columns. See the comment above SetPrivate for more
	// details.
	UnionOp

	// UnionAll is an operator used to combine the Left and Right input relations
	// into a single set containing rows from both inputs. Duplicate rows are
	// not discarded. For example:
	//
	//   SELECT x FROM xx UNION ALL SELECT y FROM yy
	//     x       y         out
	//   -----   -----      -----
	//     1       1          1
	//     1       2    ->    1
	//     2       3          1
	//                        2
	//                        2
	//                        3
	//
	// The SetPrivate field matches columns from the Left and Right inputs of the
	// UnionAll with the output columns. See the comment above SetPrivate for more
	// details.
	UnionAllOp

	// UniqueChecks is a list of uniqueness check queries, to be run after the main
	// query.
	UniqueChecksOp

	// UniqueChecksItem is a unique check query, to be run after the main query.
	// An execution error will be generated if the query returns any results.
	UniqueChecksItemOp

	UniqueChecksItemPrivateOp

	// Update evaluates a relational input expression that fetches existing rows from
	// a target table and computes new values for one or more columns. Arbitrary
	// subsets of rows can be selected from the target table and processed in order,
	// as with this example:
	//
	//   UPDATE abc SET b=10 WHERE a>0 ORDER BY b+c LIMIT 10
	//
	// The Update operator will also update any computed columns, including mutation
	// columns that are computed.
	UpdateOp

	// Upsert evaluates a relational input expression that tries to insert a new row
	// into a target table. If a conflicting row already exists, then Upsert will
	// instead update the existing row. The Upsert operator is used for all of these
	// syntactic variants:
	//
	//   INSERT..ON CONFLICT DO UPDATE
	//     INSERT INTO abc VALUES (1, 2, 3) ON CONFLICT (a) DO UPDATE SET b=10
	//
	//   INSERT..ON CONFLICT DO NOTHING
	//     INSERT INTO abc VALUES (1, 2, 3) ON CONFLICT DO NOTHING
	//
	//   UPSERT
	//     UPSERT INTO abc VALUES (1, 2, 3)
	//
	// The Update operator will also insert/update any computed columns, including
	// mutation columns that are computed.
	UpsertOp

	// UpsertDistinctOn is a variation on DistinctOn that is only used with UPSERT
	// and INSERT..ON CONFLICT statements. Unlike DistinctOn, UpsertDistinctOn treats
	// NULL values as not equal to one another for purposes of grouping. Two rows
	// having a NULL-valued grouping column will be placed in different groups. This
	// differs from DistinctOn behavior, where the two rows would be grouped
	// together. This behavior difference reflects SQL semantics, in which a unique
	// index key still allows multiple NULL values.
	//
	// UpsertDistinctOn is used when nulls are considered distinct for grouping
	// purposes and duplicates should be filtered out without raising an error.
	UpsertDistinctOnOp

	// Values returns a manufactured result set containing a constant number of rows.
	// specified by the Rows list field. Each row must contain the same set of
	// columns in the same order.
	//
	// The Rows field contains a list of Tuples, one for each row. Each tuple has
	// the same length (same with that of Cols).
	//
	// The Cols field contains the set of column indices returned by each row
	// as an opt.ColList. It is legal for Cols to be empty.
	ValuesOp

	ValuesPrivateOp

	VarPopOp

	// Variable is the typed scalar value of a column in the query. The Col field is
	// a metadata ColumnID value that references the column by index.
	VariableOp

	VarianceOp

	// When represents a single WHEN ... THEN ... condition inside a CASE statement.
	// It is the type of each list item in Whens (except for the last item which is
	// a raw expression for the ELSE statement).
	WhenOp

	// Window represents a window function. Window functions are operators which
	// allow computations that take into consideration other rows in the same result
	// set.
	//
	// More concretely, a window function is a relational operator that takes in a
	// result set and appends a single new column whose value depends on the other
	// rows within the result set, and that row's relative position in it.
	//
	// Depending on the exact window function being computed, the value of the new
	// column could be the position of the row in the output (`row_number`), or a
	// cumulative sum, or something else.
	WindowOp

	// WindowFromOffset is used as a modifier that wraps the input of a window
	// function. It supplies the expression to be used as the lower bound of the
	// window frame, if the lower bound uses OFFSET mode.
	WindowFromOffsetOp

	WindowPrivateOp

	// WindowToOffset is used as a modifier that wraps the input of a window
	// function. It supplies the expression to be used as the upper bound of the
	// window frame, if the upper bound uses OFFSET mode.
	WindowToOffsetOp

	// Windows is a set of window functions to be computed in the context of a
	// Window expression.
	WindowsOp

	// WindowsItem is a single window function to be computed in the context of a
	// Window expression.
	WindowsItemOp

	WindowsItemPrivateOp

	// With executes Binding, making its results available to Main. Within Main, the
	// results of Binding may be referenced by a WithScan expression containing the
	// ID of this With.
	WithOp

	WithPrivateOp

	// WithScan returns the results present in the With expression referenced
	// by ID.
	// Note that in order to construct a WithScan, the WithID must have a bound
	// expression in the metadata.
	WithScanOp

	WithScanPrivateOp

	XorAggOp

	// ZigzagJoin represents a join that is executed using the zigzag joiner.
	// All fields except for the ON expression are stored in the private;
	// since the zigzag joiner operates directly on indexes and doesn't
	// support arbitrary inputs.
	//
	// TODO(itsbilal): Add support for representing multi-way zigzag joins.
	ZigzagJoinOp

	ZigzagJoinPrivateOp

	// Zip represents a functional zip over generators a,b,c, which returns tuples of
	// values from a,b,c picked "simultaneously". NULLs are used when a generator is
	// "shorter" than another. In SQL, these generators can be either generator
	// functions such as generate_series(), or scalar functions or expressions such
	// as upper() or CAST. For example, consider this query:
	//
	//    SELECT * FROM ROWS FROM (generate_series(0, 1), upper('abc'));
	//
	// It is equivalent to:
	//
	//    (Zip [
	//            (ZipItem (Function generate_series)),
	//            (ZipItem (Function upper))
	//         ]
	//    )
	//
	// It produces:
	//
	//     generate_series | upper
	//    -----------------+-------
	//                   0 | ABC
	//                   1 | NULL
	//
	ZipOp

	// ZipItem contains a generator function or scalar expression that is contained
	// in a Zip. It also contains the list of output columns for the generator or
	// scalar expression in the ZipItem. Cols is a list since a single function may
	// output multiple columns (e.g. pg_get_keywords() outputs three columns).
	//
	// See the Zip header for more details.
	ZipItemOp

	NumOperators
)

const opNames = "unknownagg-distinctagg-filteraggregationsaggregations-itemalter-range-relocatealter-range-relocate-privatealter-table-relocatealter-table-relocate-privatealter-table-splitalter-table-split-privatealter-table-unsplitalter-table-unsplit-allandanti-joinanti-join-applyanyany-not-null-aggany-scalararrayarray-aggarray-flattenassignment-castavgb-box-coversb-box-intersectsbit-and-aggbit-or-aggbitandbitorbitxorbool-andbool-orcancel-privatecancel-queriescancel-sessionscasecastcoalescecollatecolumn-accessconcatconcat-aggconstconst-aggconst-not-null-aggcontained-bycontainscontrol-jobscontrol-jobs-privatecontrol-schedulescontrol-schedules-privatecorrcountcount-rowscovar-popcovar-sampcreate-functioncreate-function-privatecreate-statisticscreate-statistics-privatecreate-tablecreate-table-privatecreate-viewcreate-view-privatecume-distdeletedense-rankdistinct-ondistributedivensure-distinct-onensure-upsert-distinct-oneqexceptexcept-allexistsexplainexplain-privateexportexport-privatef-k-checksf-k-checks-itemf-k-checks-item-privatefake-relfake-rel-privatefalsefetch-textfetch-text-pathfetch-valfetch-val-pathfiltersfilters-itemfirst-aggfirst-valuefloor-divfull-joinfunctionfunction-privategegroup-bygrouping-privategti-likeif-errinindex-joinindex-join-privateindirectioninner-joininner-join-applyinsertintersectintersect-allinverted-filterinverted-filter-privateinverted-joininverted-join-privateisis-notis-tuple-not-nullis-tuple-nulljoin-privatejson-aggjson-all-existsjson-existsjson-object-aggjson-some-existsjsonb-aggjsonb-object-aggk-v-optionsk-v-options-iteml-shiftlaglast-valueleleadleft-joinleft-join-applylikelimitliteral-valueslocality-optimized-searchlookup-joinlookup-join-privateltmaxmax1-rowmemo-cycle-test-relmerge-joinmerge-join-privateminminusmodmultmutation-privatenenorm-cycle-test-relnotnot-i-likenot-innot-likenot-reg-i-matchnot-reg-matchnot-similar-tonth-valuentilenulloffsetopaque-d-d-lopaque-mutationopaque-relopaque-rel-privateorordinalityordinality-privateoverlapspercent-rankpercentile-contpercentile-discplaceholderplaceholder-scanpluspowprojectproject-setprojectionsprojections-itemr-shiftrangerankrecursive-c-t-erecursive-c-t-e-privatereg-i-matchreg-matchregression-avg-xregression-avg-yregression-countregression-interceptregression-r2regression-s-x-xregression-s-x-yregression-s-y-yregression-sloperight-joinrow-numbers-t-collects-t-extents-t-make-lines-t-unionscalar-group-byscalar-listscanscan-privateselectsemi-joinsemi-join-applysequence-selectsequence-select-privateset-privateshow-trace-for-sessionshow-trace-privatesimilar-tosortsqr-diffstd-devstd-dev-popstring-aggsubquerysubquery-privatesumsum-inttop-ktop-k-privatetruetupleu-d-fu-d-f-privateunary-cbrtunary-complementunary-minusunary-plusunary-sqrtunionunion-allunique-checksunique-checks-itemunique-checks-item-privateupdateupsertupsert-distinct-onvaluesvalues-privatevar-popvariablevariancewhenwindowwindow-from-offsetwindow-privatewindow-to-offsetwindowswindows-itemwindows-item-privatewithwith-privatewith-scanwith-scan-privatexor-aggzigzag-joinzigzag-join-privatezipzip-item"

var opNameIndexes = [...]uint32{0, 7, 19, 29, 41, 58, 78, 106, 126, 154, 171, 196, 215, 238, 241, 250, 265, 268, 284, 294, 299, 308, 321, 336, 339, 351, 367, 378, 388, 394, 399, 405, 413, 420, 434, 448, 463, 467, 471, 479, 486, 499, 505, 515, 520, 529, 547, 559, 567, 579, 599, 616, 641, 645, 650, 660, 669, 679, 694, 717, 734, 759, 771, 791, 802, 821, 830, 836, 846, 857, 867, 870, 888, 913, 915, 921, 931, 937, 944, 959, 965, 979, 989, 1004, 1027, 1035, 1051, 1056, 1066, 1081, 1090, 1104, 1111, 1123, 1132, 1143, 1152, 1161, 1169, 1185, 1187, 1195, 1211, 1213, 1219, 1225, 1227, 1237, 1255, 1266, 1276, 1292, 1298, 1307, 1320, 1335, 1358, 1371, 1392, 1394, 1400, 1417, 1430, 1442, 1450, 1465, 1476, 1491, 1507, 1516, 1532, 1543, 1559, 1566, 1569, 1579, 1581, 1585, 1594, 1609, 1613, 1618, 1632, 1657, 1668, 1687, 1689, 1692, 1700, 1719, 1729, 1747, 1750, 1755, 1758, 1762, 1778, 1780, 1799, 1802, 1812, 1818, 1826, 1841, 1854, 1868, 1877, 1882, 1886, 1892, 1904, 1919, 1929, 1947, 1949, 1959, 1977, 1985, 1997, 2012, 2027, 2038, 2054, 2058, 2061, 2068, 2079, 2090, 2106, 2113, 2118, 2122, 2137, 2160, 2171, 2180, 2196, 2212, 2228, 2248, 2261, 2277, 2293, 2309, 2325, 2335, 2345, 2356, 2366, 2379, 2388, 2403, 2414, 2418, 2430, 2436, 2445, 2460, 2475, 2498, 2509, 2531, 2549, 2559, 2563, 2571, 2578, 2589, 2599, 2607, 2623, 2626, 2633, 2638, 2651, 2655, 2660, 2665, 2678, 2688, 2704, 2715, 2725, 2735, 2740, 2749, 2762, 2780, 2806, 2812, 2818, 2836, 2842, 2856, 2863, 2871, 2879, 2883, 2889, 2907, 2921, 2937, 2944, 2956, 2976, 2980, 2992, 3001, 3018, 3025, 3036, 3055, 3058, 3066}

const opSyntaxTags = "UNKNOWNAGG DISTINCTAGG FILTERAGGREGATIONSAGGREGATIONS ITEMALTER RANGE RELOCATEALTER RANGE RELOCATE PRIVATEALTER TABLE RELOCATEALTER TABLE RELOCATE PRIVATEALTER TABLE SPLITALTER TABLE SPLIT PRIVATEALTER TABLE UNSPLITALTER TABLE UNSPLIT ALLANDANTI JOINANTI JOIN APPLYANYANY NOT NULL AGGANY SCALARARRAYARRAY AGGARRAY FLATTENASSIGNMENT CASTAVGB BOX COVERSB BOX INTERSECTSBIT AND AGGBIT OR AGGBITANDBITORBITXORBOOL ANDBOOL ORCANCEL PRIVATECANCEL QUERIESCANCEL SESSIONSCASECASTCOALESCECOLLATECOLUMN ACCESSCONCATCONCAT AGGCONSTCONST AGGCONST NOT NULL AGGCONTAINED BYCONTAINSCONTROL JOBSCONTROL JOBS PRIVATECONTROL SCHEDULESCONTROL SCHEDULES PRIVATECORRCOUNTCOUNT ROWSCOVAR POPCOVAR SAMPCREATE FUNCTIONCREATE FUNCTION PRIVATECREATE STATISTICSCREATE STATISTICS PRIVATECREATE TABLECREATE TABLE PRIVATECREATE VIEWCREATE VIEW PRIVATECUME DISTDELETEDENSE RANKDISTINCT ONDISTRIBUTEDIVENSURE DISTINCT ONENSURE UPSERT DISTINCT ONEQEXCEPTEXCEPT ALLEXISTSEXPLAINEXPLAIN PRIVATEEXPORTEXPORT PRIVATEF K CHECKSF K CHECKS ITEMF K CHECKS ITEM PRIVATEFAKE RELFAKE REL PRIVATEFALSEFETCH TEXTFETCH TEXT PATHFETCH VALFETCH VAL PATHFILTERSFILTERS ITEMFIRST AGGFIRST VALUEFLOOR DIVFULL JOINFUNCTIONFUNCTION PRIVATEGEGROUP BYGROUPING PRIVATEGTI LIKEIF ERRININDEX JOININDEX JOIN PRIVATEINDIRECTIONINNER JOININNER JOIN APPLYINSERTINTERSECTINTERSECT ALLINVERTED FILTERINVERTED FILTER PRIVATEINVERTED JOININVERTED JOIN PRIVATEISIS NOTIS TUPLE NOT NULLIS TUPLE NULLJOIN PRIVATEJSON AGGJSON ALL EXISTSJSON EXISTSJSON OBJECT AGGJSON SOME EXISTSJSONB AGGJSONB OBJECT AGGK V OPTIONSK V OPTIONS ITEML SHIFTLAGLAST VALUELELEADLEFT JOINLEFT JOIN APPLYLIKELIMITLITERAL VALUESLOCALITY OPTIMIZED SEARCHLOOKUP JOINLOOKUP JOIN PRIVATELTMAXMAX1 ROWMEMO CYCLE TEST RELMERGE JOINMERGE JOIN PRIVATEMINMINUSMODMULTMUTATION PRIVATENENORM CYCLE TEST RELNOTNOT I LIKENOT INNOT LIKENOT REG I MATCHNOT REG MATCHNOT SIMILAR TONTH VALUENTILENULLOFFSETOPAQUE D D LOPAQUE MUTATIONOPAQUE RELOPAQUE REL PRIVATEORORDINALITYORDINALITY PRIVATEOVERLAPSPERCENT RANKPERCENTILE CONTPERCENTILE DISCPLACEHOLDERPLACEHOLDER SCANPLUSPOWPROJECTPROJECT SETPROJECTIONSPROJECTIONS ITEMR SHIFTRANGERANKRECURSIVE C T ERECURSIVE C T E PRIVATEREG I MATCHREG MATCHREGRESSION AVG XREGRESSION AVG YREGRESSION COUNTREGRESSION INTERCEPTREGRESSION R2REGRESSION S X XREGRESSION S X YREGRESSION S Y YREGRESSION SLOPERIGHT JOINROW NUMBERS T COLLECTS T EXTENTS T MAKE LINES T UNIONSCALAR GROUP BYSCALAR LISTSCANSCAN PRIVATESELECTSEMI JOINSEMI JOIN APPLYSEQUENCE SELECTSEQUENCE SELECT PRIVATESET PRIVATESHOW TRACE FOR SESSIONSHOW TRACE PRIVATESIMILAR TOSORTSQR DIFFSTD DEVSTD DEV POPSTRING AGGSUBQUERYSUBQUERY PRIVATESUMSUM INTTOP KTOP K PRIVATETRUETUPLEU D FU D F PRIVATEUNARY CBRTUNARY COMPLEMENTUNARY MINUSUNARY PLUSUNARY SQRTUNIONUNION ALLUNIQUE CHECKSUNIQUE CHECKS ITEMUNIQUE CHECKS ITEM PRIVATEUPDATEUPSERTUPSERT DISTINCT ONVALUESVALUES PRIVATEVAR POPVARIABLEVARIANCEWHENWINDOWWINDOW FROM OFFSETWINDOW PRIVATEWINDOW TO OFFSETWINDOWSWINDOWS ITEMWINDOWS ITEM PRIVATEWITHWITH PRIVATEWITH SCANWITH SCAN PRIVATEXOR AGGZIGZAG JOINZIGZAG JOIN PRIVATEZIPZIP ITEM"

var opSyntaxTagIndexes = [...]uint32{0, 7, 19, 29, 41, 58, 78, 106, 126, 154, 171, 196, 215, 238, 241, 250, 265, 268, 284, 294, 299, 308, 321, 336, 339, 351, 367, 378, 388, 394, 399, 405, 413, 420, 434, 448, 463, 467, 471, 479, 486, 499, 505, 515, 520, 529, 547, 559, 567, 579, 599, 616, 641, 645, 650, 660, 669, 679, 694, 717, 734, 759, 771, 791, 802, 821, 830, 836, 846, 857, 867, 870, 888, 913, 915, 921, 931, 937, 944, 959, 965, 979, 989, 1004, 1027, 1035, 1051, 1056, 1066, 1081, 1090, 1104, 1111, 1123, 1132, 1143, 1152, 1161, 1169, 1185, 1187, 1195, 1211, 1213, 1219, 1225, 1227, 1237, 1255, 1266, 1276, 1292, 1298, 1307, 1320, 1335, 1358, 1371, 1392, 1394, 1400, 1417, 1430, 1442, 1450, 1465, 1476, 1491, 1507, 1516, 1532, 1543, 1559, 1566, 1569, 1579, 1581, 1585, 1594, 1609, 1613, 1618, 1632, 1657, 1668, 1687, 1689, 1692, 1700, 1719, 1729, 1747, 1750, 1755, 1758, 1762, 1778, 1780, 1799, 1802, 1812, 1818, 1826, 1841, 1854, 1868, 1877, 1882, 1886, 1892, 1904, 1919, 1929, 1947, 1949, 1959, 1977, 1985, 1997, 2012, 2027, 2038, 2054, 2058, 2061, 2068, 2079, 2090, 2106, 2113, 2118, 2122, 2137, 2160, 2171, 2180, 2196, 2212, 2228, 2248, 2261, 2277, 2293, 2309, 2325, 2335, 2345, 2356, 2366, 2379, 2388, 2403, 2414, 2418, 2430, 2436, 2445, 2460, 2475, 2498, 2509, 2531, 2549, 2559, 2563, 2571, 2578, 2589, 2599, 2607, 2623, 2626, 2633, 2638, 2651, 2655, 2660, 2665, 2678, 2688, 2704, 2715, 2725, 2735, 2740, 2749, 2762, 2780, 2806, 2812, 2818, 2836, 2842, 2856, 2863, 2871, 2879, 2883, 2889, 2907, 2921, 2937, 2944, 2956, 2976, 2980, 2992, 3001, 3018, 3025, 3036, 3055, 3058, 3066}

var RelationalOperators = [...]Operator{
	AlterRangeRelocateOp,
	AlterTableRelocateOp,
	AlterTableSplitOp,
	AlterTableUnsplitOp,
	AlterTableUnsplitAllOp,
	AntiJoinOp,
	AntiJoinApplyOp,
	CancelQueriesOp,
	CancelSessionsOp,
	ControlJobsOp,
	ControlSchedulesOp,
	CreateFunctionOp,
	CreateStatisticsOp,
	CreateTableOp,
	CreateViewOp,
	DeleteOp,
	DistinctOnOp,
	EnsureDistinctOnOp,
	EnsureUpsertDistinctOnOp,
	ExceptOp,
	ExceptAllOp,
	ExplainOp,
	ExportOp,
	FakeRelOp,
	FullJoinOp,
	GroupByOp,
	IndexJoinOp,
	InnerJoinOp,
	InnerJoinApplyOp,
	InsertOp,
	IntersectOp,
	IntersectAllOp,
	InvertedFilterOp,
	InvertedJoinOp,
	LeftJoinOp,
	LeftJoinApplyOp,
	LimitOp,
	LiteralValuesOp,
	LocalityOptimizedSearchOp,
	LookupJoinOp,
	Max1RowOp,
	MemoCycleTestRelOp,
	MergeJoinOp,
	NormCycleTestRelOp,
	OffsetOp,
	OpaqueDDLOp,
	OpaqueMutationOp,
	OpaqueRelOp,
	OrdinalityOp,
	PlaceholderScanOp,
	ProjectOp,
	ProjectSetOp,
	RecursiveCTEOp,
	RightJoinOp,
	ScalarGroupByOp,
	ScanOp,
	SelectOp,
	SemiJoinOp,
	SemiJoinApplyOp,
	SequenceSelectOp,
	ShowTraceForSessionOp,
	TopKOp,
	UnionOp,
	UnionAllOp,
	UpdateOp,
	UpsertOp,
	UpsertDistinctOnOp,
	ValuesOp,
	WindowOp,
	WithOp,
	WithScanOp,
	ZigzagJoinOp,
}

func IsRelationalOp(e Expr) bool {
	switch e.Op() {
	case AlterRangeRelocateOp, AlterTableRelocateOp, AlterTableSplitOp, AlterTableUnsplitOp,
		AlterTableUnsplitAllOp, AntiJoinOp, AntiJoinApplyOp, CancelQueriesOp, CancelSessionsOp,
		ControlJobsOp, ControlSchedulesOp, CreateFunctionOp, CreateStatisticsOp, CreateTableOp,
		CreateViewOp, DeleteOp, DistinctOnOp, EnsureDistinctOnOp, EnsureUpsertDistinctOnOp,
		ExceptOp, ExceptAllOp, ExplainOp, ExportOp, FakeRelOp,
		FullJoinOp, GroupByOp, IndexJoinOp, InnerJoinOp, InnerJoinApplyOp,
		InsertOp, IntersectOp, IntersectAllOp, InvertedFilterOp, InvertedJoinOp,
		LeftJoinOp, LeftJoinApplyOp, LimitOp, LiteralValuesOp, LocalityOptimizedSearchOp,
		LookupJoinOp, Max1RowOp, MemoCycleTestRelOp, MergeJoinOp, NormCycleTestRelOp,
		OffsetOp, OpaqueDDLOp, OpaqueMutationOp, OpaqueRelOp, OrdinalityOp,
		PlaceholderScanOp, ProjectOp, ProjectSetOp, RecursiveCTEOp, RightJoinOp,
		ScalarGroupByOp, ScanOp, SelectOp, SemiJoinOp, SemiJoinApplyOp,
		SequenceSelectOp, ShowTraceForSessionOp, TopKOp, UnionOp, UnionAllOp,
		UpdateOp, UpsertOp, UpsertDistinctOnOp, ValuesOp, WindowOp,
		WithOp, WithScanOp, ZigzagJoinOp:
		return true
	}
	return false
}

var EnforcerOperators = [...]Operator{
	DistributeOp,
	SortOp,
}

func IsEnforcerOp(e Expr) bool {
	switch e.Op() {
	case DistributeOp, SortOp:
		return true
	}
	return false
}

var TelemetryOperators = [...]Operator{
	AntiJoinApplyOp,
	DistinctOnOp,
	DistributeOp,
	EnsureDistinctOnOp,
	EnsureUpsertDistinctOnOp,
	GroupByOp,
	InnerJoinApplyOp,
	LeftJoinApplyOp,
	ProjectSetOp,
	ScalarGroupByOp,
	SemiJoinApplyOp,
	SortOp,
	UpsertDistinctOnOp,
	ZigzagJoinOp,
}

func IsTelemetryOp(e Expr) bool {
	switch e.Op() {
	case AntiJoinApplyOp, DistinctOnOp, DistributeOp, EnsureDistinctOnOp,
		EnsureUpsertDistinctOnOp, GroupByOp, InnerJoinApplyOp, LeftJoinApplyOp, ProjectSetOp,
		ScalarGroupByOp, SemiJoinApplyOp, SortOp, UpsertDistinctOnOp, ZigzagJoinOp:
		return true
	}
	return false
}

var MutationOperators = [...]Operator{
	AlterRangeRelocateOp,
	AlterTableRelocateOp,
	AlterTableSplitOp,
	AlterTableUnsplitOp,
	AlterTableUnsplitAllOp,
	CreateFunctionOp,
	CreateTableOp,
	CreateViewOp,
	DeleteOp,
	InsertOp,
	OpaqueDDLOp,
	OpaqueMutationOp,
	UpdateOp,
	UpsertOp,
}

func IsMutationOp(e Expr) bool {
	switch e.Op() {
	case AlterRangeRelocateOp, AlterTableRelocateOp, AlterTableSplitOp, AlterTableUnsplitOp,
		AlterTableUnsplitAllOp, CreateFunctionOp, CreateTableOp, CreateViewOp, DeleteOp,
		InsertOp, OpaqueDDLOp, OpaqueMutationOp, UpdateOp, UpsertOp:
		return true
	}
	return false
}

var WithBindingOperators = [...]Operator{
	DeleteOp,
	InsertOp,
	RecursiveCTEOp,
	UpdateOp,
	UpsertOp,
	WithOp,
}

func IsWithBindingOp(e Expr) bool {
	switch e.Op() {
	case DeleteOp, InsertOp, RecursiveCTEOp, UpdateOp,
		UpsertOp, WithOp:
		return true
	}
	return false
}

var PrivateOperators = [...]Operator{
	AlterRangeRelocatePrivateOp,
	AlterTableRelocatePrivateOp,
	AlterTableSplitPrivateOp,
	CancelPrivateOp,
	ControlJobsPrivateOp,
	ControlSchedulesPrivateOp,
	CreateFunctionPrivateOp,
	CreateStatisticsPrivateOp,
	CreateTablePrivateOp,
	CreateViewPrivateOp,
	ExplainPrivateOp,
	ExportPrivateOp,
	FKChecksItemPrivateOp,
	FakeRelPrivateOp,
	FunctionPrivateOp,
	GroupingPrivateOp,
	IndexJoinPrivateOp,
	InvertedFilterPrivateOp,
	InvertedJoinPrivateOp,
	JoinPrivateOp,
	LookupJoinPrivateOp,
	MergeJoinPrivateOp,
	MutationPrivateOp,
	OpaqueRelPrivateOp,
	OrdinalityPrivateOp,
	RecursiveCTEPrivateOp,
	ScanPrivateOp,
	SequenceSelectPrivateOp,
	SetPrivateOp,
	ShowTracePrivateOp,
	SubqueryPrivateOp,
	TopKPrivateOp,
	UDFPrivateOp,
	UniqueChecksItemPrivateOp,
	ValuesPrivateOp,
	WindowPrivateOp,
	WindowsItemPrivateOp,
	WithPrivateOp,
	WithScanPrivateOp,
	ZigzagJoinPrivateOp,
}

func IsPrivateOp(e Expr) bool {
	switch e.Op() {
	case AlterRangeRelocatePrivateOp, AlterTableRelocatePrivateOp, AlterTableSplitPrivateOp, CancelPrivateOp,
		ControlJobsPrivateOp, ControlSchedulesPrivateOp, CreateFunctionPrivateOp, CreateStatisticsPrivateOp, CreateTablePrivateOp,
		CreateViewPrivateOp, ExplainPrivateOp, ExportPrivateOp, FKChecksItemPrivateOp, FakeRelPrivateOp,
		FunctionPrivateOp, GroupingPrivateOp, IndexJoinPrivateOp, InvertedFilterPrivateOp, InvertedJoinPrivateOp,
		JoinPrivateOp, LookupJoinPrivateOp, MergeJoinPrivateOp, MutationPrivateOp, OpaqueRelPrivateOp,
		OrdinalityPrivateOp, RecursiveCTEPrivateOp, ScanPrivateOp, SequenceSelectPrivateOp, SetPrivateOp,
		ShowTracePrivateOp, SubqueryPrivateOp, TopKPrivateOp, UDFPrivateOp, UniqueChecksItemPrivateOp,
		ValuesPrivateOp, WindowPrivateOp, WindowsItemPrivateOp, WithPrivateOp, WithScanPrivateOp,
		ZigzagJoinPrivateOp:
		return true
	}
	return false
}

var ScalarOperators = [...]Operator{
	AggDistinctOp,
	AggFilterOp,
	AggregationsOp,
	AggregationsItemOp,
	AndOp,
	AnyOp,
	AnyNotNullAggOp,
	AnyScalarOp,
	ArrayOp,
	ArrayAggOp,
	ArrayFlattenOp,
	AssignmentCastOp,
	AvgOp,
	BBoxCoversOp,
	BBoxIntersectsOp,
	BitAndAggOp,
	BitOrAggOp,
	BitandOp,
	BitorOp,
	BitxorOp,
	BoolAndOp,
	BoolOrOp,
	CaseOp,
	CastOp,
	CoalesceOp,
	CollateOp,
	ColumnAccessOp,
	ConcatOp,
	ConcatAggOp,
	ConstOp,
	ConstAggOp,
	ConstNotNullAggOp,
	ContainedByOp,
	ContainsOp,
	CorrOp,
	CountOp,
	CountRowsOp,
	CovarPopOp,
	CovarSampOp,
	CumeDistOp,
	DenseRankOp,
	DivOp,
	EqOp,
	ExistsOp,
	FKChecksOp,
	FKChecksItemOp,
	FalseOp,
	FetchTextOp,
	FetchTextPathOp,
	FetchValOp,
	FetchValPathOp,
	FiltersOp,
	FiltersItemOp,
	FirstAggOp,
	FirstValueOp,
	FloorDivOp,
	FunctionOp,
	GeOp,
	GtOp,
	ILikeOp,
	IfErrOp,
	InOp,
	IndirectionOp,
	IsOp,
	IsNotOp,
	IsTupleNotNullOp,
	IsTupleNullOp,
	JsonAggOp,
	JsonAllExistsOp,
	JsonExistsOp,
	JsonObjectAggOp,
	JsonSomeExistsOp,
	JsonbAggOp,
	JsonbObjectAggOp,
	KVOptionsOp,
	KVOptionsItemOp,
	LShiftOp,
	LagOp,
	LastValueOp,
	LeOp,
	LeadOp,
	LikeOp,
	LtOp,
	MaxOp,
	MinOp,
	MinusOp,
	ModOp,
	MultOp,
	NeOp,
	NotOp,
	NotILikeOp,
	NotInOp,
	NotLikeOp,
	NotRegIMatchOp,
	NotRegMatchOp,
	NotSimilarToOp,
	NthValueOp,
	NtileOp,
	NullOp,
	OrOp,
	OverlapsOp,
	PercentRankOp,
	PercentileContOp,
	PercentileDiscOp,
	PlaceholderOp,
	PlusOp,
	PowOp,
	ProjectionsOp,
	ProjectionsItemOp,
	RShiftOp,
	RangeOp,
	RankOp,
	RegIMatchOp,
	RegMatchOp,
	RegressionAvgXOp,
	RegressionAvgYOp,
	RegressionCountOp,
	RegressionInterceptOp,
	RegressionR2Op,
	RegressionSXXOp,
	RegressionSXYOp,
	RegressionSYYOp,
	RegressionSlopeOp,
	RowNumberOp,
	STCollectOp,
	STExtentOp,
	STMakeLineOp,
	STUnionOp,
	ScalarListOp,
	SimilarToOp,
	SqrDiffOp,
	StdDevOp,
	StdDevPopOp,
	StringAggOp,
	SubqueryOp,
	SumOp,
	SumIntOp,
	TrueOp,
	TupleOp,
	UDFOp,
	UnaryCbrtOp,
	UnaryComplementOp,
	UnaryMinusOp,
	UnaryPlusOp,
	UnarySqrtOp,
	UniqueChecksOp,
	UniqueChecksItemOp,
	VarPopOp,
	VariableOp,
	VarianceOp,
	WhenOp,
	WindowFromOffsetOp,
	WindowToOffsetOp,
	WindowsOp,
	WindowsItemOp,
	XorAggOp,
	ZipOp,
	ZipItemOp,
}

func IsScalarOp(e Expr) bool {
	switch e.Op() {
	case AggDistinctOp, AggFilterOp, AggregationsOp, AggregationsItemOp,
		AndOp, AnyOp, AnyNotNullAggOp, AnyScalarOp, ArrayOp,
		ArrayAggOp, ArrayFlattenOp, AssignmentCastOp, AvgOp, BBoxCoversOp,
		BBoxIntersectsOp, BitAndAggOp, BitOrAggOp, BitandOp, BitorOp,
		BitxorOp, BoolAndOp, BoolOrOp, CaseOp, CastOp,
		CoalesceOp, CollateOp, ColumnAccessOp, ConcatOp, ConcatAggOp,
		ConstOp, ConstAggOp, ConstNotNullAggOp, ContainedByOp, ContainsOp,
		CorrOp, CountOp, CountRowsOp, CovarPopOp, CovarSampOp,
		CumeDistOp, DenseRankOp, DivOp, EqOp, ExistsOp,
		FKChecksOp, FKChecksItemOp, FalseOp, FetchTextOp, FetchTextPathOp,
		FetchValOp, FetchValPathOp, FiltersOp, FiltersItemOp, FirstAggOp,
		FirstValueOp, FloorDivOp, FunctionOp, GeOp, GtOp,
		ILikeOp, IfErrOp, InOp, IndirectionOp, IsOp,
		IsNotOp, IsTupleNotNullOp, IsTupleNullOp, JsonAggOp, JsonAllExistsOp,
		JsonExistsOp, JsonObjectAggOp, JsonSomeExistsOp, JsonbAggOp, JsonbObjectAggOp,
		KVOptionsOp, KVOptionsItemOp, LShiftOp, LagOp, LastValueOp,
		LeOp, LeadOp, LikeOp, LtOp, MaxOp,
		MinOp, MinusOp, ModOp, MultOp, NeOp,
		NotOp, NotILikeOp, NotInOp, NotLikeOp, NotRegIMatchOp,
		NotRegMatchOp, NotSimilarToOp, NthValueOp, NtileOp, NullOp,
		OrOp, OverlapsOp, PercentRankOp, PercentileContOp, PercentileDiscOp,
		PlaceholderOp, PlusOp, PowOp, ProjectionsOp, ProjectionsItemOp,
		RShiftOp, RangeOp, RankOp, RegIMatchOp, RegMatchOp,
		RegressionAvgXOp, RegressionAvgYOp, RegressionCountOp, RegressionInterceptOp, RegressionR2Op,
		RegressionSXXOp, RegressionSXYOp, RegressionSYYOp, RegressionSlopeOp, RowNumberOp,
		STCollectOp, STExtentOp, STMakeLineOp, STUnionOp, ScalarListOp,
		SimilarToOp, SqrDiffOp, StdDevOp, StdDevPopOp, StringAggOp,
		SubqueryOp, SumOp, SumIntOp, TrueOp, TupleOp,
		UDFOp, UnaryCbrtOp, UnaryComplementOp, UnaryMinusOp, UnaryPlusOp,
		UnarySqrtOp, UniqueChecksOp, UniqueChecksItemOp, VarPopOp, VariableOp,
		VarianceOp, WhenOp, WindowFromOffsetOp, WindowToOffsetOp, WindowsOp,
		WindowsItemOp, XorAggOp, ZipOp, ZipItemOp:
		return true
	}
	return false
}

var ListOperators = [...]Operator{
	AggregationsOp,
	FKChecksOp,
	FiltersOp,
	KVOptionsOp,
	ProjectionsOp,
	ScalarListOp,
	UniqueChecksOp,
	WindowsOp,
	ZipOp,
}

func IsListOp(e Expr) bool {
	switch e.Op() {
	case AggregationsOp, FKChecksOp, FiltersOp, KVOptionsOp,
		ProjectionsOp, ScalarListOp, UniqueChecksOp, WindowsOp, ZipOp:
		return true
	}
	return false
}

var ListItemOperators = [...]Operator{
	AggregationsItemOp,
	FKChecksItemOp,
	FiltersItemOp,
	KVOptionsItemOp,
	ProjectionsItemOp,
	UniqueChecksItemOp,
	WindowsItemOp,
	ZipItemOp,
}

func IsListItemOp(e Expr) bool {
	switch e.Op() {
	case AggregationsItemOp, FKChecksItemOp, FiltersItemOp, KVOptionsItemOp,
		ProjectionsItemOp, UniqueChecksItemOp, WindowsItemOp, ZipItemOp:
		return true
	}
	return false
}

var JoinOperators = [...]Operator{
	AntiJoinOp,
	AntiJoinApplyOp,
	FullJoinOp,
	InnerJoinOp,
	InnerJoinApplyOp,
	LeftJoinOp,
	LeftJoinApplyOp,
	RightJoinOp,
	SemiJoinOp,
	SemiJoinApplyOp,
}

func IsJoinOp(e Expr) bool {
	switch e.Op() {
	case AntiJoinOp, AntiJoinApplyOp, FullJoinOp, InnerJoinOp,
		InnerJoinApplyOp, LeftJoinOp, LeftJoinApplyOp, RightJoinOp, SemiJoinOp,
		SemiJoinApplyOp:
		return true
	}
	return false
}

var JoinNonApplyOperators = [...]Operator{
	AntiJoinOp,
	FullJoinOp,
	InnerJoinOp,
	LeftJoinOp,
	RightJoinOp,
	SemiJoinOp,
}

func IsJoinNonApplyOp(e Expr) bool {
	switch e.Op() {
	case AntiJoinOp, FullJoinOp, InnerJoinOp, LeftJoinOp,
		RightJoinOp, SemiJoinOp:
		return true
	}
	return false
}

var JoinApplyOperators = [...]Operator{
	AntiJoinApplyOp,
	InnerJoinApplyOp,
	LeftJoinApplyOp,
	SemiJoinApplyOp,
}

func IsJoinApplyOp(e Expr) bool {
	switch e.Op() {
	case AntiJoinApplyOp, InnerJoinApplyOp, LeftJoinApplyOp, SemiJoinApplyOp:
		return true
	}
	return false
}

var GroupingOperators = [...]Operator{
	DistinctOnOp,
	EnsureDistinctOnOp,
	EnsureUpsertDistinctOnOp,
	GroupByOp,
	ScalarGroupByOp,
	UpsertDistinctOnOp,
}

func IsGroupingOp(e Expr) bool {
	switch e.Op() {
	case DistinctOnOp, EnsureDistinctOnOp, EnsureUpsertDistinctOnOp, GroupByOp,
		ScalarGroupByOp, UpsertDistinctOnOp:
		return true
	}
	return false
}

var SetOperators = [...]Operator{
	ExceptOp,
	ExceptAllOp,
	IntersectOp,
	IntersectAllOp,
	LocalityOptimizedSearchOp,
	UnionOp,
	UnionAllOp,
}

func IsSetOp(e Expr) bool {
	switch e.Op() {
	case ExceptOp, ExceptAllOp, IntersectOp, IntersectAllOp,
		LocalityOptimizedSearchOp, UnionOp, UnionAllOp:
		return true
	}
	return false
}

var BoolOperators = [...]Operator{
	AndOp,
	AnyOp,
	AnyScalarOp,
	BBoxCoversOp,
	BBoxIntersectsOp,
	ContainedByOp,
	ContainsOp,
	EqOp,
	ExistsOp,
	FalseOp,
	FiltersOp,
	FiltersItemOp,
	GeOp,
	GtOp,
	ILikeOp,
	InOp,
	IsOp,
	IsNotOp,
	IsTupleNotNullOp,
	IsTupleNullOp,
	JsonAllExistsOp,
	JsonExistsOp,
	JsonSomeExistsOp,
	LeOp,
	LikeOp,
	LtOp,
	NeOp,
	NotOp,
	NotILikeOp,
	NotInOp,
	NotLikeOp,
	NotRegIMatchOp,
	NotRegMatchOp,
	NotSimilarToOp,
	OrOp,
	OverlapsOp,
	RangeOp,
	RegIMatchOp,
	RegMatchOp,
	SimilarToOp,
	TrueOp,
}

func IsBoolOp(e Expr) bool {
	switch e.Op() {
	case AndOp, AnyOp, AnyScalarOp, BBoxCoversOp,
		BBoxIntersectsOp, ContainedByOp, ContainsOp, EqOp, ExistsOp,
		FalseOp, FiltersOp, FiltersItemOp, GeOp, GtOp,
		ILikeOp, InOp, IsOp, IsNotOp, IsTupleNotNullOp,
		IsTupleNullOp, JsonAllExistsOp, JsonExistsOp, JsonSomeExistsOp, LeOp,
		LikeOp, LtOp, NeOp, NotOp, NotILikeOp,
		NotInOp, NotLikeOp, NotRegIMatchOp, NotRegMatchOp, NotSimilarToOp,
		OrOp, OverlapsOp, RangeOp, RegIMatchOp, RegMatchOp,
		SimilarToOp, TrueOp:
		return true
	}
	return false
}

var CompositeInsensitiveOperators = [...]Operator{
	ContainedByOp,
	ContainsOp,
	DivOp,
	EqOp,
	FloorDivOp,
	GeOp,
	GtOp,
	InOp,
	IsOp,
	IsNotOp,
	LeOp,
	LtOp,
	MinusOp,
	ModOp,
	MultOp,
	NeOp,
	NotInOp,
	PlusOp,
	PowOp,
	ScalarListOp,
	UnaryCbrtOp,
	UnaryMinusOp,
	UnaryPlusOp,
	UnarySqrtOp,
	VariableOp,
}

func IsCompositeInsensitiveOp(e Expr) bool {
	switch e.Op() {
	case ContainedByOp, ContainsOp, DivOp, EqOp,
		FloorDivOp, GeOp, GtOp, InOp, IsOp,
		IsNotOp, LeOp, LtOp, MinusOp, ModOp,
		MultOp, NeOp, NotInOp, PlusOp, PowOp,
		ScalarListOp, UnaryCbrtOp, UnaryMinusOp, UnaryPlusOp, UnarySqrtOp,
		VariableOp:
		return true
	}
	return false
}

var ConstValueOperators = [...]Operator{
	ConstOp,
	FalseOp,
	NullOp,
	TrueOp,
}

func IsConstValueOp(e Expr) bool {
	switch e.Op() {
	case ConstOp, FalseOp, NullOp, TrueOp:
		return true
	}
	return false
}

var ScalarPropsOperators = [...]Operator{
	AggregationsItemOp,
	FiltersItemOp,
	ProjectionsItemOp,
	WindowsItemOp,
	ZipItemOp,
}

func IsScalarPropsOp(e Expr) bool {
	switch e.Op() {
	case AggregationsItemOp, FiltersItemOp, ProjectionsItemOp, WindowsItemOp,
		ZipItemOp:
		return true
	}
	return false
}

var ComparisonOperators = [...]Operator{
	BBoxCoversOp,
	BBoxIntersectsOp,
	ContainedByOp,
	ContainsOp,
	EqOp,
	GeOp,
	GtOp,
	ILikeOp,
	InOp,
	IsOp,
	IsNotOp,
	JsonAllExistsOp,
	JsonExistsOp,
	JsonSomeExistsOp,
	LeOp,
	LikeOp,
	LtOp,
	NeOp,
	NotILikeOp,
	NotInOp,
	NotLikeOp,
	NotRegIMatchOp,
	NotRegMatchOp,
	NotSimilarToOp,
	OverlapsOp,
	RegIMatchOp,
	RegMatchOp,
	SimilarToOp,
}

func IsComparisonOp(e Expr) bool {
	switch e.Op() {
	case BBoxCoversOp, BBoxIntersectsOp, ContainedByOp, ContainsOp,
		EqOp, GeOp, GtOp, ILikeOp, InOp,
		IsOp, IsNotOp, JsonAllExistsOp, JsonExistsOp, JsonSomeExistsOp,
		LeOp, LikeOp, LtOp, NeOp, NotILikeOp,
		NotInOp, NotLikeOp, NotRegIMatchOp, NotRegMatchOp, NotSimilarToOp,
		OverlapsOp, RegIMatchOp, RegMatchOp, SimilarToOp:
		return true
	}
	return false
}

var BinaryOperators = [...]Operator{
	BitandOp,
	BitorOp,
	BitxorOp,
	ConcatOp,
	DivOp,
	FetchTextOp,
	FetchTextPathOp,
	FetchValOp,
	FetchValPathOp,
	FloorDivOp,
	LShiftOp,
	MinusOp,
	ModOp,
	MultOp,
	PlusOp,
	PowOp,
	RShiftOp,
}

func IsBinaryOp(e Expr) bool {
	switch e.Op() {
	case BitandOp, BitorOp, BitxorOp, ConcatOp,
		DivOp, FetchTextOp, FetchTextPathOp, FetchValOp, FetchValPathOp,
		FloorDivOp, LShiftOp, MinusOp, ModOp, MultOp,
		PlusOp, PowOp, RShiftOp:
		return true
	}
	return false
}

var UnaryOperators = [...]Operator{
	UnaryCbrtOp,
	UnaryComplementOp,
	UnaryMinusOp,
	UnaryPlusOp,
	UnarySqrtOp,
}

func IsUnaryOp(e Expr) bool {
	switch e.Op() {
	case UnaryCbrtOp, UnaryComplementOp, UnaryMinusOp, UnaryPlusOp,
		UnarySqrtOp:
		return true
	}
	return false
}

var AggregateOperators = [...]Operator{
	AnyNotNullAggOp,
	ArrayAggOp,
	AvgOp,
	BitAndAggOp,
	BitOrAggOp,
	BoolAndOp,
	BoolOrOp,
	ConcatAggOp,
	ConstAggOp,
	ConstNotNullAggOp,
	CorrOp,
	CountOp,
	CountRowsOp,
	CovarPopOp,
	CovarSampOp,
	FirstAggOp,
	JsonAggOp,
	JsonObjectAggOp,
	JsonbAggOp,
	JsonbObjectAggOp,
	MaxOp,
	MinOp,
	PercentileContOp,
	PercentileDiscOp,
	RegressionAvgXOp,
	RegressionAvgYOp,
	RegressionCountOp,
	RegressionInterceptOp,
	RegressionR2Op,
	RegressionSXXOp,
	RegressionSXYOp,
	RegressionSYYOp,
	RegressionSlopeOp,
	STCollectOp,
	STExtentOp,
	STMakeLineOp,
	STUnionOp,
	SqrDiffOp,
	StdDevOp,
	StdDevPopOp,
	StringAggOp,
	SumOp,
	SumIntOp,
	VarPopOp,
	VarianceOp,
	XorAggOp,
}

func IsAggregateOp(e Expr) bool {
	switch e.Op() {
	case AnyNotNullAggOp, ArrayAggOp, AvgOp, BitAndAggOp,
		BitOrAggOp, BoolAndOp, BoolOrOp, ConcatAggOp, ConstAggOp,
		ConstNotNullAggOp, CorrOp, CountOp, CountRowsOp, CovarPopOp,
		CovarSampOp, FirstAggOp, JsonAggOp, JsonObjectAggOp, JsonbAggOp,
		JsonbObjectAggOp, MaxOp, MinOp, PercentileContOp, PercentileDiscOp,
		RegressionAvgXOp, RegressionAvgYOp, RegressionCountOp, RegressionInterceptOp, RegressionR2Op,
		RegressionSXXOp, RegressionSXYOp, RegressionSYYOp, RegressionSlopeOp, STCollectOp,
		STExtentOp, STMakeLineOp, STUnionOp, SqrDiffOp, StdDevOp,
		StdDevPopOp, StringAggOp, SumOp, SumIntOp, VarPopOp,
		VarianceOp, XorAggOp:
		return true
	}
	return false
}

var IntOperators = [...]Operator{
	CountRowsOp,
	DenseRankOp,
	NtileOp,
	RankOp,
	RowNumberOp,
}

func IsIntOp(e Expr) bool {
	switch e.Op() {
	case CountRowsOp, DenseRankOp, NtileOp, RankOp,
		RowNumberOp:
		return true
	}
	return false
}

var WindowOperators = [...]Operator{
	CumeDistOp,
	DenseRankOp,
	FirstValueOp,
	LagOp,
	LastValueOp,
	LeadOp,
	NthValueOp,
	NtileOp,
	PercentRankOp,
	RankOp,
	RowNumberOp,
}

func IsWindowOp(e Expr) bool {
	switch e.Op() {
	case CumeDistOp, DenseRankOp, FirstValueOp, LagOp,
		LastValueOp, LeadOp, NthValueOp, NtileOp, PercentRankOp,
		RankOp, RowNumberOp:
		return true
	}
	return false
}

var FloatOperators = [...]Operator{
	CumeDistOp,
	PercentRankOp,
}

func IsFloatOp(e Expr) bool {
	switch e.Op() {
	case CumeDistOp, PercentRankOp:
		return true
	}
	return false
}

var DDLOperators = [...]Operator{
	CreateFunctionOp,
	CreateTableOp,
	CreateViewOp,
	OpaqueDDLOp,
}

func IsDDLOp(e Expr) bool {
	switch e.Op() {
	case CreateFunctionOp, CreateTableOp, CreateViewOp, OpaqueDDLOp:
		return true
	}
	return false
}
