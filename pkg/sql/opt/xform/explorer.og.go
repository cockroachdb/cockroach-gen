// Code generated by optgen; DO NOT EDIT.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

func (_e *explorer) exploreGroupMember(
	state *exploreState,
	member memo.RelExpr,
	ordinal int,
) (_fullyExplored bool) {
	switch t := member.(type) {
	case *memo.ScanExpr:
		return _e.exploreScan(state, t, ordinal)
	case *memo.SelectExpr:
		return _e.exploreSelect(state, t, ordinal)
	case *memo.ProjectExpr:
		return _e.exploreProject(state, t, ordinal)
	case *memo.InnerJoinExpr:
		return _e.exploreInnerJoin(state, t, ordinal)
	case *memo.LeftJoinExpr:
		return _e.exploreLeftJoin(state, t, ordinal)
	case *memo.RightJoinExpr:
		return _e.exploreRightJoin(state, t, ordinal)
	case *memo.FullJoinExpr:
		return _e.exploreFullJoin(state, t, ordinal)
	case *memo.SemiJoinExpr:
		return _e.exploreSemiJoin(state, t, ordinal)
	case *memo.AntiJoinExpr:
		return _e.exploreAntiJoin(state, t, ordinal)
	case *memo.GroupByExpr:
		return _e.exploreGroupBy(state, t, ordinal)
	case *memo.ScalarGroupByExpr:
		return _e.exploreScalarGroupBy(state, t, ordinal)
	case *memo.DistinctOnExpr:
		return _e.exploreDistinctOn(state, t, ordinal)
	case *memo.EnsureDistinctOnExpr:
		return _e.exploreEnsureDistinctOn(state, t, ordinal)
	case *memo.UpsertDistinctOnExpr:
		return _e.exploreUpsertDistinctOn(state, t, ordinal)
	case *memo.EnsureUpsertDistinctOnExpr:
		return _e.exploreEnsureUpsertDistinctOn(state, t, ordinal)
	case *memo.LimitExpr:
		return _e.exploreLimit(state, t, ordinal)
	}

	// No rules for other operator types.
	return true
}

func (_e *explorer) exploreScan(
	_rootState *exploreState,
	_root *memo.ScanExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateIndexScans]
	{
		if _rootOrd >= _rootState.start {
			scanPrivate := &_root.ScanPrivate
			if _e.funcs.IsCanonicalScan(scanPrivate) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateIndexScans) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateIndexScans(_root, scanPrivate)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateIndexScans, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreSelect(
	_rootState *exploreState,
	_root *memo.SelectExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateZigzagJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scan := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scan) {
						if !_e.funcs.IsLocking(scan) {
							filters := _root.Filters
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateZigzagJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateZigzagJoins(_root, scan, filters)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateZigzagJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedIndexZigzagJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scan := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scan) {
						if !_e.funcs.IsLocking(scan) {
							if _e.funcs.HasInvertedIndexes(scan) {
								filters := _root.Filters
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedIndexZigzagJoins) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateInvertedIndexZigzagJoins(_root, scan, filters)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateInvertedIndexZigzagJoins, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GeneratePartialIndexScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						filters := _root.Filters
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GeneratePartialIndexScans) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GeneratePartialIndexScans(_root, scanPrivate, filters)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GeneratePartialIndexScans, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateConstrainedScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						filters := _root.Filters
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateConstrainedScans) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateConstrainedScans(_root, scanPrivate, filters)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateConstrainedScans, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedIndexScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							filters := _root.Filters
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedIndexScans) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedIndexScans(_root, scanPrivate, filters)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedIndexScans, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitDisjunction]
	{
		_partlyExplored := _rootOrd < _rootState.start
		input := _root.Input
		_state := _e.lookupExploreState(input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasStrictKey(input) {
							filters := _root.Filters
							pair := _e.funcs.ExprPairForSplitDisjunction(scanPrivate, filters)
							if _e.funcs.ExprPairSucceeded(pair) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitDisjunction) {
									leftScan := _e.f.ConstructScan(
										_e.funcs.DuplicateScanPrivate(scanPrivate),
									)
									rightScan := _e.f.ConstructScan(
										_e.funcs.DuplicateScanPrivate(scanPrivate),
									)
									_expr := &memo.DistinctOnExpr{
										Input: _e.f.ConstructUnionAll(
											_e.f.ConstructSelect(
												leftScan,
												_e.funcs.MapFilterCols(_e.funcs.ReplaceFiltersItem(filters, _e.funcs.ExprPairFiltersItemToReplace(pair), _e.funcs.ExprPairLeft(pair)), _e.funcs.OutputCols(input), _e.funcs.OutputCols(leftScan)),
											),
											_e.f.ConstructSelect(
												rightScan,
												_e.funcs.MapFilterCols(_e.funcs.ReplaceFiltersItem(filters, _e.funcs.ExprPairFiltersItemToReplace(pair), _e.funcs.ExprPairRight(pair)), _e.funcs.OutputCols(input), _e.funcs.OutputCols(rightScan)),
											),
											_e.funcs.MakeSetPrivate(_e.funcs.OutputCols(leftScan), _e.funcs.OutputCols(rightScan), _e.funcs.OutputCols(input)),
										),
										Aggregations:    _e.funcs.MakeAggCols(opt.ConstAggOp, _e.funcs.NonKeyCols(input)),
										GroupingPrivate: *_e.funcs.MakeGrouping(_e.funcs.KeyCols(input), _e.funcs.EmptyOrdering()),
									}
									_interned := _e.mem.AddDistinctOnToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.SplitDisjunction, _root, nil)
										} else {
											_e.o.appliedRule(opt.SplitDisjunction, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitDisjunctionAddKey]
	{
		_partlyExplored := _rootOrd < _rootState.start
		input := _root.Input
		_state := _e.lookupExploreState(input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if !_e.funcs.HasStrictKey(input) {
							filters := _root.Filters
							pair := _e.funcs.ExprPairForSplitDisjunction(scanPrivate, filters)
							if _e.funcs.ExprPairSucceeded(pair) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitDisjunctionAddKey) {
									leftScan := _e.f.ConstructScan(
										_e.funcs.AddPrimaryKeyColsToScanPrivate(_e.funcs.DuplicateScanPrivate(scanPrivate)),
									)
									groupingCols := _e.funcs.PrimaryKeyCols(_e.funcs.TableIDFromScanPrivate(scanPrivate))
									outCols := _e.funcs.UnionCols(_e.funcs.OutputCols(input), groupingCols)
									rightScan := _e.f.ConstructScan(
										_e.funcs.AddPrimaryKeyColsToScanPrivate(_e.funcs.DuplicateScanPrivate(scanPrivate)),
									)
									_expr := &memo.ProjectExpr{
										Input: _e.f.ConstructDistinctOn(
											_e.f.ConstructUnionAll(
												_e.f.ConstructSelect(
													leftScan,
													_e.funcs.MapFilterCols(_e.funcs.ReplaceFiltersItem(filters, _e.funcs.ExprPairFiltersItemToReplace(pair), _e.funcs.ExprPairLeft(pair)), outCols, _e.funcs.OutputCols(leftScan)),
												),
												_e.f.ConstructSelect(
													rightScan,
													_e.funcs.MapFilterCols(_e.funcs.ReplaceFiltersItem(filters, _e.funcs.ExprPairFiltersItemToReplace(pair), _e.funcs.ExprPairRight(pair)), outCols, _e.funcs.OutputCols(rightScan)),
												),
												_e.funcs.MakeSetPrivate(_e.funcs.OutputCols(leftScan), _e.funcs.OutputCols(rightScan), outCols),
											),
											_e.funcs.MakeAggCols(opt.ConstAggOp, _e.funcs.OutputCols(input)),
											_e.funcs.MakeGrouping(groupingCols, _e.funcs.EmptyOrdering()),
										),
										Projections: memo.EmptyProjectionsExpr,
										Passthrough: _e.funcs.OutputCols(input),
									}
									_interned := _e.mem.AddProjectToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.SplitDisjunctionAddKey, _root, nil)
										} else {
											_e.o.appliedRule(opt.SplitDisjunctionAddKey, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreProject(
	_rootState *exploreState,
	_root *memo.ProjectExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [EliminateIndexJoinInsideProject]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					input := _indexJoin.Input
					projections := _root.Projections
					passthrough := _root.Passthrough
					if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(_e.funcs.ProjectionOuterCols(projections), passthrough), _e.funcs.OutputCols(input)) {
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinInsideProject) {
							_expr := &memo.ProjectExpr{
								Input:       input,
								Projections: projections,
								Passthrough: passthrough,
							}
							_interned := _e.mem.AddProjectToGroup(_expr, _root)
							if _e.o.appliedRule != nil {
								if _interned != _expr {
									_e.o.appliedRule(opt.EliminateIndexJoinInsideProject, _root, nil)
								} else {
									_e.o.appliedRule(opt.EliminateIndexJoinInsideProject, _root, _interned)
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreInnerJoin(
	_rootState *exploreState,
	_root *memo.InnerJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.InnerJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, opt.InnerJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							on := _root.On
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedJoins(_root, opt.InnerJoinOp, left, scanPrivate, on, private)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoinsFromSelect]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								if _e.funcs.HasInvertedIndexes(scanPrivate) {
									filters := _select.Filters
									on := _root.On
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoinsFromSelect) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateInvertedJoins(_root, opt.InnerJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateInvertedJoinsFromSelect, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, opt.InnerJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushJoinIntoIndexJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(left)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = left.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					indexInput := _indexJoin.Input
					indexPrivate := &_indexJoin.IndexJoinPrivate
					right := _root.Right
					if !_e.funcs.HasOuterCols(right) {
						on := _root.On
						if _e.funcs.FiltersBoundBy(on, _e.funcs.OutputCols2(indexInput, right)) {
							joinPrivate := &_root.JoinPrivate
							if _e.funcs.NoJoinHints(joinPrivate) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushJoinIntoIndexJoin) {
									_expr := &memo.LookupJoinExpr{
										Input: _e.f.ConstructInnerJoin(
											indexInput,
											right,
											on,
											joinPrivate,
										),
										On:                memo.EmptyFiltersExpr,
										LookupJoinPrivate: *_e.funcs.ConvertIndexToLookupJoinPrivate(indexPrivate, _e.funcs.OutputCols2(left, right)),
									}
									_interned := _e.mem.AddLookupJoinToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.PushJoinIntoIndexJoin, _root, nil)
										} else {
											_e.o.appliedRule(opt.PushJoinIntoIndexJoin, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreLeftJoin(
	_rootState *exploreState,
	_root *memo.LeftJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [CommuteLeftJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.CommuteLeftJoin) {
				_expr := &memo.RightJoinExpr{
					Left:        right,
					Right:       left,
					On:          on,
					JoinPrivate: *_e.funcs.CommuteJoinFlags(private),
				}
				_interned := _e.mem.AddRightJoinToGroup(_expr, _root)
				if _e.o.appliedRule != nil {
					if _interned != _expr {
						_e.o.appliedRule(opt.CommuteLeftJoin, _root, nil)
					} else {
						_e.o.appliedRule(opt.CommuteLeftJoin, _root, _interned)
					}
				}
			}
		}
	}

	// [ConvertLeftToInnerJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			if _e.funcs.CanGenerateInvertedJoin(right, on) {
				private := &_root.JoinPrivate
				if _e.funcs.NoJoinHints(private) {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ConvertLeftToInnerJoin) {
						newLeft := _e.funcs.EnsureKey(left)
						bindingExpr := _e.funcs.ReplaceOutputCols(newLeft)
						id := _e.funcs.AddWithBinding(bindingExpr)
						outerLeft := _e.funcs.MakeWithScanUsingCols(id, _e.funcs.OutputCols(newLeft))
						innerLeft := _e.funcs.MakeWithScan(id)
						_expr := &memo.WithExpr{
							Binding: bindingExpr,
							Main: _e.f.ConstructProject(
								_e.f.ConstructLeftJoin(
									outerLeft,
									_e.f.ConstructInnerJoin(
										innerLeft,
										right,
										_e.funcs.MapFilterCols(on, _e.funcs.OutputCols(newLeft), _e.funcs.OutputCols(innerLeft)),
										_e.funcs.EmptyJoinPrivate(),
									),
									_e.funcs.MakeWithScanKeyEqualityFilters(outerLeft, innerLeft),
									private,
								),
								memo.EmptyProjectionsExpr,
								_e.funcs.OutputCols2(left, right),
							),
							WithPrivate: *_e.funcs.MakeWithPrivate(id),
						}
						_interned := _e.mem.AddWithToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.ConvertLeftToInnerJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.ConvertLeftToInnerJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.LeftJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, opt.LeftJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, opt.LeftJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreRightJoin(
	_rootState *exploreState,
	_root *memo.RightJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.RightJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreFullJoin(
	_rootState *exploreState,
	_root *memo.FullJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.FullJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreSemiJoin(
	_rootState *exploreState,
	_root *memo.SemiJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [CommuteSemiJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			if _e.funcs.IsSimpleEquality(on) {
				private := &_root.JoinPrivate
				if _e.funcs.NoJoinHints(private) {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.CommuteSemiJoin) {
						_expr := &memo.ProjectExpr{
							Input: _e.f.ConstructInnerJoin(
								left,
								_e.f.ConstructDistinctOn(
									right,
									memo.EmptyAggregationsExpr,
									_e.funcs.MakeGrouping(_e.funcs.IntersectionCols(_e.funcs.OutputCols(right), _e.funcs.FilterOuterCols(on)), _e.funcs.EmptyOrdering()),
								),
								on,
								private,
							),
							Projections: memo.EmptyProjectionsExpr,
							Passthrough: _e.funcs.OutputCols(left),
						}
						_interned := _e.mem.AddProjectToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.CommuteSemiJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.CommuteSemiJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [ConvertSemiToInnerJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			if !_e.funcs.IsSimpleEquality(on) {
				private := &_root.JoinPrivate
				if _e.funcs.NoJoinHints(private) {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ConvertSemiToInnerJoin) {
						newLeft := _e.funcs.EnsureKey(left)
						_expr := &memo.ProjectExpr{
							Input: _e.f.ConstructDistinctOn(
								_e.f.ConstructInnerJoin(
									newLeft,
									right,
									on,
									private,
								),
								_e.funcs.MakeAggCols(opt.ConstAggOp, _e.funcs.NonKeyCols(newLeft)),
								_e.funcs.MakeGrouping(_e.funcs.KeyCols(newLeft), _e.funcs.EmptyOrdering()),
							),
							Projections: memo.EmptyProjectionsExpr,
							Passthrough: _e.funcs.OutputCols(left),
						}
						_interned := _e.mem.AddProjectToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.ConvertSemiToInnerJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.ConvertSemiToInnerJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.SemiJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, opt.SemiJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, opt.SemiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreAntiJoin(
	_rootState *exploreState,
	_root *memo.AntiJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [ConvertAntiToLeftJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			if _e.funcs.CanGenerateInvertedJoin(right, on) {
				private := &_root.JoinPrivate
				if _e.funcs.NoJoinHints(private) {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ConvertAntiToLeftJoin) {
						newRight := _e.funcs.EnsureNotNullColFromFilteredScan(right)
						variable := _e.f.ConstructVariable(
							_e.funcs.NotNullCol(newRight),
						)
						_expr := &memo.ProjectExpr{
							Input: _e.f.ConstructSelect(
								_e.f.ConstructLeftJoin(
									left,
									newRight,
									on,
									private,
								),
								memo.FiltersExpr{
									_e.f.ConstructFiltersItem(
										_e.f.ConstructIs(
											variable,
											_e.f.ConstructNull(
												_e.funcs.TypeOf(variable),
											),
										),
									),
								},
							),
							Projections: memo.EmptyProjectionsExpr,
							Passthrough: _e.funcs.OutputCols(left),
						}
						_interned := _e.mem.AddProjectToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.ConvertAntiToLeftJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.ConvertAntiToLeftJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.AntiJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, opt.AntiJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, opt.AntiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreGroupBy(
	_rootState *exploreState,
	_root *memo.GroupByExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReplaceMinWithLimit]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggregations := _root.Aggregations
			for i := range aggregations {
				item := &aggregations[i]
				_min, _ := item.Agg.(*memo.MinExpr)
				if _min != nil {
					variable := _min.Input
					_variable, _ := variable.(*memo.VariableExpr)
					if _variable != nil {
						col := _variable.Col
						if _e.funcs.IsColNotNull(col, input) {
							if _e.funcs.OtherAggsAreConst(aggregations, item) {
								groupingPrivate := &_root.GroupingPrivate
								if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
									if _e.funcs.ColsAreConst(_e.funcs.GroupingCols(groupingPrivate), input) {
										if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceMinWithLimit) {
											var _last memo.RelExpr
											if _e.o.appliedRule != nil {
												_last = memo.LastGroupMember(_root)
											}
											_e.funcs.MakeProjectFromPassthroughAggs(_root, _e.f.ConstructLimit(
												input,
												_e.funcs.IntConst(tree.NewDInt(1)),
												_e.funcs.MakeOrderingChoiceFromColumn(opt.MinOp, col),
											), aggregations)
											if _e.o.appliedRule != nil {
												_e.o.appliedRule(opt.ReplaceMinWithLimit, _root, _last.NextExpr())
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ReplaceMaxWithLimit]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggregations := _root.Aggregations
			for i := range aggregations {
				item := &aggregations[i]
				_max, _ := item.Agg.(*memo.MaxExpr)
				if _max != nil {
					variable := _max.Input
					_variable, _ := variable.(*memo.VariableExpr)
					if _variable != nil {
						col := _variable.Col
						if _e.funcs.OtherAggsAreConst(aggregations, item) {
							groupingPrivate := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
								if _e.funcs.ColsAreConst(_e.funcs.GroupingCols(groupingPrivate), input) {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceMaxWithLimit) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.MakeProjectFromPassthroughAggs(_root, _e.f.ConstructLimit(
											input,
											_e.funcs.IntConst(tree.NewDInt(1)),
											_e.funcs.MakeOrderingChoiceFromColumn(opt.MaxOp, col),
										), aggregations)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.ReplaceMaxWithLimit, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.GroupByOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreScalarGroupBy(
	_rootState *exploreState,
	_root *memo.ScalarGroupByExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReplaceScalarMinMaxWithLimit]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			if len(_root.Aggregations) == 1 {
				_item := &_root.Aggregations[0]
				agg := _item.Agg
				if agg.Op() == opt.MinOp || agg.Op() == opt.MaxOp {
					variable := agg.Child(0).(opt.ScalarExpr)
					_variable, _ := variable.(*memo.VariableExpr)
					if _variable != nil {
						col := _variable.Col
						aggPrivate := _item.Col
						groupingPrivate := &_root.GroupingPrivate
						if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceScalarMinMaxWithLimit) {
								_expr := &memo.ScalarGroupByExpr{
									Input: _e.f.ConstructLimit(
										_e.f.ConstructSelect(
											input,
											memo.FiltersExpr{
												_e.f.ConstructFiltersItem(
													_e.f.ConstructIsNot(
														variable,
														_e.f.ConstructNull(
															_e.funcs.AnyType(),
														),
													),
												),
											},
										),
										_e.funcs.IntConst(tree.NewDInt(1)),
										_e.funcs.MakeOrderingChoiceFromColumn(agg.Op(), col),
									),
									Aggregations: memo.AggregationsExpr{
										_e.f.ConstructAggregationsItem(
											_e.f.ConstructConstAgg(
												variable,
											),
											aggPrivate,
										),
									},
									GroupingPrivate: *groupingPrivate,
								}
								_interned := _e.mem.AddScalarGroupByToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.ReplaceScalarMinMaxWithLimit, _root, nil)
									} else {
										_e.o.appliedRule(opt.ReplaceScalarMinMaxWithLimit, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreDistinctOn(
	_rootState *exploreState,
	_root *memo.DistinctOnExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.DistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreEnsureDistinctOn(
	_rootState *exploreState,
	_root *memo.EnsureDistinctOnExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.EnsureDistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreUpsertDistinctOn(
	_rootState *exploreState,
	_root *memo.UpsertDistinctOnExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.UpsertDistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreEnsureUpsertDistinctOn(
	_rootState *exploreState,
	_root *memo.EnsureUpsertDistinctOnExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.EnsureUpsertDistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreLimit(
	_rootState *exploreState,
	_root *memo.LimitExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateLimitedScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						_const, _ := _root.Limit.(*memo.ConstExpr)
						if _const != nil {
							limit := _const.Value
							if _e.funcs.IsPositiveInt(limit) {
								ordering := _root.Ordering
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLimitedScans) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLimitedScans(_root, scanPrivate, limit, ordering)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLimitedScans, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoFilteredScan]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					_const, _ := _root.Limit.(*memo.ConstExpr)
					if _const != nil {
						limit := _const.Value
						if _e.funcs.IsPositiveInt(limit) {
							ordering := _root.Ordering
							if _e.funcs.CanLimitFilteredScan(scanPrivate, ordering) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushLimitIntoFilteredScan) {
									_expr := &memo.ScanExpr{
										ScanPrivate: *_e.funcs.LimitScanPrivate(scanPrivate, limit, ordering),
									}
									_interned := _e.mem.AddScanToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.PushLimitIntoFilteredScan, _root, nil)
										} else {
											_e.o.appliedRule(opt.PushLimitIntoFilteredScan, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoIndexJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					input := _indexJoin.Input
					indexJoinPrivate := &_indexJoin.IndexJoinPrivate
					limitExpr := _root.Limit
					_const, _ := limitExpr.(*memo.ConstExpr)
					if _const != nil {
						limit := _const.Value
						if _e.funcs.IsPositiveInt(limit) {
							ordering := _root.Ordering
							cols := _e.funcs.OutputCols(input)
							if _e.funcs.OrderingCanProjectCols(ordering, cols) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushLimitIntoIndexJoin) {
									_expr := &memo.IndexJoinExpr{
										Input: _e.f.ConstructLimit(
											input,
											limitExpr,
											_e.funcs.PruneOrdering(ordering, cols),
										),
										IndexJoinPrivate: *indexJoinPrivate,
									}
									_interned := _e.mem.AddIndexJoinToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.PushLimitIntoIndexJoin, _root, nil)
										} else {
											_e.o.appliedRule(opt.PushLimitIntoIndexJoin, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if !_e.funcs.ScanIsLimited(scanPrivate) {
						if !_e.funcs.ScanIsInverted(scanPrivate) {
							limitExpr := _root.Limit
							_const, _ := limitExpr.(*memo.ConstExpr)
							if _const != nil {
								limit := _const.Value
								if _e.funcs.IsPositiveInt(limit) {
									ordering := _root.Ordering
									unionScans := _e.funcs.SplitScanIntoUnionScans(ordering, scan, scanPrivate, limit)
									if _e.funcs.Succeeded(unionScans) {
										if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitScanIntoUnionScans) {
											_expr := &memo.LimitExpr{
												Input:    unionScans,
												Limit:    limitExpr,
												Ordering: ordering,
											}
											_interned := _e.mem.AddLimitToGroup(_expr, _root)
											if _e.o.appliedRule != nil {
												if _interned != _expr {
													_e.o.appliedRule(opt.SplitScanIntoUnionScans, _root, nil)
												} else {
													_e.o.appliedRule(opt.SplitScanIntoUnionScans, _root, _interned)
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}
