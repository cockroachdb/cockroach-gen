// Code generated by optgen; DO NOT EDIT.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

func (_e *explorer) exploreGroupMember(
	state *exploreState,
	member memo.RelExpr,
	ordinal int,
) (_fullyExplored bool) {
	switch t := member.(type) {
	case *memo.ScanExpr:
		return _e.exploreScan(state, t, ordinal)
	case *memo.SelectExpr:
		return _e.exploreSelect(state, t, ordinal)
	case *memo.ProjectExpr:
		return _e.exploreProject(state, t, ordinal)
	case *memo.InnerJoinExpr:
		return _e.exploreInnerJoin(state, t, ordinal)
	case *memo.LeftJoinExpr:
		return _e.exploreLeftJoin(state, t, ordinal)
	case *memo.RightJoinExpr:
		return _e.exploreRightJoin(state, t, ordinal)
	case *memo.FullJoinExpr:
		return _e.exploreFullJoin(state, t, ordinal)
	case *memo.SemiJoinExpr:
		return _e.exploreSemiJoin(state, t, ordinal)
	case *memo.AntiJoinExpr:
		return _e.exploreAntiJoin(state, t, ordinal)
	case *memo.LookupJoinExpr:
		return _e.exploreLookupJoin(state, t, ordinal)
	case *memo.GroupByExpr:
		return _e.exploreGroupBy(state, t, ordinal)
	case *memo.ScalarGroupByExpr:
		return _e.exploreScalarGroupBy(state, t, ordinal)
	case *memo.DistinctOnExpr:
		return _e.exploreDistinctOn(state, t, ordinal)
	case *memo.EnsureDistinctOnExpr:
		return _e.exploreEnsureDistinctOn(state, t, ordinal)
	case *memo.UpsertDistinctOnExpr:
		return _e.exploreUpsertDistinctOn(state, t, ordinal)
	case *memo.EnsureUpsertDistinctOnExpr:
		return _e.exploreEnsureUpsertDistinctOn(state, t, ordinal)
	case *memo.UnionExpr:
		return _e.exploreUnion(state, t, ordinal)
	case *memo.IntersectExpr:
		return _e.exploreIntersect(state, t, ordinal)
	case *memo.ExceptExpr:
		return _e.exploreExcept(state, t, ordinal)
	case *memo.IntersectAllExpr:
		return _e.exploreIntersectAll(state, t, ordinal)
	case *memo.ExceptAllExpr:
		return _e.exploreExceptAll(state, t, ordinal)
	case *memo.LimitExpr:
		return _e.exploreLimit(state, t, ordinal)
	}

	// No rules for other operator types.
	return true
}

func (_e *explorer) exploreScan(
	_rootState *exploreState,
	_root *memo.ScanExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateIndexScans]
	{
		if _rootOrd >= _rootState.start {
			scanPrivate := &_root.ScanPrivate
			if _e.funcs.IsCanonicalScan(scanPrivate) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateIndexScans) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateIndexScans(_root, scanPrivate)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateIndexScans, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [GenerateLocalityOptimizedScan]
	{
		if _rootOrd >= _rootState.start {
			scanPrivate := &_root.ScanPrivate
			if _e.funcs.CanMaybeGenerateLocalityOptimizedScan(scanPrivate) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLocalityOptimizedScan) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateLocalityOptimizedScan(_root, scanPrivate)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateLocalityOptimizedScan, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreSelect(
	_rootState *exploreState,
	_root *memo.SelectExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GeneratePartialIndexScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						filters := _root.Filters
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GeneratePartialIndexScans) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GeneratePartialIndexScans(_root, scanPrivate, filters)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GeneratePartialIndexScans, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateConstrainedScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						filters := _root.Filters
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateConstrainedScans) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateConstrainedScans(_root, scanPrivate, filters)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateConstrainedScans, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedIndexScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							filters := _root.Filters
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedIndexScans) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedIndexScans(_root, scanPrivate, filters)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedIndexScans, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateZigzagJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scan := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scan) {
						if !_e.funcs.IsLocking(scan) {
							filters := _root.Filters
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateZigzagJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateZigzagJoins(_root, scan, filters)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateZigzagJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedIndexZigzagJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scan := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scan) {
						if !_e.funcs.IsLocking(scan) {
							if _e.funcs.HasInvertedIndexes(scan) {
								filters := _root.Filters
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedIndexZigzagJoins) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateInvertedIndexZigzagJoins(_root, scan, filters)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateInvertedIndexZigzagJoins, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitDisjunction]
	{
		_partlyExplored := _rootOrd < _rootState.start
		input := _root.Input
		_state := _e.lookupExploreState(input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasStrictKey(_scan) {
							filters := _root.Filters
							leftFilter, rightFilter, itemToReplace, ok := _e.funcs.SplitDisjunction(scanPrivate, filters)
							if ok {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitDisjunction) {
									leftScan := _e.f.ConstructScan(
										_e.funcs.DuplicateScanPrivate(scanPrivate),
									)
									rightScan := _e.f.ConstructScan(
										_e.funcs.DuplicateScanPrivate(scanPrivate),
									)
									_expr := &memo.DistinctOnExpr{
										Input: _e.f.ConstructUnionAll(
											_e.f.ConstructSelect(
												leftScan,
												_e.funcs.MapFilterCols(_e.funcs.ReplaceFiltersItem(filters, itemToReplace, leftFilter), _e.funcs.OutputCols(_scan), _e.funcs.OutputCols(leftScan)),
											),
											_e.f.ConstructSelect(
												rightScan,
												_e.funcs.MapFilterCols(_e.funcs.ReplaceFiltersItem(filters, itemToReplace, rightFilter), _e.funcs.OutputCols(_scan), _e.funcs.OutputCols(rightScan)),
											),
											_e.funcs.MakeSetPrivate(_e.funcs.OutputCols(leftScan), _e.funcs.OutputCols(rightScan), _e.funcs.OutputCols(_scan)),
										),
										Aggregations:    _e.funcs.MakeAggCols(opt.ConstAggOp, _e.funcs.NonKeyCols(_scan)),
										GroupingPrivate: *_e.funcs.MakeGrouping(_e.funcs.KeyCols(_scan), _e.funcs.EmptyOrdering()),
									}
									_interned := _e.mem.AddDistinctOnToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.SplitDisjunction, _root, nil)
										} else {
											_e.o.appliedRule(opt.SplitDisjunction, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitDisjunctionAddKey]
	{
		_partlyExplored := _rootOrd < _rootState.start
		input := _root.Input
		_state := _e.lookupExploreState(input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if !_e.funcs.HasStrictKey(_scan) {
							filters := _root.Filters
							leftFilter, rightFilter, itemToReplace, ok := _e.funcs.SplitDisjunction(scanPrivate, filters)
							if ok {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitDisjunctionAddKey) {
									leftScan := _e.f.ConstructScan(
										_e.funcs.AddPrimaryKeyColsToScanPrivate(_e.funcs.DuplicateScanPrivate(scanPrivate)),
									)
									outCols := _e.funcs.UnionCols(_e.funcs.OutputCols(_scan), _e.funcs.PrimaryKeyCols(_e.funcs.TableIDFromScanPrivate(scanPrivate)))
									rightScan := _e.f.ConstructScan(
										_e.funcs.AddPrimaryKeyColsToScanPrivate(_e.funcs.DuplicateScanPrivate(scanPrivate)),
									)
									_expr := &memo.ProjectExpr{
										Input: _e.f.ConstructUnion(
											_e.f.ConstructSelect(
												leftScan,
												_e.funcs.MapFilterCols(_e.funcs.ReplaceFiltersItem(filters, itemToReplace, leftFilter), outCols, _e.funcs.OutputCols(leftScan)),
											),
											_e.f.ConstructSelect(
												rightScan,
												_e.funcs.MapFilterCols(_e.funcs.ReplaceFiltersItem(filters, itemToReplace, rightFilter), outCols, _e.funcs.OutputCols(rightScan)),
											),
											_e.funcs.MakeSetPrivate(_e.funcs.OutputCols(leftScan), _e.funcs.OutputCols(rightScan), outCols),
										),
										Projections: memo.EmptyProjectionsExpr,
										Passthrough: _e.funcs.OutputCols(_scan),
									}
									_interned := _e.mem.AddProjectToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.SplitDisjunctionAddKey, _root, nil)
										} else {
											_e.o.appliedRule(opt.SplitDisjunctionAddKey, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreProject(
	_rootState *exploreState,
	_root *memo.ProjectExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [EliminateIndexJoinInsideProject]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					input := _indexJoin.Input
					projections := _root.Projections
					passthrough := _root.Passthrough
					if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(_e.funcs.ProjectionOuterCols(projections), passthrough), _e.funcs.OutputCols(input)) {
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinInsideProject) {
							_expr := &memo.ProjectExpr{
								Input:       input,
								Projections: projections,
								Passthrough: passthrough,
							}
							_interned := _e.mem.AddProjectToGroup(_expr, _root)
							if _e.o.appliedRule != nil {
								if _interned != _expr {
									_e.o.appliedRule(opt.EliminateIndexJoinInsideProject, _root, nil)
								} else {
									_e.o.appliedRule(opt.EliminateIndexJoinInsideProject, _root, _interned)
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreInnerJoin(
	_rootState *exploreState,
	_root *memo.InnerJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.InnerJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, opt.InnerJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							on := _root.On
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedJoins(_root, opt.InnerJoinOp, left, scanPrivate, on, private)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoinsFromSelect]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								if _e.funcs.HasInvertedIndexes(scanPrivate) {
									filters := _select.Filters
									on := _root.On
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoinsFromSelect) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateInvertedJoins(_root, opt.InnerJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateInvertedJoinsFromSelect, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, opt.InnerJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualCols]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								virtualCols := _e.funcs.VirtualColumns(scanPrivate)
								if !_e.funcs.ColsAreEmpty(virtualCols) {
									projections := _project.Projections
									projectedVirtualCols := _e.funcs.ProjectionCols(projections)
									if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
										on := _root.On
										private := &_root.JoinPrivate
										if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualCols) {
											var _last memo.RelExpr
											if _e.o.appliedRule != nil {
												_last = memo.LastGroupMember(_root)
											}
											_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, opt.InnerJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, on, private)
											if _e.o.appliedRule != nil {
												_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualCols, _root, _last.NextExpr())
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithVirtualColsAndFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		project := _root.Right
		_state := _e.lookupExploreState(project)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = project.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_project, _ := _member.(*memo.ProjectExpr)
			if _project != nil {
				_state := _e.lookupExploreState(_project.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _project.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					_partlyExplored := _partlyExplored && _ord < _state.start
					_select, _ := _member.(*memo.SelectExpr)
					if _select != nil {
						_state := _e.lookupExploreState(_select.Input)
						if !_state.fullyExplored {
							_fullyExplored = false
						}
						var _member memo.RelExpr
						for _ord := 0; _ord < _state.end; _ord++ {
							if _member == nil {
								_member = _select.Input.FirstExpr()
							} else {
								_member = _member.NextExpr()
							}
							if !_partlyExplored || _ord >= _state.start {
								_scan, _ := _member.(*memo.ScanExpr)
								if _scan != nil {
									scanPrivate := &_scan.ScanPrivate
									if _e.funcs.IsCanonicalScan(scanPrivate) {
										virtualCols := _e.funcs.VirtualColumns(scanPrivate)
										if !_e.funcs.ColsAreEmpty(virtualCols) {
											filters := _select.Filters
											projections := _project.Projections
											projectedVirtualCols := _e.funcs.ProjectionCols(projections)
											if _e.funcs.ColsAreSubset(projectedVirtualCols, virtualCols) {
												on := _root.On
												private := &_root.JoinPrivate
												if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter) {
													var _last memo.RelExpr
													if _e.o.appliedRule != nil {
														_last = memo.LastGroupMember(_root)
													}
													_e.funcs.GenerateLookupJoinsWithVirtualCols(_root, opt.InnerJoinOp, left, _e.funcs.OutputCols(_project), projectedVirtualCols, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
													if _e.o.appliedRule != nil {
														_e.o.appliedRule(opt.GenerateLookupJoinsWithVirtualColsAndFilter, _root, _last.NextExpr())
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushJoinIntoIndexJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(left)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = left.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					indexInput := _indexJoin.Input
					indexPrivate := &_indexJoin.IndexJoinPrivate
					right := _root.Right
					if !_e.funcs.HasOuterCols(right) {
						on := _root.On
						if _e.funcs.FiltersBoundBy(on, _e.funcs.OutputCols2(indexInput, right)) {
							joinPrivate := &_root.JoinPrivate
							if _e.funcs.NoJoinHints(joinPrivate) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushJoinIntoIndexJoin) {
									_expr := &memo.LookupJoinExpr{
										Input: _e.f.ConstructInnerJoin(
											indexInput,
											right,
											on,
											joinPrivate,
										),
										On:                memo.EmptyFiltersExpr,
										LookupJoinPrivate: *_e.funcs.ConvertIndexToLookupJoinPrivate(indexPrivate, _e.funcs.OutputCols2(_indexJoin, right)),
									}
									_interned := _e.mem.AddLookupJoinToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.PushJoinIntoIndexJoin, _root, nil)
										} else {
											_e.o.appliedRule(opt.PushJoinIntoIndexJoin, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [HoistProjectFromInnerJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		proj := _root.Right
		_state := _e.lookupExploreState(proj)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = proj.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_project, _ := _member.(*memo.ProjectExpr)
				if _project != nil {
					right := _project.Input
					projections := _project.Projections
					if !_e.funcs.HasVolatileProjection(projections) {
						passthrough := _project.Passthrough
						on := _root.On
						if !_e.funcs.ColsIntersect(_e.funcs.ProjectionCols(projections), _e.funcs.FilterOuterCols(on)) {
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.HoistProjectFromInnerJoin) {
								_expr := &memo.ProjectExpr{
									Input: _e.f.ConstructInnerJoin(
										left,
										right,
										on,
										private,
									),
									Projections: projections,
									Passthrough: _e.funcs.UnionCols(passthrough, _e.funcs.OutputCols(left)),
								}
								_interned := _e.mem.AddProjectToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.HoistProjectFromInnerJoin, _root, nil)
									} else {
										_e.o.appliedRule(opt.HoistProjectFromInnerJoin, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreLeftJoin(
	_rootState *exploreState,
	_root *memo.LeftJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [CommuteLeftJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.CommuteLeftJoin) {
				_expr := &memo.RightJoinExpr{
					Left:        right,
					Right:       left,
					On:          on,
					JoinPrivate: *_e.funcs.CommuteJoinFlags(private),
				}
				_interned := _e.mem.AddRightJoinToGroup(_expr, _root)
				if _e.o.appliedRule != nil {
					if _interned != _expr {
						_e.o.appliedRule(opt.CommuteLeftJoin, _root, nil)
					} else {
						_e.o.appliedRule(opt.CommuteLeftJoin, _root, _interned)
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.LeftJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, opt.LeftJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							on := _root.On
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedJoins(_root, opt.LeftJoinOp, left, scanPrivate, on, private)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoinsFromSelect]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								if _e.funcs.HasInvertedIndexes(scanPrivate) {
									filters := _select.Filters
									on := _root.On
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoinsFromSelect) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateInvertedJoins(_root, opt.LeftJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateInvertedJoinsFromSelect, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, opt.LeftJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [HoistProjectFromLeftJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_project, _ := _member.(*memo.ProjectExpr)
				if _project != nil {
					right := _project.Input
					projections := _project.Projections
					if !_e.funcs.HasVolatileProjection(projections) {
						passthrough := _project.Passthrough
						on := _root.On
						if !_e.funcs.ColsIntersect(_e.funcs.ProjectionCols(projections), _e.funcs.FilterOuterCols(on)) {
							canaryCol := _e.funcs.FindLeftJoinCanaryColumn(right, on)
							if _e.funcs.FoundCanaryColumn(canaryCol) {
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.HoistProjectFromLeftJoin) {
									_expr := &memo.ProjectExpr{
										Input: _e.f.ConstructLeftJoin(
											left,
											right,
											on,
											private,
										),
										Projections: _e.funcs.MakeProjectionsForOuterJoin(canaryCol, projections),
										Passthrough: _e.funcs.UnionCols(passthrough, _e.funcs.OutputCols(left)),
									}
									_interned := _e.mem.AddProjectToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.HoistProjectFromLeftJoin, _root, nil)
										} else {
											_e.o.appliedRule(opt.HoistProjectFromLeftJoin, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreRightJoin(
	_rootState *exploreState,
	_root *memo.RightJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.RightJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreFullJoin(
	_rootState *exploreState,
	_root *memo.FullJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.FullJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreSemiJoin(
	_rootState *exploreState,
	_root *memo.SemiJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [CommuteSemiJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			if _e.funcs.IsSimpleEquality(on) {
				private := &_root.JoinPrivate
				if _e.funcs.NoJoinHints(private) {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.CommuteSemiJoin) {
						_expr := &memo.ProjectExpr{
							Input: _e.f.ConstructInnerJoin(
								left,
								_e.f.ConstructDistinctOn(
									right,
									memo.EmptyAggregationsExpr,
									_e.funcs.MakeGrouping(_e.funcs.IntersectionCols(_e.funcs.OutputCols(right), _e.funcs.FilterOuterCols(on)), _e.funcs.EmptyOrdering()),
								),
								on,
								private,
							),
							Projections: memo.EmptyProjectionsExpr,
							Passthrough: _e.funcs.OutputCols(left),
						}
						_interned := _e.mem.AddProjectToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.CommuteSemiJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.CommuteSemiJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [ConvertSemiToInnerJoin]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			if !_e.funcs.IsSimpleEquality(on) {
				private := &_root.JoinPrivate
				if _e.funcs.NoJoinHints(private) {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ConvertSemiToInnerJoin) {
						newLeft := _e.funcs.EnsureKey(left)
						_expr := &memo.ProjectExpr{
							Input: _e.f.ConstructDistinctOn(
								_e.f.ConstructInnerJoin(
									newLeft,
									right,
									on,
									private,
								),
								_e.funcs.MakeAggCols(opt.ConstAggOp, _e.funcs.NonKeyCols(newLeft)),
								_e.funcs.MakeGrouping(_e.funcs.KeyCols(newLeft), _e.funcs.EmptyOrdering()),
							),
							Projections: memo.EmptyProjectionsExpr,
							Passthrough: _e.funcs.OutputCols(left),
						}
						_interned := _e.mem.AddProjectToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.ConvertSemiToInnerJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.ConvertSemiToInnerJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.SemiJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, opt.SemiJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							on := _root.On
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedJoins(_root, opt.SemiJoinOp, left, scanPrivate, on, private)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoinsFromSelect]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								if _e.funcs.HasInvertedIndexes(scanPrivate) {
									filters := _select.Filters
									on := _root.On
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoinsFromSelect) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateInvertedJoins(_root, opt.SemiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateInvertedJoinsFromSelect, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, opt.SemiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreAntiJoin(
	_rootState *exploreState,
	_root *memo.AntiJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReorderJoins]
	{
		if _rootOrd >= _rootState.start {
			if _e.funcs.ShouldReorderJoins(_root) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReorderJoins) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.ReorderJoins(_root)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.ReorderJoins, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [GenerateMergeJoins]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			on := _root.On
			private := &_root.JoinPrivate
			if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateMergeJoins) {
				var _last memo.RelExpr
				if _e.o.appliedRule != nil {
					_last = memo.LastGroupMember(_root)
				}
				_e.funcs.GenerateMergeJoins(_root, opt.AntiJoinOp, left, right, on, private)
				if _e.o.appliedRule != nil {
					_e.o.appliedRule(opt.GenerateMergeJoins, _root, _last.NextExpr())
				}
			}
		}
	}

	// [GenerateLookupJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						on := _root.On
						private := &_root.JoinPrivate
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoins) {
							var _last memo.RelExpr
							if _e.o.appliedRule != nil {
								_last = memo.LastGroupMember(_root)
							}
							_e.funcs.GenerateLookupJoins(_root, opt.AntiJoinOp, left, scanPrivate, on, private)
							if _e.o.appliedRule != nil {
								_e.o.appliedRule(opt.GenerateLookupJoins, _root, _last.NextExpr())
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoins]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						if _e.funcs.HasInvertedIndexes(scanPrivate) {
							on := _root.On
							private := &_root.JoinPrivate
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoins) {
								var _last memo.RelExpr
								if _e.o.appliedRule != nil {
									_last = memo.LastGroupMember(_root)
								}
								_e.funcs.GenerateInvertedJoins(_root, opt.AntiJoinOp, left, scanPrivate, on, private)
								if _e.o.appliedRule != nil {
									_e.o.appliedRule(opt.GenerateInvertedJoins, _root, _last.NextExpr())
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateInvertedJoinsFromSelect]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								if _e.funcs.HasInvertedIndexes(scanPrivate) {
									filters := _select.Filters
									on := _root.On
									private := &_root.JoinPrivate
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateInvertedJoinsFromSelect) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.GenerateInvertedJoins(_root, opt.AntiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.GenerateInvertedJoinsFromSelect, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLookupJoinsWithFilter]
	{
		_partlyExplored := _rootOrd < _rootState.start
		left := _root.Left
		_state := _e.lookupExploreState(_root.Right)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Right.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				_state := _e.lookupExploreState(_select.Input)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = _select.Input.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if _e.funcs.IsCanonicalScan(scanPrivate) {
								filters := _select.Filters
								on := _root.On
								private := &_root.JoinPrivate
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLookupJoinsWithFilter) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLookupJoins(_root, opt.AntiJoinOp, left, scanPrivate, _e.funcs.ConcatFilters(on, filters), private)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLookupJoinsWithFilter, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreLookupJoin(
	_rootState *exploreState,
	_root *memo.LookupJoinExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateLocalityOptimizedAntiJoin]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			on := _root.On
			private := &_root.LookupJoinPrivate
			if _e.funcs.IsAntiJoin(private) {
				localExpr, remoteExpr, ok := _e.funcs.GetLocalityOptimizedLookupJoinExprs(on, private)
				if ok {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLocalityOptimizedAntiJoin) {
						_expr := &memo.LookupJoinExpr{
							Input: _e.f.ConstructLookupJoin(
								input,
								on,
								_e.funcs.CreateLocalityOptimizedLookupJoinPrivate(localExpr, _e.funcs.EmptyFiltersExpr(), private),
							),
							On:                on,
							LookupJoinPrivate: *_e.funcs.CreateLocalityOptimizedLookupJoinPrivate(remoteExpr, _e.funcs.EmptyFiltersExpr(), private),
						}
						_interned := _e.mem.AddLookupJoinToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.GenerateLocalityOptimizedAntiJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.GenerateLocalityOptimizedAntiJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	// [GenerateLocalityOptimizedLookupJoin]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			on := _root.On
			private := &_root.LookupJoinPrivate
			if !_e.funcs.IsAntiJoin(private) {
				localExpr, remoteExpr, ok := _e.funcs.GetLocalityOptimizedLookupJoinExprs(on, private)
				if ok {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLocalityOptimizedLookupJoin) {
						_expr := &memo.LookupJoinExpr{
							Input:             input,
							On:                on,
							LookupJoinPrivate: *_e.funcs.CreateLocalityOptimizedLookupJoinPrivate(localExpr, remoteExpr, private),
						}
						_interned := _e.mem.AddLookupJoinToGroup(_expr, _root)
						if _e.o.appliedRule != nil {
							if _interned != _expr {
								_e.o.appliedRule(opt.GenerateLocalityOptimizedLookupJoin, _root, nil)
							} else {
								_e.o.appliedRule(opt.GenerateLocalityOptimizedLookupJoin, _root, _interned)
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreGroupBy(
	_rootState *exploreState,
	_root *memo.GroupByExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReplaceMinWithLimit]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggregations := _root.Aggregations
			for i := range aggregations {
				item := &aggregations[i]
				_min, _ := item.Agg.(*memo.MinExpr)
				if _min != nil {
					variable := _min.Input
					_variable, _ := variable.(*memo.VariableExpr)
					if _variable != nil {
						col := _variable.Col
						if _e.funcs.IsColNotNull(col, input) {
							if _e.funcs.OtherAggsAreConst(aggregations, item) {
								groupingPrivate := &_root.GroupingPrivate
								if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
									if _e.funcs.ColsAreConst(_e.funcs.GroupingCols(groupingPrivate), input) {
										if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceMinWithLimit) {
											var _last memo.RelExpr
											if _e.o.appliedRule != nil {
												_last = memo.LastGroupMember(_root)
											}
											_e.funcs.MakeProjectFromPassthroughAggs(_root, _e.f.ConstructLimit(
												input,
												_e.funcs.IntConst(tree.NewDInt(1)),
												_e.funcs.MakeOrderingChoiceFromColumn(opt.MinOp, col),
											), aggregations)
											if _e.o.appliedRule != nil {
												_e.o.appliedRule(opt.ReplaceMinWithLimit, _root, _last.NextExpr())
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ReplaceMaxWithLimit]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggregations := _root.Aggregations
			for i := range aggregations {
				item := &aggregations[i]
				_max, _ := item.Agg.(*memo.MaxExpr)
				if _max != nil {
					variable := _max.Input
					_variable, _ := variable.(*memo.VariableExpr)
					if _variable != nil {
						col := _variable.Col
						if _e.funcs.OtherAggsAreConst(aggregations, item) {
							groupingPrivate := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
								if _e.funcs.ColsAreConst(_e.funcs.GroupingCols(groupingPrivate), input) {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceMaxWithLimit) {
										var _last memo.RelExpr
										if _e.o.appliedRule != nil {
											_last = memo.LastGroupMember(_root)
										}
										_e.funcs.MakeProjectFromPassthroughAggs(_root, _e.f.ConstructLimit(
											input,
											_e.funcs.IntConst(tree.NewDInt(1)),
											_e.funcs.MakeOrderingChoiceFromColumn(opt.MaxOp, col),
										), aggregations)
										if _e.o.appliedRule != nil {
											_e.o.appliedRule(opt.ReplaceMaxWithLimit, _root, _last.NextExpr())
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.GroupByOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [SplitGroupByScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if !_e.funcs.ScanIsLimited(scanPrivate) {
						if !_e.funcs.ScanIsInverted(scanPrivate) {
							aggs := _root.Aggregations
							private := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(private) {
								unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
								if ok {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByScanIntoUnionScans) {
										_expr := &memo.GroupByExpr{
											Input:           unionScans,
											Aggregations:    aggs,
											GroupingPrivate: *private,
										}
										_interned := _e.mem.AddGroupByToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, nil)
											} else {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitGroupByFilteredScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				scan := _select.Input
				_state := _e.lookupExploreState(scan)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = scan.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if !_e.funcs.ScanIsLimited(scanPrivate) {
								if !_e.funcs.ScanIsInverted(scanPrivate) {
									filters := _select.Filters
									aggs := _root.Aggregations
									private := &_root.GroupingPrivate
									if _e.funcs.IsCanonicalGroupBy(private) {
										unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
										if ok {
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByFilteredScanIntoUnionScans) {
												_expr := &memo.GroupByExpr{
													Input: _e.f.ConstructSelect(
														unionScans,
														filters,
													),
													Aggregations:    aggs,
													GroupingPrivate: *private,
												}
												_interned := _e.mem.AddGroupByToGroup(_expr, _root)
												if _e.o.appliedRule != nil {
													if _interned != _expr {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, nil)
													} else {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, _interned)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [EliminateIndexJoinOrProjectInsideGroupBy]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				if _member.Op() == opt.IndexJoinOp || _member.Op() == opt.ProjectOp {
					input := _member.Child(0).(memo.RelExpr)
					aggs := _root.Aggregations
					private := &_root.GroupingPrivate
					ordering := _e.funcs.GroupingOrdering(private)
					inputCols := _e.funcs.OutputCols(input)
					if _e.funcs.OrderingCanProjectCols(ordering, inputCols) {
						groupingCols := _e.funcs.GroupingColumns(private)
						if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(groupingCols, _e.funcs.AggregationOuterCols(aggs)), inputCols) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy) {
								_expr := &memo.GroupByExpr{
									Input:           input,
									Aggregations:    aggs,
									GroupingPrivate: *_e.funcs.MakeGroupingPrivate(groupingCols, _e.funcs.PruneOrdering(ordering, inputCols), _e.funcs.NullsAreDistinct(private), _e.funcs.ErrorOnDup(private)),
								}
								_interned := _e.mem.AddGroupByToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, nil)
									} else {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreScalarGroupBy(
	_rootState *exploreState,
	_root *memo.ScalarGroupByExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [ReplaceScalarMinMaxWithLimit]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			if len(_root.Aggregations) == 1 {
				_item := &_root.Aggregations[0]
				agg := _item.Agg
				if agg.Op() == opt.MinOp || agg.Op() == opt.MaxOp {
					variable := agg.Child(0).(opt.ScalarExpr)
					_variable, _ := variable.(*memo.VariableExpr)
					if _variable != nil {
						col := _variable.Col
						aggPrivate := _item.Col
						groupingPrivate := &_root.GroupingPrivate
						if _e.funcs.IsCanonicalGroupBy(groupingPrivate) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ReplaceScalarMinMaxWithLimit) {
								_expr := &memo.ScalarGroupByExpr{
									Input: _e.f.ConstructLimit(
										_e.f.ConstructSelect(
											input,
											memo.FiltersExpr{
												_e.f.ConstructFiltersItem(
													_e.f.ConstructIsNot(
														_variable,
														_e.f.ConstructNull(
															_e.funcs.AnyType(),
														),
													),
												),
											},
										),
										_e.funcs.IntConst(tree.NewDInt(1)),
										_e.funcs.MakeOrderingChoiceFromColumn(agg.Op(), col),
									),
									Aggregations: memo.AggregationsExpr{
										_e.f.ConstructAggregationsItem(
											_e.f.ConstructConstAgg(
												_variable,
											),
											aggPrivate,
										),
									},
									GroupingPrivate: *groupingPrivate,
								}
								_interned := _e.mem.AddScalarGroupByToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.ReplaceScalarMinMaxWithLimit, _root, nil)
									} else {
										_e.o.appliedRule(opt.ReplaceScalarMinMaxWithLimit, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [EliminateIndexJoinOrProjectInsideGroupBy]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				if _member.Op() == opt.IndexJoinOp || _member.Op() == opt.ProjectOp {
					input := _member.Child(0).(memo.RelExpr)
					aggs := _root.Aggregations
					private := &_root.GroupingPrivate
					ordering := _e.funcs.GroupingOrdering(private)
					inputCols := _e.funcs.OutputCols(input)
					if _e.funcs.OrderingCanProjectCols(ordering, inputCols) {
						groupingCols := _e.funcs.GroupingColumns(private)
						if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(groupingCols, _e.funcs.AggregationOuterCols(aggs)), inputCols) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy) {
								_expr := &memo.ScalarGroupByExpr{
									Input:           input,
									Aggregations:    aggs,
									GroupingPrivate: *_e.funcs.MakeGroupingPrivate(groupingCols, _e.funcs.PruneOrdering(ordering, inputCols), _e.funcs.NullsAreDistinct(private), _e.funcs.ErrorOnDup(private)),
								}
								_interned := _e.mem.AddScalarGroupByToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, nil)
									} else {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreDistinctOn(
	_rootState *exploreState,
	_root *memo.DistinctOnExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.DistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [SplitGroupByScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if !_e.funcs.ScanIsLimited(scanPrivate) {
						if !_e.funcs.ScanIsInverted(scanPrivate) {
							aggs := _root.Aggregations
							private := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(private) {
								unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
								if ok {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByScanIntoUnionScans) {
										_expr := &memo.DistinctOnExpr{
											Input:           unionScans,
											Aggregations:    aggs,
											GroupingPrivate: *private,
										}
										_interned := _e.mem.AddDistinctOnToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, nil)
											} else {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitGroupByFilteredScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				scan := _select.Input
				_state := _e.lookupExploreState(scan)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = scan.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if !_e.funcs.ScanIsLimited(scanPrivate) {
								if !_e.funcs.ScanIsInverted(scanPrivate) {
									filters := _select.Filters
									aggs := _root.Aggregations
									private := &_root.GroupingPrivate
									if _e.funcs.IsCanonicalGroupBy(private) {
										unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
										if ok {
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByFilteredScanIntoUnionScans) {
												_expr := &memo.DistinctOnExpr{
													Input: _e.f.ConstructSelect(
														unionScans,
														filters,
													),
													Aggregations:    aggs,
													GroupingPrivate: *private,
												}
												_interned := _e.mem.AddDistinctOnToGroup(_expr, _root)
												if _e.o.appliedRule != nil {
													if _interned != _expr {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, nil)
													} else {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, _interned)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [EliminateIndexJoinOrProjectInsideGroupBy]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				if _member.Op() == opt.IndexJoinOp || _member.Op() == opt.ProjectOp {
					input := _member.Child(0).(memo.RelExpr)
					aggs := _root.Aggregations
					private := &_root.GroupingPrivate
					ordering := _e.funcs.GroupingOrdering(private)
					inputCols := _e.funcs.OutputCols(input)
					if _e.funcs.OrderingCanProjectCols(ordering, inputCols) {
						groupingCols := _e.funcs.GroupingColumns(private)
						if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(groupingCols, _e.funcs.AggregationOuterCols(aggs)), inputCols) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy) {
								_expr := &memo.DistinctOnExpr{
									Input:           input,
									Aggregations:    aggs,
									GroupingPrivate: *_e.funcs.MakeGroupingPrivate(groupingCols, _e.funcs.PruneOrdering(ordering, inputCols), _e.funcs.NullsAreDistinct(private), _e.funcs.ErrorOnDup(private)),
								}
								_interned := _e.mem.AddDistinctOnToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, nil)
									} else {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreEnsureDistinctOn(
	_rootState *exploreState,
	_root *memo.EnsureDistinctOnExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.EnsureDistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreUpsertDistinctOn(
	_rootState *exploreState,
	_root *memo.UpsertDistinctOnExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.UpsertDistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreEnsureUpsertDistinctOn(
	_rootState *exploreState,
	_root *memo.EnsureUpsertDistinctOnExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingGroupBy]
	{
		if _rootOrd >= _rootState.start {
			input := _root.Input
			aggs := _root.Aggregations
			private := &_root.GroupingPrivate
			if _e.funcs.IsCanonicalGroupBy(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingGroupBy) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingGroupBy(_root, opt.EnsureUpsertDistinctOnOp, input, aggs, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingGroupBy, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	// [SplitGroupByScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if !_e.funcs.ScanIsLimited(scanPrivate) {
						if !_e.funcs.ScanIsInverted(scanPrivate) {
							aggs := _root.Aggregations
							private := &_root.GroupingPrivate
							if _e.funcs.IsCanonicalGroupBy(private) {
								unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
								if ok {
									if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByScanIntoUnionScans) {
										_expr := &memo.EnsureUpsertDistinctOnExpr{
											Input:           unionScans,
											Aggregations:    aggs,
											GroupingPrivate: *private,
										}
										_interned := _e.mem.AddEnsureUpsertDistinctOnToGroup(_expr, _root)
										if _e.o.appliedRule != nil {
											if _interned != _expr {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, nil)
											} else {
												_e.o.appliedRule(opt.SplitGroupByScanIntoUnionScans, _root, _interned)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitGroupByFilteredScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			_partlyExplored := _partlyExplored && _ord < _state.start
			_select, _ := _member.(*memo.SelectExpr)
			if _select != nil {
				scan := _select.Input
				_state := _e.lookupExploreState(scan)
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				var _member memo.RelExpr
				for _ord := 0; _ord < _state.end; _ord++ {
					if _member == nil {
						_member = scan.FirstExpr()
					} else {
						_member = _member.NextExpr()
					}
					if !_partlyExplored || _ord >= _state.start {
						_scan, _ := _member.(*memo.ScanExpr)
						if _scan != nil {
							scanPrivate := &_scan.ScanPrivate
							if !_e.funcs.ScanIsLimited(scanPrivate) {
								if !_e.funcs.ScanIsInverted(scanPrivate) {
									filters := _select.Filters
									aggs := _root.Aggregations
									private := &_root.GroupingPrivate
									if _e.funcs.IsCanonicalGroupBy(private) {
										unionScans, ok := _e.funcs.SplitGroupByScanIntoUnionScans(_scan, scanPrivate, private)
										if ok {
											if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitGroupByFilteredScanIntoUnionScans) {
												_expr := &memo.EnsureUpsertDistinctOnExpr{
													Input: _e.f.ConstructSelect(
														unionScans,
														filters,
													),
													Aggregations:    aggs,
													GroupingPrivate: *private,
												}
												_interned := _e.mem.AddEnsureUpsertDistinctOnToGroup(_expr, _root)
												if _e.o.appliedRule != nil {
													if _interned != _expr {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, nil)
													} else {
														_e.o.appliedRule(opt.SplitGroupByFilteredScanIntoUnionScans, _root, _interned)
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [EliminateIndexJoinOrProjectInsideGroupBy]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				if _member.Op() == opt.IndexJoinOp || _member.Op() == opt.ProjectOp {
					input := _member.Child(0).(memo.RelExpr)
					aggs := _root.Aggregations
					private := &_root.GroupingPrivate
					ordering := _e.funcs.GroupingOrdering(private)
					inputCols := _e.funcs.OutputCols(input)
					if _e.funcs.OrderingCanProjectCols(ordering, inputCols) {
						groupingCols := _e.funcs.GroupingColumns(private)
						if _e.funcs.ColsAreSubset(_e.funcs.UnionCols(groupingCols, _e.funcs.AggregationOuterCols(aggs)), inputCols) {
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy) {
								_expr := &memo.EnsureUpsertDistinctOnExpr{
									Input:           input,
									Aggregations:    aggs,
									GroupingPrivate: *_e.funcs.MakeGroupingPrivate(groupingCols, _e.funcs.PruneOrdering(ordering, inputCols), _e.funcs.NullsAreDistinct(private), _e.funcs.ErrorOnDup(private)),
								}
								_interned := _e.mem.AddEnsureUpsertDistinctOnToGroup(_expr, _root)
								if _e.o.appliedRule != nil {
									if _interned != _expr {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, nil)
									} else {
										_e.o.appliedRule(opt.EliminateIndexJoinOrProjectInsideGroupBy, _root, _interned)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreUnion(
	_rootState *exploreState,
	_root *memo.UnionExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, opt.UnionOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreIntersect(
	_rootState *exploreState,
	_root *memo.IntersectExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, opt.IntersectOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreExcept(
	_rootState *exploreState,
	_root *memo.ExceptExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, opt.ExceptOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreIntersectAll(
	_rootState *exploreState,
	_root *memo.IntersectAllExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, opt.IntersectAllOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreExceptAll(
	_rootState *exploreState,
	_root *memo.ExceptAllExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateStreamingSetOp]
	{
		if _rootOrd >= _rootState.start {
			left := _root.Left
			right := _root.Right
			private := &_root.SetPrivate
			if _e.funcs.IsCanonicalSetOp(private) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateStreamingSetOp) {
					var _last memo.RelExpr
					if _e.o.appliedRule != nil {
						_last = memo.LastGroupMember(_root)
					}
					_e.funcs.GenerateStreamingSetOp(_root, opt.ExceptAllOp, left, right, private)
					if _e.o.appliedRule != nil {
						_e.o.appliedRule(opt.GenerateStreamingSetOp, _root, _last.NextExpr())
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreLimit(
	_rootState *exploreState,
	_root *memo.LimitExpr,
	_rootOrd int,
) (_fullyExplored bool) {
	_fullyExplored = true

	// [GenerateLimitedScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if _e.funcs.IsCanonicalScan(scanPrivate) {
						_const, _ := _root.Limit.(*memo.ConstExpr)
						if _const != nil {
							limit := _const.Value
							if _e.funcs.IsPositiveInt(limit) {
								ordering := _root.Ordering
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateLimitedScans) {
									var _last memo.RelExpr
									if _e.o.appliedRule != nil {
										_last = memo.LastGroupMember(_root)
									}
									_e.funcs.GenerateLimitedScans(_root, scanPrivate, limit, ordering)
									if _e.o.appliedRule != nil {
										_e.o.appliedRule(opt.GenerateLimitedScans, _root, _last.NextExpr())
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoFilteredScan]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					_const, _ := _root.Limit.(*memo.ConstExpr)
					if _const != nil {
						limit := _const.Value
						if _e.funcs.IsPositiveInt(limit) {
							ordering := _root.Ordering
							if _e.funcs.CanLimitFilteredScan(scanPrivate, ordering) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushLimitIntoFilteredScan) {
									_expr := &memo.ScanExpr{
										ScanPrivate: *_e.funcs.LimitScanPrivate(scanPrivate, limit, ordering),
									}
									_interned := _e.mem.AddScanToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.PushLimitIntoFilteredScan, _root, nil)
										} else {
											_e.o.appliedRule(opt.PushLimitIntoFilteredScan, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoIndexJoin]
	{
		_partlyExplored := _rootOrd < _rootState.start
		_state := _e.lookupExploreState(_root.Input)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = _root.Input.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_indexJoin, _ := _member.(*memo.IndexJoinExpr)
				if _indexJoin != nil {
					input := _indexJoin.Input
					indexJoinPrivate := &_indexJoin.IndexJoinPrivate
					limitExpr := _root.Limit
					_const, _ := limitExpr.(*memo.ConstExpr)
					if _const != nil {
						limit := _const.Value
						if _e.funcs.IsPositiveInt(limit) {
							ordering := _root.Ordering
							cols := _e.funcs.OutputCols(input)
							if _e.funcs.OrderingCanProjectCols(ordering, cols) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushLimitIntoIndexJoin) {
									_expr := &memo.IndexJoinExpr{
										Input: _e.f.ConstructLimit(
											input,
											_const,
											_e.funcs.PruneOrdering(ordering, cols),
										),
										IndexJoinPrivate: *indexJoinPrivate,
									}
									_interned := _e.mem.AddIndexJoinToGroup(_expr, _root)
									if _e.o.appliedRule != nil {
										if _interned != _expr {
											_e.o.appliedRule(opt.PushLimitIntoIndexJoin, _root, nil)
										} else {
											_e.o.appliedRule(opt.PushLimitIntoIndexJoin, _root, _interned)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SplitLimitedScanIntoUnionScans]
	{
		_partlyExplored := _rootOrd < _rootState.start
		scan := _root.Input
		_state := _e.lookupExploreState(scan)
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		var _member memo.RelExpr
		for _ord := 0; _ord < _state.end; _ord++ {
			if _member == nil {
				_member = scan.FirstExpr()
			} else {
				_member = _member.NextExpr()
			}
			if !_partlyExplored || _ord >= _state.start {
				_scan, _ := _member.(*memo.ScanExpr)
				if _scan != nil {
					scanPrivate := &_scan.ScanPrivate
					if !_e.funcs.ScanIsLimited(scanPrivate) {
						if !_e.funcs.ScanIsInverted(scanPrivate) {
							limitExpr := _root.Limit
							_const, _ := limitExpr.(*memo.ConstExpr)
							if _const != nil {
								limit := _const.Value
								if _e.funcs.IsPositiveInt(limit) {
									ordering := _root.Ordering
									unionScans, ok := _e.funcs.SplitLimitedScanIntoUnionScans(ordering, _scan, scanPrivate, limit)
									if ok {
										if _e.o.matchedRule == nil || _e.o.matchedRule(opt.SplitLimitedScanIntoUnionScans) {
											_expr := &memo.LimitExpr{
												Input:    unionScans,
												Limit:    _const,
												Ordering: ordering,
											}
											_interned := _e.mem.AddLimitToGroup(_expr, _root)
											if _e.o.appliedRule != nil {
												if _interned != _expr {
													_e.o.appliedRule(opt.SplitLimitedScanIntoUnionScans, _root, nil)
												} else {
													_e.o.appliedRule(opt.SplitLimitedScanIntoUnionScans, _root, _interned)
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}
