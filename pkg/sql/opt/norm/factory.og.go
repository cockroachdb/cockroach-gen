// Code generated by optgen; DO NOT EDIT.

package norm

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/props"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/errors"
)

// ConstructNormCycleTestRel constructs an expression for the NormCycleTestRel operator.
// NormCycleTestRel is a relational operator for testing that normalization rule
// cycles are detected by the Factory and a stack overflow is prevented. Two
// rules for this expression, NormCycleTestRelTrueToFalse and
// NormCycleTestRelFalseToTrue, create a normalization rule cycle. See the cycle
// test file for tests that use this expression.
func (_f *Factory) ConstructNormCycleTestRel(
	scalar opt.ScalarExpr,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [NormCycleTestRelTrueToFalse]
	{
		_true, _ := scalar.(*memo.TrueExpr)
		if _true != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.NormCycleTestRelTrueToFalse) {
				_expr := _f.ConstructNormCycleTestRel(
					_f.ConstructFalse(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.NormCycleTestRelTrueToFalse, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [NormCycleTestRelFalseToTrue]
	{
		_false, _ := scalar.(*memo.FalseExpr)
		if _false != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.NormCycleTestRelFalseToTrue) {
				_expr := _f.ConstructNormCycleTestRel(
					_f.ConstructTrue(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.NormCycleTestRelFalseToTrue, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeNormCycleTestRel(scalar)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructMemoCycleTestRel constructs an expression for the MemoCycleTestRel operator.
// MemoCycleTestRel is a relational expression for testing that memo cycles are
// detected by the optimizer and a stack overflow is prevented. A cycle in the
// memo occurs when there is a path from a group member's children back to the
// group member's group. MemoCycleTestRel is similar in structure to the Select
// expression, but matches a rule, MemoCycleTestRelRule, that creates a memo
// cycle.
func (_f *Factory) ConstructMemoCycleTestRel(
	input memo.RelExpr,
	filters memo.FiltersExpr,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeMemoCycleTestRel(input, filters)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructInsert constructs an expression for the Insert operator.
// Insert evaluates a relational input expression, and inserts values from it
// into a target table. The input may be an arbitrarily complex expression:
//
//	INSERT INTO ab SELECT x, y+1 FROM xy ORDER BY y
//
// It can also be a simple VALUES clause:
//
//	INSERT INTO ab VALUES (1, 2)
//
// It may also return rows, which can be further composed:
//
//	SELECT a + b FROM [INSERT INTO ab VALUES (1, 2) RETURNING a, b]
//
// The Insert operator is capable of inserting values into computed columns and
// mutation columns, which are not writable (or even visible in the case of
// mutation columns) by SQL users.
func (_f *Factory) ConstructInsert(
	input memo.RelExpr,
	uniqueChecks memo.UniqueChecksExpr,
	fKChecks memo.FKChecksExpr,
	mutationPrivate *memo.MutationPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [PruneMutationInputCols]
	{
		fkChecks := fKChecks
		needed := _f.funcs.NeededMutationCols(mutationPrivate, uniqueChecks, fkChecks)
		if _f.funcs.CanPruneCols(input, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneMutationInputCols) {
				_expr := _f.ConstructInsert(
					_f.funcs.PruneCols(input, needed),
					uniqueChecks,
					fkChecks,
					mutationPrivate,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneMutationInputCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeInsert(input, uniqueChecks, fKChecks, mutationPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUpdate constructs an expression for the Update operator.
// Update evaluates a relational input expression that fetches existing rows from
// a target table and computes new values for one or more columns. Arbitrary
// subsets of rows can be selected from the target table and processed in order,
// as with this example:
//
//	UPDATE abc SET b=10 WHERE a>0 ORDER BY b+c LIMIT 10
//
// The Update operator will also update any computed columns, including mutation
// columns that are computed.
func (_f *Factory) ConstructUpdate(
	input memo.RelExpr,
	uniqueChecks memo.UniqueChecksExpr,
	fKChecks memo.FKChecksExpr,
	mutationPrivate *memo.MutationPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyPartialIndexProjections]
	{
		project := input
		_project, _ := project.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			passthrough := _project.Passthrough
			fkChecks := fKChecks
			simplifiableCols := _f.funcs.SimplifiablePartialIndexProjectCols(mutationPrivate, uniqueChecks, fkChecks, projections)
			if !_f.funcs.ColsAreEmpty(simplifiableCols) {
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyPartialIndexProjections) {
					_expr := _f.ConstructUpdate(
						_f.ConstructProject(
							input,
							_f.funcs.SimplifyPartialIndexProjections(projections, simplifiableCols),
							passthrough,
						),
						uniqueChecks,
						fkChecks,
						mutationPrivate,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyPartialIndexProjections, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneMutationFetchCols]
	{
		fkChecks := fKChecks
		needed := _f.funcs.NeededMutationFetchCols(opt.UpdateOp, mutationPrivate)
		if _f.funcs.CanPruneMutationFetchCols(mutationPrivate, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneMutationFetchCols) {
				_expr := _f.ConstructUpdate(
					input,
					uniqueChecks,
					fkChecks,
					_f.funcs.PruneMutationFetchCols(mutationPrivate, needed),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneMutationFetchCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PruneMutationInputCols]
	{
		fkChecks := fKChecks
		needed := _f.funcs.NeededMutationCols(mutationPrivate, uniqueChecks, fkChecks)
		if _f.funcs.CanPruneCols(input, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneMutationInputCols) {
				_expr := _f.ConstructUpdate(
					_f.funcs.PruneCols(input, needed),
					uniqueChecks,
					fkChecks,
					mutationPrivate,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneMutationInputCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUpdate(input, uniqueChecks, fKChecks, mutationPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUpsert constructs an expression for the Upsert operator.
// Upsert evaluates a relational input expression that tries to insert a new row
// into a target table. If a conflicting row already exists, then Upsert will
// instead update the existing row. The Upsert operator is used for all of these
// syntactic variants:
//
//	INSERT..ON CONFLICT DO UPDATE
//	  INSERT INTO abc VALUES (1, 2, 3) ON CONFLICT (a) DO UPDATE SET b=10
//
//	INSERT..ON CONFLICT DO NOTHING
//	  INSERT INTO abc VALUES (1, 2, 3) ON CONFLICT DO NOTHING
//
//	UPSERT
//	  UPSERT INTO abc VALUES (1, 2, 3)
//
// The Update operator will also insert/update any computed columns, including
// mutation columns that are computed.
func (_f *Factory) ConstructUpsert(
	input memo.RelExpr,
	uniqueChecks memo.UniqueChecksExpr,
	fKChecks memo.FKChecksExpr,
	mutationPrivate *memo.MutationPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [PruneMutationFetchCols]
	{
		fkChecks := fKChecks
		needed := _f.funcs.NeededMutationFetchCols(opt.UpsertOp, mutationPrivate)
		if _f.funcs.CanPruneMutationFetchCols(mutationPrivate, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneMutationFetchCols) {
				_expr := _f.ConstructUpsert(
					input,
					uniqueChecks,
					fkChecks,
					_f.funcs.PruneMutationFetchCols(mutationPrivate, needed),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneMutationFetchCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PruneMutationInputCols]
	{
		fkChecks := fKChecks
		needed := _f.funcs.NeededMutationCols(mutationPrivate, uniqueChecks, fkChecks)
		if _f.funcs.CanPruneCols(input, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneMutationInputCols) {
				_expr := _f.ConstructUpsert(
					_f.funcs.PruneCols(input, needed),
					uniqueChecks,
					fkChecks,
					mutationPrivate,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneMutationInputCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUpsert(input, uniqueChecks, fKChecks, mutationPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructDelete constructs an expression for the Delete operator.
// Delete is an operator used to delete all rows that are selected by a
// relational input expression:
//
//	DELETE FROM abc WHERE a>0 ORDER BY b LIMIT 10
func (_f *Factory) ConstructDelete(
	input memo.RelExpr,
	uniqueChecks memo.UniqueChecksExpr,
	fKChecks memo.FKChecksExpr,
	mutationPrivate *memo.MutationPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [PruneMutationFetchCols]
	{
		fkChecks := fKChecks
		needed := _f.funcs.NeededMutationFetchCols(opt.DeleteOp, mutationPrivate)
		if _f.funcs.CanPruneMutationFetchCols(mutationPrivate, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneMutationFetchCols) {
				_expr := _f.ConstructDelete(
					input,
					uniqueChecks,
					fkChecks,
					_f.funcs.PruneMutationFetchCols(mutationPrivate, needed),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneMutationFetchCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PruneMutationInputCols]
	{
		fkChecks := fKChecks
		needed := _f.funcs.NeededMutationCols(mutationPrivate, uniqueChecks, fkChecks)
		if _f.funcs.CanPruneCols(input, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneMutationInputCols) {
				_expr := _f.ConstructDelete(
					_f.funcs.PruneCols(input, needed),
					uniqueChecks,
					fkChecks,
					mutationPrivate,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneMutationInputCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeDelete(input, uniqueChecks, fKChecks, mutationPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFKChecksItem constructs an expression for the FKChecksItem operator.
// FKChecksItem is a foreign key check query, to be run after the main query.
// An execution error will be generated if the query returns any results.
func (_f *Factory) ConstructFKChecksItem(
	check memo.RelExpr,
	fKChecksItemPrivate *memo.FKChecksItemPrivate,
) memo.FKChecksItem {
	item := memo.FKChecksItem{Check: check, FKChecksItemPrivate: *fKChecksItemPrivate}
	return item
}

// ConstructUniqueChecksItem constructs an expression for the UniqueChecksItem operator.
// UniqueChecksItem is a unique check query, to be run after the main query.
// An execution error will be generated if the query returns any results.
func (_f *Factory) ConstructUniqueChecksItem(
	check memo.RelExpr,
	uniqueChecksItemPrivate *memo.UniqueChecksItemPrivate,
) memo.UniqueChecksItem {
	item := memo.UniqueChecksItem{Check: check, UniqueChecksItemPrivate: *uniqueChecksItemPrivate}
	return item
}

// ConstructScan constructs an expression for the Scan operator.
// Scan returns a result set containing every row in a table by scanning one of
// the table's indexes according to its ordering. The ScanPrivate field
// identifies the table and index to scan, as well as the subset of columns to
// project from it.
//
// The scan can be constrained and/or have an internal row limit. A scan can be
// executed either as a forward or as a reverse scan (except when it has a limit,
// in which case the direction is fixed).
func (_f *Factory) ConstructScan(
	scanPrivate *memo.ScanPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeScan(scanPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructPlaceholderScan constructs an expression for the PlaceholderScan operator.
// PlaceholderScan is a special variant of Scan. It scans exactly one span of a
// non-inverted index, and the span has the same start and end key. The values
// for the span key are child scalar operators which are either constants or
// placeholders. This operator evaluates the placeholders at execbuild time.
//
// PlaceholderScan cannot have a Constraint or InvertedConstraint.
func (_f *Factory) ConstructPlaceholderScan(
	span memo.ScalarListExpr,
	scanPrivate *memo.ScanPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizePlaceholderScan(span, scanPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSequenceSelect constructs an expression for the SequenceSelect operator.
// SequenceSelect represents a read from a sequence as a data source. It always returns
// three columns, last_value, log_cnt, and is_called, with a single row. last_value is
// the most recent value returned from the sequence and log_cnt and is_called are
// always 0 and true, respectively.
func (_f *Factory) ConstructSequenceSelect(
	sequenceSelectPrivate *memo.SequenceSelectPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeSequenceSelect(sequenceSelectPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructValues constructs an expression for the Values operator.
// Values returns a manufactured result set containing a constant number of rows.
// specified by the Rows list field. Each row must contain the same set of
// columns in the same order.
//
// The Rows field contains a list of Tuples, one for each row. Each tuple has
// the same length (same with that of Cols).
//
// The Cols field contains the set of column indices returned by each row
// as an opt.ColList. It is legal for Cols to be empty.
func (_f *Factory) ConstructValues(
	rows memo.ScalarListExpr,
	valuesPrivate *memo.ValuesPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [HoistValuesSubquery]
	{
		for i := range rows {
			item := rows[i]
			if _f.funcs.HasHoistableSubquery(item) {
				private := valuesPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistValuesSubquery) {
					_expr := _f.funcs.HoistValuesSubquery(rows, private).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistValuesSubquery, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeValues(rows, valuesPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLiteralValues constructs an expression for the LiteralValues operator.
// LiteralValues is a version of values where the exprs have already been type checked
// and are real Datums that don't need evaluation.
func (_f *Factory) ConstructLiteralValues(
	rows *opt.LiteralRows,
	cols opt.ColList,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeLiteralValues(rows, cols)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSelect constructs an expression for the Select operator.
// Select filters rows from its input result set, based on the boolean filter
// predicate expression. Rows which do not match the filter are discarded. While
// the Filter operand can be any boolean expression, normalization rules will
// typically convert it to a Filters operator in order to make conjunction list
// matching easier.
func (_f *Factory) ConstructSelect(
	input memo.RelExpr,
	filters memo.FiltersExpr,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [InlineConstVar]
	{
		if _f.funcs.CanInlineConstVar(filters) {
			if _f.matchedRule == nil || _f.matchedRule(opt.InlineConstVar) {
				_expr := _f.ConstructSelect(
					input,
					_f.funcs.InlineConstVar(filters),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.InlineConstVar, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [RejectNullsLeftJoin]
	{
		if input.Op() == opt.LeftJoinOp || input.Op() == opt.LeftJoinApplyOp || input.Op() == opt.FullJoinOp {
			left := input.Child(0).(memo.RelExpr)
			right := input.Child(1).(memo.RelExpr)
			on := *input.Child(2).(*memo.FiltersExpr)
			private := input.Private().(*memo.JoinPrivate)
			if _f.funcs.HasNullRejectingFilter(filters, _f.funcs.OutputCols(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsLeftJoin) {
					_expr := _f.ConstructSelect(
						_f.funcs.ConstructNonLeftJoin(input.Op(), left, right, on, private),
						filters,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsLeftJoin, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [RejectNullsRightJoin]
	{
		_fullJoin, _ := input.(*memo.FullJoinExpr)
		if _fullJoin != nil {
			left := _fullJoin.Left
			right := _fullJoin.Right
			on := _fullJoin.On
			private := &_fullJoin.JoinPrivate
			if _f.funcs.HasNullRejectingFilter(filters, _f.funcs.OutputCols(left)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsRightJoin) {
					_expr := _f.ConstructSelect(
						_f.ConstructLeftJoin(
							left,
							right,
							on,
							private,
						),
						filters,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsRightJoin, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [SimplifySelectFilters]
	{
		for i := range filters {
			item := &filters[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsFilterFalse(filters) {
							if _f.matchedRule == nil || _f.matchedRule(opt.SimplifySelectFilters) {
								_expr := _f.ConstructSelect(
									input,
									_f.funcs.SimplifyFilters(filters),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.SimplifySelectFilters, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeSelectAnyFilter]
	{
		for i := range filters {
			item := &filters[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeSelectAnyFilter) {
					_expr := _f.ConstructSelect(
						input,
						_f.funcs.ReplaceFiltersItem(filters, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeSelectAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeSelectNotAnyFilter]
	{
		for i := range filters {
			item := &filters[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeSelectNotAnyFilter) {
						_expr := _f.ConstructSelect(
							input,
							_f.funcs.ReplaceFiltersItem(filters, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeSelectNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineSelectConstants]
	{
		constCols := _f.funcs.FindInlinableConstants(input)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range filters {
				item := &filters[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					if _f.matchedRule == nil || _f.matchedRule(opt.InlineSelectConstants) {
						_expr := _f.ConstructSelect(
							input,
							_f.funcs.InlineFilterConstants(filters, input, constCols),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.InlineSelectConstants, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineSelectVirtualColumns]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			scan := _project.Input
			_scan, _ := scan.(*memo.ScanExpr)
			if _scan != nil {
				scanPrivate := &_scan.ScanPrivate
				projections := _project.Projections
				passthrough := _project.Passthrough
				virtualColumns := _f.funcs.VirtualColumns(scanPrivate)
				if !_f.funcs.ColsAreEmpty(virtualColumns) {
					inlinableFilters := _f.funcs.InlinableVirtualColumnFilters(filters, virtualColumns)
					if !_f.funcs.IsFilterEmpty(inlinableFilters) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineSelectVirtualColumns) {
							_expr := _f.ConstructSelect(
								_f.ConstructProject(
									_f.ConstructSelect(
										_scan,
										_f.funcs.InlineSelectProject(inlinableFilters, projections),
									),
									projections,
									passthrough,
								),
								_f.funcs.DiffFilters(filters, inlinableFilters),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineSelectVirtualColumns, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [RejectNullsProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			innerInput := _project.Input
			projections := _project.Projections
			projectionCols := _f.funcs.ProjectionCols(projections)
			if !_f.funcs.ColsAreEmpty(projectionCols) {
				passthrough := _project.Passthrough
				rejectNullCols := _f.funcs.RejectNullCols(_project)
				if !_f.funcs.ColsAreEmpty(rejectNullCols) {
					nullRejectedCols := _f.funcs.IntersectionCols(projectionCols, rejectNullCols)
					if _f.funcs.HasNullRejectingFilter(filters, nullRejectedCols) {
						if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsProject) {
							_expr := _f.ConstructSelect(
								_f.ConstructProject(
									_f.ConstructSelect(
										innerInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.NullRejectProjections(projections, nullRejectedCols, _f.funcs.RejectNullCols(innerInput)),
													_f.ConstructNull(
														_f.funcs.AnyType(),
													),
												),
											),
										},
									),
									projections,
									passthrough,
								),
								filters,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.RejectNullsProject, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [EliminateSelect]
	{
		if len(filters) == 0 {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateSelect) {
				_expr := input
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateSelect, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [MergeSelects]
	{
		_select, _ := input.(*memo.SelectExpr)
		if _select != nil {
			input := _select.Input
			innerFilters := _select.Filters
			if _f.matchedRule == nil || _f.matchedRule(opt.MergeSelects) {
				_expr := _f.ConstructSelect(
					input,
					_f.funcs.ConcatFilters(innerFilters, filters),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.MergeSelects, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PushSelectIntoProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			passthrough := _project.Passthrough
			for i := range filters {
				item := &filters[i]
				inputCols := _f.funcs.OutputCols(input)
				if _f.funcs.IsBoundBy(item, inputCols) {
					if _f.matchedRule == nil || _f.matchedRule(opt.PushSelectIntoProject) {
						_expr := _f.ConstructSelect(
							_f.ConstructProject(
								_f.ConstructSelect(
									input,
									_f.funcs.ExtractBoundConditions(filters, inputCols),
								),
								projections,
								passthrough,
							),
							_f.funcs.ExtractUnboundConditions(filters, inputCols),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushSelectIntoProject, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [MergeSelectInnerJoin]
	{
		if input.Op() == opt.InnerJoinOp || input.Op() == opt.InnerJoinApplyOp {
			left := input.Child(0).(memo.RelExpr)
			right := input.Child(1).(memo.RelExpr)
			on := *input.Child(2).(*memo.FiltersExpr)
			private := input.Private().(*memo.JoinPrivate)
			if _f.matchedRule == nil || _f.matchedRule(opt.MergeSelectInnerJoin) {
				_arg := _f.funcs.ConcatFilters(on, filters)
				_expr := _f.DynamicConstruct(
					input.Op(),
					left,
					right,
					&_arg,
					private,
				).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.MergeSelectInnerJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PushSelectCondLeftIntoJoinLeftAndRight]
	{
		if input.Op() == opt.LeftJoinOp || input.Op() == opt.LeftJoinApplyOp || input.Op() == opt.SemiJoinOp || input.Op() == opt.SemiJoinApplyOp || input.Op() == opt.AntiJoinOp || input.Op() == opt.AntiJoinApplyOp {
			left := input.Child(0).(memo.RelExpr)
			right := input.Child(1).(memo.RelExpr)
			on := *input.Child(2).(*memo.FiltersExpr)
			private := input.Private().(*memo.JoinPrivate)
			for i := range filters {
				item := &filters[i]
				condition := item.Condition
				if _f.funcs.IsBoundBy(item, _f.funcs.OutputCols(left)) {
					rightCols := _f.funcs.OutputCols(right)
					equivFD := _f.funcs.GetEquivFD(on, left, right)
					if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
						if _f.matchedRule == nil || _f.matchedRule(opt.PushSelectCondLeftIntoJoinLeftAndRight) {
							on := on
							_expr := _f.ConstructSelect(
								_f.DynamicConstruct(
									input.Op(),
									_f.ConstructSelect(
										left,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												condition,
											),
										},
									),
									_f.ConstructSelect(
										right,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.funcs.MapJoinOpFilter(item, rightCols, equivFD),
											),
										},
									),
									&on,
									private,
								).(memo.RelExpr),
								_f.funcs.RemoveFiltersItem(filters, item),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.PushSelectCondLeftIntoJoinLeftAndRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [PushSelectIntoJoinLeft]
	{
		if input.Op() == opt.LeftJoinOp || input.Op() == opt.LeftJoinApplyOp || input.Op() == opt.SemiJoinOp || input.Op() == opt.SemiJoinApplyOp || input.Op() == opt.AntiJoinOp || input.Op() == opt.AntiJoinApplyOp {
			left := input.Child(0).(memo.RelExpr)
			right := input.Child(1).(memo.RelExpr)
			on := *input.Child(2).(*memo.FiltersExpr)
			private := input.Private().(*memo.JoinPrivate)
			for i := range filters {
				item := &filters[i]
				leftCols := _f.funcs.OutputCols(left)
				if _f.funcs.IsBoundBy(item, leftCols) {
					if _f.matchedRule == nil || _f.matchedRule(opt.PushSelectIntoJoinLeft) {
						on := on
						_expr := _f.ConstructSelect(
							_f.DynamicConstruct(
								input.Op(),
								_f.ConstructSelect(
									left,
									_f.funcs.ExtractBoundConditions(filters, leftCols),
								),
								right,
								&on,
								private,
							).(memo.RelExpr),
							_f.funcs.ExtractUnboundConditions(filters, leftCols),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushSelectIntoJoinLeft, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushSelectIntoGroupBy]
	{
		if input.Op() == opt.GroupByOp || input.Op() == opt.DistinctOnOp {
			groupingInput := input.Child(0).(memo.RelExpr)
			aggregations := *input.Child(1).(*memo.AggregationsExpr)
			groupingPrivate := input.Private().(*memo.GroupingPrivate)
			for i := range filters {
				item := &filters[i]
				passthrough := _f.funcs.GroupingAndConstCols(groupingPrivate, aggregations)
				if _f.funcs.IsBoundBy(item, passthrough) {
					if _f.matchedRule == nil || _f.matchedRule(opt.PushSelectIntoGroupBy) {
						aggregations := aggregations
						_expr := _f.ConstructSelect(
							_f.DynamicConstruct(
								input.Op(),
								_f.ConstructSelect(
									groupingInput,
									_f.funcs.ExtractBoundConditions(filters, passthrough),
								),
								&aggregations,
								groupingPrivate,
							).(memo.RelExpr),
							_f.funcs.ExtractUnboundConditions(filters, passthrough),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushSelectIntoGroupBy, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [RemoveNotNullCondition]
	{
		for i := range filters {
			item := &filters[i]
			_isNot, _ := item.Condition.(*memo.IsNotExpr)
			if _isNot != nil {
				_variable, _ := _isNot.Left.(*memo.VariableExpr)
				if _variable != nil {
					col := _variable.Col
					if _f.funcs.IsColNotNull(col, input) {
						_null, _ := _isNot.Right.(*memo.NullExpr)
						if _null != nil {
							if _f.matchedRule == nil || _f.matchedRule(opt.RemoveNotNullCondition) {
								_expr := _f.ConstructSelect(
									input,
									_f.funcs.RemoveFiltersItem(filters, item),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.RemoveNotNullCondition, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [SimplifyIsNullCondition]
	{
		for i := range filters {
			item := &filters[i]
			_is, _ := item.Condition.(*memo.IsExpr)
			if _is != nil {
				_variable, _ := _is.Left.(*memo.VariableExpr)
				if _variable != nil {
					col := _variable.Col
					if _f.funcs.IsColNotNull(col, input) {
						_null, _ := _is.Right.(*memo.NullExpr)
						if _null != nil {
							if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyIsNullCondition) {
								_expr := _f.ConstructSelect(
									input,
									memo.FiltersExpr{
										_f.ConstructFiltersItem(
											_f.ConstructFalse(),
										),
									},
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.SimplifyIsNullCondition, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [PushSelectIntoProjectSet]
	{
		_projectSet, _ := input.(*memo.ProjectSetExpr)
		if _projectSet != nil {
			input := _projectSet.Input
			zip := _projectSet.Zip
			for i := range filters {
				item := &filters[i]
				inputCols := _f.funcs.OutputCols(input)
				if _f.funcs.IsBoundBy(item, inputCols) {
					if _f.matchedRule == nil || _f.matchedRule(opt.PushSelectIntoProjectSet) {
						_expr := _f.ConstructSelect(
							_f.ConstructProjectSet(
								_f.ConstructSelect(
									input,
									_f.funcs.ExtractBoundConditions(filters, inputCols),
								),
								zip,
							),
							_f.funcs.ExtractUnboundConditions(filters, inputCols),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushSelectIntoProjectSet, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoSetOp]
	{
		if opt.IsSetOp(input) {
			left := input.Child(0).(memo.RelExpr)
			right := input.Child(1).(memo.RelExpr)
			colmap := input.Private().(*memo.SetPrivate)
			filter := filters
			for i := range filter {
				item := &filter[i]
				if _f.funcs.CanMapOnSetOp(item) {
					inputCols := _f.funcs.OutputCols(input)
					if _f.funcs.IsBoundBy(item, inputCols) {
						if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoSetOp) {
							_expr := _f.ConstructSelect(
								_f.DynamicConstruct(
									input.Op(),
									_f.ConstructSelect(
										left,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.funcs.MapSetOpFilterLeft(item, colmap),
											),
										},
									),
									_f.ConstructSelect(
										right,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.funcs.MapSetOpFilterRight(item, colmap),
											),
										},
									),
									colmap,
								).(memo.RelExpr),
								_f.funcs.RemoveFiltersItem(filter, item),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.PushFilterIntoSetOp, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [PushSelectIntoWindow]
	{
		_window, _ := input.(*memo.WindowExpr)
		if _window != nil {
			input := _window.Input
			fn := _window.Windows
			private := &_window.WindowPrivate
			for i := range filters {
				item := &filters[i]
				partitionCols := _f.funcs.WindowPartition(private)
				if _f.funcs.ColsAreDeterminedBy(_f.funcs.OuterCols(item), partitionCols, input) {
					if _f.matchedRule == nil || _f.matchedRule(opt.PushSelectIntoWindow) {
						_expr := _f.ConstructSelect(
							_f.ConstructWindow(
								_f.ConstructSelect(
									input,
									_f.funcs.ExtractDeterminedConditions(filters, partitionCols, input),
								),
								fn,
								private,
							),
							_f.funcs.ExtractUndeterminedConditions(filters, partitionCols, input),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushSelectIntoWindow, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [HoistSelectExists]
	{
		for i := range filters {
			item := &filters[i]
			if _f.funcs.HasHoistableSubquery(item) {
				_exists, _ := item.Condition.(*memo.ExistsExpr)
				if _exists != nil {
					subquery := _exists.Input
					if _f.matchedRule == nil || _f.matchedRule(opt.HoistSelectExists) {
						_expr := _f.ConstructSelect(
							_f.ConstructSemiJoinApply(
								input,
								subquery,
								memo.EmptyFiltersExpr,
								_f.funcs.EmptyJoinPrivate(),
							),
							_f.funcs.RemoveFiltersItem(filters, item),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.HoistSelectExists, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [HoistSelectNotExists]
	{
		for i := range filters {
			item := &filters[i]
			if _f.funcs.HasHoistableSubquery(item) {
				_not, _ := item.Condition.(*memo.NotExpr)
				if _not != nil {
					_exists, _ := _not.Input.(*memo.ExistsExpr)
					if _exists != nil {
						subquery := _exists.Input
						if _f.matchedRule == nil || _f.matchedRule(opt.HoistSelectNotExists) {
							_expr := _f.ConstructSelect(
								_f.ConstructAntiJoinApply(
									input,
									subquery,
									memo.EmptyFiltersExpr,
									_f.funcs.EmptyJoinPrivate(),
								),
								_f.funcs.RemoveFiltersItem(filters, item),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.HoistSelectNotExists, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [HoistSelectSubquery]
	{
		for i := range filters {
			item := &filters[i]
			if _f.funcs.HasHoistableSubquery(item) {
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistSelectSubquery) {
					_expr := _f.funcs.HoistSelectSubquery(input, filters).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistSelectSubquery, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PushSelectIntoInlinableProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			if _f.funcs.CanInlineProjections(projections) {
				passthrough := _project.Passthrough
				if !_f.funcs.FilterHasCorrelatedSubquery(filters) {
					if _f.matchedRule == nil || _f.matchedRule(opt.PushSelectIntoInlinableProject) {
						_expr := _f.ConstructProject(
							_f.ConstructSelect(
								input,
								_f.funcs.InlineSelectProject(filters, projections),
							),
							projections,
							passthrough,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushSelectIntoInlinableProject, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [RejectNullsGroupBy]
	{
		if input.Op() == opt.GroupByOp || input.Op() == opt.ScalarGroupByOp {
			innerInput := input.Child(0).(memo.RelExpr)
			aggregations := *input.Child(1).(*memo.AggregationsExpr)
			groupingPrivate := input.Private().(*memo.GroupingPrivate)
			rejectCols := _f.funcs.RejectNullCols(input)
			if _f.funcs.HasNullRejectingFilter(filters, rejectCols) {
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsGroupBy) {
					aggregations := aggregations
					_expr := _f.ConstructSelect(
						_f.DynamicConstruct(
							input.Op(),
							_f.ConstructSelect(
								innerInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.ConstructIsNot(
											_f.funcs.NullRejectAggVar(aggregations, rejectCols),
											_f.ConstructNull(
												_f.funcs.AnyType(),
											),
										),
									),
								},
							),
							&aggregations,
							groupingPrivate,
						).(memo.RelExpr),
						filters,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsGroupBy, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [ConsolidateSelectFilters]
	{
		if _f.funcs.CanConsolidateFilters(filters) {
			if _f.matchedRule == nil || _f.matchedRule(opt.ConsolidateSelectFilters) {
				_expr := _f.ConstructSelect(
					input,
					_f.funcs.ConsolidateFilters(filters),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ConsolidateSelectFilters, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [DeduplicateSelectFilters]
	{
		if _f.funcs.HasDuplicateFilters(filters) {
			if _f.matchedRule == nil || _f.matchedRule(opt.DeduplicateSelectFilters) {
				_expr := _f.ConstructSelect(
					input,
					_f.funcs.DeduplicateFilters(filters),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.DeduplicateSelectFilters, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeSelect(input, filters)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructProject constructs an expression for the Project operator.
// Project modifies the set of columns returned by the input result set. Columns
// can be removed, reordered, or renamed. In addition, new columns can be
// synthesized.
//
// Projections describes the synthesized columns constructed by Project, and
// Passthrough describes the input columns that are passed through as Project
// output columns.
func (_f *Factory) ConstructProject(
	input memo.RelExpr,
	projections memo.ProjectionsExpr,
	passthrough opt.ColSet,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [InlineProjectConstants]
	{
		constCols := _f.funcs.FindInlinableConstants(input)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range projections {
				item := &projections[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					if _f.matchedRule == nil || _f.matchedRule(opt.InlineProjectConstants) {
						_expr := _f.ConstructProject(
							input,
							_f.funcs.InlineProjectionConstants(projections, input, constCols),
							passthrough,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.InlineProjectConstants, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [EliminateJoinUnderProjectLeft]
	{
		join := input
		if join.Op() == opt.InnerJoinOp || join.Op() == opt.LeftJoinOp {
			left := join.Child(0).(memo.RelExpr)
			right := join.Child(1).(memo.RelExpr)
			if _f.funcs.JoinDoesNotDuplicateLeftRows(join) {
				if _f.funcs.JoinPreservesLeftRows(join) {
					rightCols := _f.funcs.OutputCols(right)
					if !_f.funcs.AreProjectionsCorrelated(projections, rightCols) {
						if !_f.funcs.ColsIntersect(passthrough, rightCols) {
							if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinUnderProjectLeft) {
								_expr := _f.ConstructProject(
									left,
									projections,
									passthrough,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.EliminateJoinUnderProjectLeft, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [EliminateJoinUnderProjectRight]
	{
		join := input
		_innerJoin, _ := join.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			left := _innerJoin.Left
			right := _innerJoin.Right
			if _f.funcs.JoinDoesNotDuplicateRightRows(_innerJoin) {
				if _f.funcs.JoinPreservesRightRows(_innerJoin) {
					leftCols := _f.funcs.OutputCols(left)
					if !_f.funcs.AreProjectionsCorrelated(projections, leftCols) {
						if !_f.funcs.ColsIntersect(passthrough, leftCols) {
							if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinUnderProjectRight) {
								_expr := _f.ConstructProject(
									right,
									projections,
									passthrough,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.EliminateJoinUnderProjectRight, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [EliminateProject]
	{
		if len(projections) == 0 {
			if _f.funcs.ColsAreEqual(passthrough, _f.funcs.OutputCols(input)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateProject) {
					_expr := input
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [MergeProjects]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			innerInput := _project.Input
			innerProjections := _project.Projections
			if _f.funcs.CanMergeProjections(projections, innerProjections) {
				if _f.matchedRule == nil || _f.matchedRule(opt.MergeProjects) {
					_expr := _f.ConstructProject(
						innerInput,
						_f.funcs.MergeProjections(projections, innerProjections, passthrough),
						_f.funcs.DifferenceCols(passthrough, _f.funcs.ProjectionCols(innerProjections)),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.MergeProjects, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [MergeProjectWithValues]
	{
		_values, _ := input.(*memo.ValuesExpr)
		if _values != nil {
			if len(_values.Rows) == 1 {
				if !_f.funcs.AreProjectionsCorrelated(projections, _f.funcs.OutputCols(_values)) {
					if _f.matchedRule == nil || _f.matchedRule(opt.MergeProjectWithValues) {
						_expr := _f.funcs.MergeProjectWithValues(projections, passthrough, _values).(memo.RelExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.MergeProjectWithValues, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushColumnRemappingIntoValues]
	{
		_values, _ := input.(*memo.ValuesExpr)
		if _values != nil {
			if _f.funcs.CanPushColumnRemappingIntoValues(projections, passthrough, _values) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PushColumnRemappingIntoValues) {
					_expr := _f.funcs.PushColumnRemappingIntoValues(_values, projections, passthrough).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PushColumnRemappingIntoValues, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PushAssignmentCastsIntoValues]
	{
		_values, _ := input.(*memo.ValuesExpr)
		if _values != nil {
			castCols := _f.funcs.IntersectionCols(_f.funcs.DifferenceCols(_f.funcs.AssignmentCastCols(projections), passthrough), _f.funcs.OutputCols(_values))
			if !_f.funcs.ColsAreEmpty(castCols) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PushAssignmentCastsIntoValues) {
					_expr := _f.funcs.PushAssignmentCastsIntoValues(_values, projections, passthrough, castCols).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PushAssignmentCastsIntoValues, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldTupleAccessIntoValues]
	{
		_values, _ := input.(*memo.ValuesExpr)
		if _values != nil {
			if len(_values.Rows) > 0 {
				if _f.funcs.ColsAreLenOne(_f.funcs.OutputCols(_values)) {
					if _f.funcs.CanUnnestTuplesFromValues(_values) {
						col := _f.funcs.SingleColFromSet(_f.funcs.OutputCols(_values))
						if _f.funcs.HasNoDirectTupleReferences(projections, col) {
							if _f.funcs.ColsAreEmpty(passthrough) {
								if _f.matchedRule == nil || _f.matchedRule(opt.FoldTupleAccessIntoValues) {
									tupleCols := _f.funcs.MakeColsForUnnestTuples(col)
									_expr := _f.ConstructProject(
										_f.funcs.UnnestTuplesFromValues(_values, tupleCols),
										_f.funcs.FoldTupleColumnAccess(projections, tupleCols, col),
										passthrough,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.FoldTupleAccessIntoValues, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [FoldJSONAccessIntoValues]
	{
		_values, _ := input.(*memo.ValuesExpr)
		if _values != nil {
			if len(_values.Rows) > 0 {
				if _f.funcs.ColsAreLenOne(_f.funcs.OutputCols(_values)) {
					col := _f.funcs.SingleColFromSet(_f.funcs.OutputCols(_values))
					if _f.funcs.CanUnnestJSONFromValues(_values, projections, col) {
						if _f.funcs.ColsAreEmpty(passthrough) {
							if _f.matchedRule == nil || _f.matchedRule(opt.FoldJSONAccessIntoValues) {
								jsonCols := _f.funcs.MakeColsForUnnestJSON(_values, col)
								_expr := _f.ConstructProject(
									_f.funcs.UnnestJSONFromValues(_values, jsonCols),
									_f.funcs.FoldJSONFieldAccess(projections, jsonCols, col, _values),
									passthrough,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.FoldJSONAccessIntoValues, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [PruneProjectCols]
	{
		project := input
		_project, _ := project.(*memo.ProjectExpr)
		if _project != nil {
			needed := _f.funcs.UnionCols(_f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(_project, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneProjectCols) {
					_expr := _f.ConstructProject(
						_f.funcs.PruneCols(_project, needed),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneProjectCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneScanCols]
	{
		_scan, _ := input.(*memo.ScanExpr)
		if _scan != nil {
			needed := _f.funcs.UnionCols(_f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(_scan, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneScanCols) {
					_expr := _f.ConstructProject(
						_f.funcs.PruneCols(_scan, needed),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneScanCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneSelectCols]
	{
		_select, _ := input.(*memo.SelectExpr)
		if _select != nil {
			input := _select.Input
			filters := _select.Filters
			needed := _f.funcs.UnionCols3(_f.funcs.FilterOuterCols(filters), _f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(input, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneSelectCols) {
					_expr := _f.ConstructProject(
						_f.ConstructSelect(
							_f.funcs.PruneCols(input, needed),
							filters,
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneSelectCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneLimitCols]
	{
		_limit, _ := input.(*memo.LimitExpr)
		if _limit != nil {
			input := _limit.Input
			limit := _limit.Limit
			ordering := _limit.Ordering
			needed := _f.funcs.UnionCols3(_f.funcs.OrderingCols(ordering), _f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(input, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneLimitCols) {
					_expr := _f.ConstructProject(
						_f.ConstructLimit(
							_f.funcs.PruneCols(input, needed),
							limit,
							_f.funcs.PruneOrdering(ordering, needed),
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneLimitCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneOffsetCols]
	{
		_offset, _ := input.(*memo.OffsetExpr)
		if _offset != nil {
			input := _offset.Input
			offset := _offset.Offset
			ordering := _offset.Ordering
			needed := _f.funcs.UnionCols3(_f.funcs.OrderingCols(ordering), _f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(input, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneOffsetCols) {
					_expr := _f.ConstructProject(
						_f.ConstructOffset(
							_f.funcs.PruneCols(input, needed),
							offset,
							_f.funcs.PruneOrdering(ordering, needed),
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneOffsetCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneJoinLeftCols]
	{
		if opt.IsJoinOp(input) {
			left := input.Child(0).(memo.RelExpr)
			right := input.Child(1).(memo.RelExpr)
			on := *input.Child(2).(*memo.FiltersExpr)
			private := input.Private().(*memo.JoinPrivate)
			needed := _f.funcs.UnionCols4(_f.funcs.OuterCols(right), _f.funcs.FilterOuterCols(on), _f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(left, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneJoinLeftCols) {
					on := on
					_expr := _f.ConstructProject(
						_f.DynamicConstruct(
							input.Op(),
							_f.funcs.PruneCols(left, needed),
							right,
							&on,
							private,
						).(memo.RelExpr),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneJoinLeftCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneJoinRightCols]
	{
		if opt.IsJoinOp(input) {
			left := input.Child(0).(memo.RelExpr)
			right := input.Child(1).(memo.RelExpr)
			on := *input.Child(2).(*memo.FiltersExpr)
			private := input.Private().(*memo.JoinPrivate)
			needed := _f.funcs.UnionCols3(_f.funcs.FilterOuterCols(on), _f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(right, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneJoinRightCols) {
					on := on
					_expr := _f.ConstructProject(
						_f.DynamicConstruct(
							input.Op(),
							left,
							_f.funcs.PruneCols(right, needed),
							&on,
							private,
						).(memo.RelExpr),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneJoinRightCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneAggCols]
	{
		if input.Op() == opt.GroupByOp || input.Op() == opt.ScalarGroupByOp || input.Op() == opt.DistinctOnOp || input.Op() == opt.EnsureDistinctOnOp {
			innerInput := input.Child(0).(memo.RelExpr)
			aggregations := *input.Child(1).(*memo.AggregationsExpr)
			groupingPrivate := input.Private().(*memo.GroupingPrivate)
			needed := _f.funcs.UnionCols(_f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneAggCols(aggregations, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneAggCols) {
					_arg := _f.funcs.PruneAggCols(aggregations, needed)
					_expr := _f.ConstructProject(
						_f.DynamicConstruct(
							input.Op(),
							innerInput,
							&_arg,
							groupingPrivate,
						).(memo.RelExpr),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneAggCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneValuesCols]
	{
		_values, _ := input.(*memo.ValuesExpr)
		if _values != nil {
			needed := _f.funcs.UnionCols(_f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(_values, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneValuesCols) {
					_expr := _f.ConstructProject(
						_f.funcs.PruneCols(_values, needed),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneValuesCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneOrdinalityCols]
	{
		_ordinality, _ := input.(*memo.OrdinalityExpr)
		if _ordinality != nil {
			input := _ordinality.Input
			ordinalityPrivate := &_ordinality.OrdinalityPrivate
			needed := _f.funcs.UnionCols3(_f.funcs.NeededOrdinalityCols(ordinalityPrivate), _f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(input, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneOrdinalityCols) {
					_expr := _f.ConstructProject(
						_f.ConstructOrdinality(
							_f.funcs.PruneCols(input, needed),
							_f.funcs.PruneOrderingOrdinality(ordinalityPrivate, needed),
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneOrdinalityCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneProjectSetCols]
	{
		_projectSet, _ := input.(*memo.ProjectSetExpr)
		if _projectSet != nil {
			innerInput := _projectSet.Input
			zip := _projectSet.Zip
			needed := _f.funcs.UnionCols3(_f.funcs.ZipOuterCols(zip), _f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(_projectSet, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneProjectSetCols) {
					_expr := _f.ConstructProject(
						_f.ConstructProjectSet(
							_f.funcs.PruneCols(innerInput, needed),
							zip,
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneProjectSetCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneWindowOutputCols]
	{
		_window, _ := input.(*memo.WindowExpr)
		if _window != nil {
			input := _window.Input
			windows := _window.Windows
			private := &_window.WindowPrivate
			needed := _f.funcs.UnionCols(_f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneWindows(needed, windows) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneWindowOutputCols) {
					_expr := _f.ConstructProject(
						_f.ConstructWindow(
							input,
							_f.funcs.PruneWindows(needed, windows),
							private,
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneWindowOutputCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneWindowInputCols]
	{
		_window, _ := input.(*memo.WindowExpr)
		if _window != nil {
			innerInput := _window.Input
			fn := _window.Windows
			private := &_window.WindowPrivate
			needed := _f.funcs.UnionCols3(_f.funcs.NeededWindowCols(fn, private), _f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(_window, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneWindowInputCols) {
					_expr := _f.ConstructProject(
						_f.ConstructWindow(
							_f.funcs.PruneCols(innerInput, needed),
							fn,
							private,
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneWindowInputCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneMutationReturnCols]
	{
		if input.Op() == opt.InsertOp || input.Op() == opt.UpdateOp || input.Op() == opt.UpsertOp || input.Op() == opt.DeleteOp {
			innerInput := input.Child(0).(memo.RelExpr)
			uniqueChecks := *input.Child(1).(*memo.UniqueChecksExpr)
			fkChecks := *input.Child(2).(*memo.FKChecksExpr)
			mutationPrivate := input.Private().(*memo.MutationPrivate)
			needed := _f.funcs.UnionCols3(_f.funcs.PrimaryKeyCols(_f.funcs.MutationTable(mutationPrivate)), _f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneMutationReturnCols(mutationPrivate, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneMutationReturnCols) {
					uniqueChecks := uniqueChecks
					fkChecks := fkChecks
					_expr := _f.ConstructProject(
						_f.DynamicConstruct(
							input.Op(),
							innerInput,
							&uniqueChecks,
							&fkChecks,
							_f.funcs.PruneMutationReturnCols(mutationPrivate, needed),
						).(memo.RelExpr),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneMutationReturnCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneWithScanCols]
	{
		_withScan, _ := input.(*memo.WithScanExpr)
		if _withScan != nil {
			needed := _f.funcs.UnionCols(_f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(_withScan, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneWithScanCols) {
					_expr := _f.ConstructProject(
						_f.funcs.PruneCols(_withScan, needed),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneWithScanCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PruneWithCols]
	{
		_with, _ := input.(*memo.WithExpr)
		if _with != nil {
			binding := _with.Binding
			input := _with.Main
			private := &_with.WithPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneWithCols) {
				_expr := _f.ConstructWith(
					binding,
					_f.ConstructProject(
						input,
						projections,
						passthrough,
					),
					private,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneWithCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PruneUnionAllCols]
	{
		union := input
		_unionAll, _ := union.(*memo.UnionAllExpr)
		if _unionAll != nil {
			left := _unionAll.Left
			right := _unionAll.Right
			colmap := &_unionAll.SetPrivate
			needed := _f.funcs.UnionCols(_f.funcs.ProjectionOuterCols(projections), passthrough)
			if _f.funcs.CanPruneCols(_unionAll, needed) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PruneUnionAllCols) {
					_expr := _f.ConstructProject(
						_f.ConstructUnionAll(
							_f.ConstructProject(
								left,
								memo.EmptyProjectionsExpr,
								_f.funcs.NeededColMapLeft(needed, colmap),
							),
							_f.ConstructProject(
								right,
								memo.EmptyProjectionsExpr,
								_f.funcs.NeededColMapRight(needed, colmap),
							),
							_f.funcs.PruneSetPrivate(needed, colmap),
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PruneUnionAllCols, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [HoistProjectSubquery]
	{
		for i := range projections {
			item := &projections[i]
			if _f.funcs.HasHoistableSubquery(item) {
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistProjectSubquery) {
					_expr := _f.funcs.HoistProjectSubquery(input, projections, passthrough).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistProjectSubquery, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [InlineProjectInProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			innerProjections := _project.Projections
			if !_f.funcs.HasDuplicateRefs(projections, passthrough, _f.funcs.ProjectionCols(innerProjections)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.InlineProjectInProject) {
					_expr := _f.funcs.InlineProjectProject(_project, projections, passthrough).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.InlineProjectInProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeProject(input, projections, passthrough)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructInvertedFilter constructs an expression for the InvertedFilter operator.
// InvertedFilter filters rows from its input result set, based on the
// InvertedExpression predicate (which is defined in InvertedFilterPrivate).
// Rows which do not match the filter are discarded. The input should be a
// constrained scan of an inverted index, possibly wrapped in other operators
// such as Select.
func (_f *Factory) ConstructInvertedFilter(
	input memo.RelExpr,
	invertedFilterPrivate *memo.InvertedFilterPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeInvertedFilter(input, invertedFilterPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructInnerJoin constructs an expression for the InnerJoin operator.
// InnerJoin creates a result set that combines columns from its left and right
// inputs, based upon its "on" join predicate. Rows which do not match the
// predicate are filtered. While expressions in the predicate can refer to
// columns projected by either the left or right inputs, the inputs are not
// allowed to refer to the other's projected columns.
func (_f *Factory) ConstructInnerJoin(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructInnerJoin(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		if _f.funcs.HasOuterCols(right) {
			_select, _ := right.(*memo.SelectExpr)
			if _select != nil {
				input := _select.Input
				filters := _select.Filters
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSelect) {
					_expr := _f.ConstructInnerJoin(
						left,
						input,
						_f.funcs.ConcatFilters(on, filters),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateSelect, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateProject]
	{
		if _f.funcs.HasOuterCols(right) {
			_project, _ := right.(*memo.ProjectExpr)
			if _project != nil {
				input := _project.Input
				projections := _project.Projections
				passthrough := _project.Passthrough
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateProject) {
					_expr := _f.ConstructSelect(
						_f.ConstructProject(
							_f.ConstructInnerJoin(
								left,
								input,
								memo.EmptyFiltersExpr,
								private,
							),
							projections,
							_f.funcs.UnionCols(_f.funcs.OutputCols(left), passthrough),
						),
						on,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateInnerJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.InnerJoinOp || right.Op() == opt.InnerJoinApplyOp {
				innerLeft := right.Child(0).(memo.RelExpr)
				innerRight := right.Child(1).(memo.RelExpr)
				innerOn := *right.Child(2).(*memo.FiltersExpr)
				if !_f.funcs.FiltersBoundBy(innerOn, _f.funcs.OutputCols2(innerLeft, innerRight)) {
					innerPrivate := right.Private().(*memo.JoinPrivate)
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerJoin) {
						_expr := _f.ConstructInnerJoin(
							left,
							_f.DynamicConstruct(
								right.Op(),
								innerLeft,
								innerRight,
								&memo.EmptyFiltersExpr,
								innerPrivate,
							).(memo.RelExpr),
							_f.funcs.ConcatFilters(on, innerOn),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateInnerLeftJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			_leftJoin, _ := right.(*memo.LeftJoinExpr)
			if _leftJoin != nil {
				innerLeft := _leftJoin.Left
				innerRight := _leftJoin.Right
				innerOn := _leftJoin.On
				innerPrivate := &_leftJoin.JoinPrivate
				if _f.funcs.FiltersBoundBy(on, _f.funcs.OutputCols2(left, innerLeft)) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerLeftJoin) {
						_expr := _f.ConstructLeftJoinApply(
							_f.ConstructInnerJoin(
								left,
								innerLeft,
								on,
								innerPrivate,
							),
							innerRight,
							innerOn,
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerLeftJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateGroupBy]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.GroupByOp || right.Op() == opt.DistinctOnOp {
				input := right.Child(0).(memo.RelExpr)
				aggregations := *right.Child(1).(*memo.AggregationsExpr)
				groupingPrivate := right.Private().(*memo.GroupingPrivate)
				if _f.funcs.IsUnorderedGrouping(groupingPrivate) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateGroupBy) {
						newLeft := _f.funcs.EnsureKey(left)
						_arg := _f.funcs.AppendAggCols(aggregations, opt.ConstAggOp, _f.funcs.NonKeyCols(newLeft))
						_expr := _f.ConstructProject(
							_f.ConstructSelect(
								_f.DynamicConstruct(
									right.Op(),
									_f.ConstructInnerJoinApply(
										newLeft,
										input,
										memo.EmptyFiltersExpr,
										private,
									),
									&_arg,
									_f.funcs.AddColsToGrouping(groupingPrivate, _f.funcs.KeyCols(newLeft)),
								).(memo.RelExpr),
								on,
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols2(left, right),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateGroupBy, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateScalarGroupBy]
	{
		if _f.funcs.HasOuterCols(right) {
			_scalarGroupBy, _ := right.(*memo.ScalarGroupByExpr)
			if _scalarGroupBy != nil {
				input := _scalarGroupBy.Input
				aggregations := _scalarGroupBy.Aggregations
				groupingPrivate := &_scalarGroupBy.GroupingPrivate
				if _f.funcs.AggsCanBeDecorrelated(aggregations) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateScalarGroupBy) {
						leftWithKey := _f.funcs.EnsureKey(left)
						canaryCol := _f.funcs.EnsureCanaryCol(input, aggregations)
						rightWithCanary := _f.funcs.EnsureCanary(input, canaryCol)
						translatedAggs := _f.funcs.EnsureAggsCanIgnoreNulls(rightWithCanary, aggregations)
						_expr := _f.ConstructSelect(
							_f.ConstructProject(
								_f.funcs.TranslateNonIgnoreAggs(_f.ConstructGroupBy(
									_f.ConstructLeftJoinApply(
										leftWithKey,
										rightWithCanary,
										memo.EmptyFiltersExpr,
										private,
									),
									_f.funcs.AppendAggCols2(translatedAggs, opt.ConstAggOp, _f.funcs.NonKeyCols(leftWithKey), opt.AnyNotNullAggOp, _f.funcs.CanaryColSet(canaryCol)),
									_f.funcs.MakeGrouping(_f.funcs.KeyCols(leftWithKey), _f.funcs.ExtractGroupingOrdering(groupingPrivate)),
								), translatedAggs, rightWithCanary, aggregations, canaryCol),
								memo.EmptyProjectionsExpr,
								_f.funcs.OutputCols2(left, _scalarGroupBy),
							),
							on,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateScalarGroupBy, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateLimitOne]
	{
		if _f.funcs.HasOuterCols(right) {
			_limit, _ := right.(*memo.LimitExpr)
			if _limit != nil {
				input := _limit.Input
				_const, _ := _limit.Limit.(*memo.ConstExpr)
				if _const != nil {
					if _f.funcs.EqualsNumber(_const.Value, 1) {
						ordering := _limit.Ordering
						private := joinPrivate
						if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateLimitOne) {
							newLeft := _f.funcs.EnsureKey(left)
							_expr := _f.ConstructProject(
								_f.ConstructDistinctOn(
									_f.ConstructInnerJoin(
										newLeft,
										input,
										on,
										private,
									),
									_f.funcs.MakeAggCols2(opt.ConstAggOp, _f.funcs.NonKeyCols(newLeft), opt.FirstAggOp, _f.funcs.OutputCols(input)),
									_f.funcs.MakeGrouping(_f.funcs.KeyCols(newLeft), ordering),
								),
								memo.EmptyProjectionsExpr,
								_f.funcs.OutputCols2(left, _limit),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.TryDecorrelateLimitOne, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateLimit]
	{
		_limit, _ := right.(*memo.LimitExpr)
		if _limit != nil {
			input := _limit.Input
			_const, _ := _limit.Limit.(*memo.ConstExpr)
			if _const != nil {
				limit := _const.Value
				ordering := _limit.Ordering
				if _f.funcs.HasOuterCols(_limit) {
					if _f.funcs.IsGreaterThan(limit, tree.NewDInt(1)) {
						private := joinPrivate
						if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateLimit) {
							rowNum, rowNumCol := _f.funcs.MakeRowNumberWindowFunc()
							_expr := _f.ConstructSelect(
								_f.ConstructInnerJoin(
									left,
									_f.ConstructWindow(
										input,
										rowNum,
										_f.funcs.MakeWindowPrivate(_f.funcs.MakeEmptyColSet(), ordering),
									),
									on,
									private,
								),
								_f.funcs.LimitToRowNumberFilter(limit, rowNumCol),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.TryDecorrelateLimit, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateWindow]
	{
		_window, _ := right.(*memo.WindowExpr)
		if _window != nil {
			input := _window.Input
			windows := _window.Windows
			private := &_window.WindowPrivate
			if _f.funcs.HasOuterCols(_window) {
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateWindow) {
					newLeft := _f.funcs.EnsureKey(left)
					_expr := _f.ConstructProject(
						_f.ConstructSelect(
							_f.ConstructWindow(
								_f.ConstructInnerJoin(
									newLeft,
									input,
									memo.EmptyFiltersExpr,
									joinPrivate,
								),
								windows,
								_f.funcs.AddColsToPartition(private, _f.funcs.KeyCols(newLeft)),
							),
							on,
						),
						memo.EmptyProjectionsExpr,
						_f.funcs.OutputCols2(left, _window),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateWindow, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateMax1Row]
	{
		if _f.funcs.HasOuterCols(right) {
			_max1Row, _ := right.(*memo.Max1RowExpr)
			if _max1Row != nil {
				input := _max1Row.Input
				errorText := _max1Row.ErrorText
				if len(on) == 0 {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateMax1Row) {
						newLeft := _f.funcs.EnsureKey(left)
						_expr := _f.ConstructProject(
							_f.ConstructEnsureDistinctOn(
								_f.ConstructInnerJoin(
									newLeft,
									input,
									memo.EmptyFiltersExpr,
									private,
								),
								_f.funcs.MakeAggCols(opt.ConstAggOp, _f.funcs.UnionCols(_f.funcs.NonKeyCols(newLeft), _f.funcs.OutputCols(input))),
								_f.funcs.MakeErrorOnDupGrouping(_f.funcs.KeyCols(newLeft), _f.funcs.EmptyOrdering(), errorText),
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols2(left, _max1Row),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateMax1Row, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructInnerJoin(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructInnerJoin(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructInnerJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructInnerJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructInnerJoin(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				for i := range on {
					item := &on[i]
					_match := false
					_eq, _ := item.Condition.(*memo.EqExpr)
					if _eq != nil {
						_variable, _ := _eq.Left.(*memo.VariableExpr)
						if _variable != nil {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								_match = true
							}
						}
					}

					if !_match {
						leftCols := _f.funcs.OutputCols(left)
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, leftCols, equivFD) {
							rightCols := _f.funcs.OutputCols(right)
							if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinLeftAndRight) {
									_expr := _f.ConstructInnerJoin(
										_f.ConstructSelect(
											left,
											memo.FiltersExpr{
												_f.ConstructFiltersItem(
													_f.funcs.MapJoinOpFilter(item, leftCols, equivFD),
												),
											},
										),
										_f.ConstructSelect(
											right,
											memo.FiltersExpr{
												_f.ConstructFiltersItem(
													_f.funcs.MapJoinOpFilter(item, rightCols, equivFD),
												),
											},
										),
										_f.funcs.RemoveFiltersItem(on, item),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.PushFilterIntoJoinLeftAndRight, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinLeft]
	{
		if !_f.funcs.HasOuterCols(left) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					leftCols := _f.funcs.OutputCols(left)
					if !_f.funcs.IsBoundBy(item, leftCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, leftCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinLeft) {
								_expr := _f.ConstructInnerJoin(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, leftCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinLeft, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					rightCols := _f.funcs.OutputCols(right)
					if !_f.funcs.IsBoundBy(item, rightCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinRight) {
								_expr := _f.ConstructInnerJoin(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, rightCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinRight, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapEqualityIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				leftCols := _f.funcs.OutputCols(left)
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.CanMapJoinOpEqualities(on, leftCols, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.MapEqualityIntoJoinLeftAndRight) {
						_expr := _f.ConstructInnerJoin(
							left,
							right,
							_f.funcs.MapJoinOpEqualities(on, leftCols, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.MapEqualityIntoJoinLeftAndRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinLeft]
	{
		if !_f.funcs.HasOuterCols(left) {
			for i := range on {
				item := &on[i]
				leftCols := _f.funcs.OutputCols(left)
				if _f.funcs.IsBoundBy(item, leftCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinLeft) {
						_expr := _f.ConstructInnerJoin(
							_f.ConstructSelect(
								left,
								_f.funcs.ExtractBoundConditions(on, leftCols),
							),
							right,
							_f.funcs.ExtractUnboundConditions(on, leftCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinLeft, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.IsBoundBy(item, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinRight) {
						_expr := _f.ConstructInnerJoin(
							left,
							_f.ConstructSelect(
								right,
								_f.funcs.ExtractBoundConditions(on, rightCols),
							),
							_f.funcs.ExtractUnboundConditions(on, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [EliminateJoinNoColsLeft]
	{
		if _f.funcs.ColsAreEmpty(_f.funcs.OutputCols(left)) {
			if _f.funcs.HasOneRow(left) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinNoColsLeft) {
					_expr := _f.ConstructSelect(
						right,
						on,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateJoinNoColsLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [EliminateJoinNoColsRight]
	{
		if _f.funcs.ColsAreEmpty(_f.funcs.OutputCols(right)) {
			if _f.funcs.HasOneRow(right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinNoColsRight) {
					_expr := _f.ConstructSelect(
						left,
						on,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateJoinNoColsRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [HoistJoinProjectRight]
	{
		_project, _ := right.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			if len(projections) == 0 {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinProjectRight) {
					_expr := _f.ConstructProject(
						_f.ConstructInnerJoin(
							left,
							input,
							on,
							private,
						),
						projections,
						_f.funcs.OutputCols2(left, _project),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinProjectRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [HoistJoinProjectLeft]
	{
		_project, _ := left.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			if len(projections) == 0 {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinProjectLeft) {
					_expr := _f.ConstructProject(
						_f.ConstructInnerJoin(
							input,
							right,
							on,
							private,
						),
						projections,
						_f.funcs.OutputCols2(_project, right),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinProjectLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructInnerJoin(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ExtractJoinComparisons]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				for i := range on {
					item := &on[i]
					if item.Condition.Op() == opt.EqOp || item.Condition.Op() == opt.LtOp || item.Condition.Op() == opt.LeOp || item.Condition.Op() == opt.GtOp || item.Condition.Op() == opt.GeOp {
						a := item.Condition.Child(0).(opt.ScalarExpr)
						if !(opt.IsConstValueOp(a)) {
							b := item.Condition.Child(1).(opt.ScalarExpr)
							if !(opt.IsConstValueOp(b)) {
								if _f.funcs.CanExtractJoinComparison(a, b, _f.funcs.OutputCols(left), _f.funcs.OutputCols(right)) {
									private := joinPrivate
									if _f.matchedRule == nil || _f.matchedRule(opt.ExtractJoinComparisons) {
										_expr := _f.funcs.ExtractJoinComparison(opt.InnerJoinOp, left, right, on, item, private).(memo.RelExpr)
										if _f.appliedRule != nil {
											_f.appliedRule(opt.ExtractJoinComparisons, nil, _expr)
										}
										_f.constructorStackDepth--
										return _expr
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [SortFiltersInJoin]
	{
		if !_f.funcs.AreFiltersSorted(on) {
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.SortFiltersInJoin) {
				_expr := _f.ConstructInnerJoin(
					left,
					right,
					_f.funcs.SortFilters(on),
					private,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SortFiltersInJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [ProjectInnerJoinValues]
	{
		_values, _ := right.(*memo.ValuesExpr)
		if _values != nil {
			if _f.funcs.HasOneRow(_values) {
				if _f.matchedRule == nil || _f.matchedRule(opt.ProjectInnerJoinValues) {
					_expr := _f.ConstructSelect(
						_f.ConstructProject(
							left,
							_f.funcs.MakeProjectionsFromValues(_values),
							_f.funcs.OutputCols(left),
						),
						on,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.ProjectInnerJoinValues, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [HoistJoinSubquery]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.HasHoistableSubquery(item) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinSubquery) {
					_expr := _f.funcs.HoistJoinSubquery(opt.InnerJoinOp, left, right, on, private).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinSubquery, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [LeftAssociateJoinsLeft]
	{
		_innerJoin, _ := left.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			insideLeft := _innerJoin.Left
			insideRight := _innerJoin.Right
			if len(_innerJoin.On) == 0 {
				insidePrivate := &_innerJoin.JoinPrivate
				if _f.funcs.NoJoinHints(insidePrivate) {
					outsideRight := right
					outsideOn := on
					for i := range outsideOn {
						item := &outsideOn[i]
						cols := _f.funcs.OutputCols2(insideLeft, outsideRight)
						if _f.funcs.IsBoundBy(item, cols) {
							outsidePrivate := joinPrivate
							if _f.funcs.NoJoinHints(outsidePrivate) {
								if _f.matchedRule == nil || _f.matchedRule(opt.LeftAssociateJoinsLeft) {
									_expr := _f.ConstructInnerJoin(
										insideRight,
										_f.ConstructInnerJoin(
											insideLeft,
											outsideRight,
											_f.funcs.ExtractBoundConditions(outsideOn, cols),
											_f.funcs.EmptyJoinPrivate(),
										),
										_f.funcs.ExtractUnboundConditions(outsideOn, cols),
										_f.funcs.EmptyJoinPrivate(),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.LeftAssociateJoinsLeft, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [LeftAssociateJoinsRight]
	{
		_innerJoin, _ := left.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			insideLeft := _innerJoin.Left
			insideRight := _innerJoin.Right
			if len(_innerJoin.On) == 0 {
				insidePrivate := &_innerJoin.JoinPrivate
				if _f.funcs.NoJoinHints(insidePrivate) {
					outsideRight := right
					outsideOn := on
					for i := range outsideOn {
						item := &outsideOn[i]
						cols := _f.funcs.OutputCols2(insideRight, outsideRight)
						if _f.funcs.IsBoundBy(item, cols) {
							outsidePrivate := joinPrivate
							if _f.funcs.NoJoinHints(outsidePrivate) {
								if _f.matchedRule == nil || _f.matchedRule(opt.LeftAssociateJoinsRight) {
									_expr := _f.ConstructInnerJoin(
										insideLeft,
										_f.ConstructInnerJoin(
											insideRight,
											outsideRight,
											_f.funcs.ExtractBoundConditions(outsideOn, cols),
											_f.funcs.EmptyJoinPrivate(),
										),
										_f.funcs.ExtractUnboundConditions(outsideOn, cols),
										_f.funcs.EmptyJoinPrivate(),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.LeftAssociateJoinsRight, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [RightAssociateJoinsLeft]
	{
		outsideLeft := left
		_innerJoin, _ := right.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			insideLeft := _innerJoin.Left
			insideRight := _innerJoin.Right
			if len(_innerJoin.On) == 0 {
				insidePrivate := &_innerJoin.JoinPrivate
				if _f.funcs.NoJoinHints(insidePrivate) {
					outsideOn := on
					for i := range outsideOn {
						item := &outsideOn[i]
						cols := _f.funcs.OutputCols2(insideLeft, outsideLeft)
						if _f.funcs.IsBoundBy(item, cols) {
							outsidePrivate := joinPrivate
							if _f.funcs.NoJoinHints(outsidePrivate) {
								if _f.matchedRule == nil || _f.matchedRule(opt.RightAssociateJoinsLeft) {
									_expr := _f.ConstructInnerJoin(
										_f.ConstructInnerJoin(
											outsideLeft,
											insideLeft,
											_f.funcs.ExtractBoundConditions(outsideOn, cols),
											_f.funcs.EmptyJoinPrivate(),
										),
										insideRight,
										_f.funcs.ExtractUnboundConditions(outsideOn, cols),
										_f.funcs.EmptyJoinPrivate(),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.RightAssociateJoinsLeft, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [RightAssociateJoinsRight]
	{
		outsideLeft := left
		_innerJoin, _ := right.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			insideLeft := _innerJoin.Left
			insideRight := _innerJoin.Right
			if len(_innerJoin.On) == 0 {
				insidePrivate := &_innerJoin.JoinPrivate
				if _f.funcs.NoJoinHints(insidePrivate) {
					outsideOn := on
					for i := range outsideOn {
						item := &outsideOn[i]
						cols := _f.funcs.OutputCols2(insideRight, outsideLeft)
						if _f.funcs.IsBoundBy(item, cols) {
							outsidePrivate := joinPrivate
							if _f.funcs.NoJoinHints(outsidePrivate) {
								if _f.matchedRule == nil || _f.matchedRule(opt.RightAssociateJoinsRight) {
									_expr := _f.ConstructInnerJoin(
										_f.ConstructInnerJoin(
											outsideLeft,
											insideRight,
											_f.funcs.ExtractBoundConditions(outsideOn, cols),
											_f.funcs.EmptyJoinPrivate(),
										),
										insideLeft,
										_f.funcs.ExtractUnboundConditions(outsideOn, cols),
										_f.funcs.EmptyJoinPrivate(),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.RightAssociateJoinsRight, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [RejectNullsUnderJoinLeft]
	{
		rejectCols := _f.funcs.RejectNullCols(left)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinLeft) {
					_expr := _f.ConstructInnerJoin(
						_f.ConstructSelect(
							left,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						right,
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [RejectNullsUnderJoinRight]
	{
		rejectCols := _f.funcs.RejectNullCols(right)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinRight) {
					_expr := _f.ConstructInnerJoin(
						left,
						_f.ConstructSelect(
							right,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeInnerJoin(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLeftJoin constructs an expression for the LeftJoin operator.
func (_f *Factory) ConstructLeftJoin(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructLeftJoin(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		if _f.funcs.HasOuterCols(right) {
			_select, _ := right.(*memo.SelectExpr)
			if _select != nil {
				input := _select.Input
				filters := _select.Filters
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSelect) {
					_expr := _f.ConstructLeftJoin(
						left,
						input,
						_f.funcs.ConcatFilters(on, filters),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateSelect, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateInnerJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.InnerJoinOp || right.Op() == opt.InnerJoinApplyOp {
				innerLeft := right.Child(0).(memo.RelExpr)
				innerRight := right.Child(1).(memo.RelExpr)
				innerOn := *right.Child(2).(*memo.FiltersExpr)
				if !_f.funcs.FiltersBoundBy(innerOn, _f.funcs.OutputCols2(innerLeft, innerRight)) {
					innerPrivate := right.Private().(*memo.JoinPrivate)
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerJoin) {
						_expr := _f.ConstructLeftJoin(
							left,
							_f.DynamicConstruct(
								right.Op(),
								innerLeft,
								innerRight,
								&memo.EmptyFiltersExpr,
								innerPrivate,
							).(memo.RelExpr),
							_f.funcs.ConcatFilters(on, innerOn),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateLimitOne]
	{
		if _f.funcs.HasOuterCols(right) {
			_limit, _ := right.(*memo.LimitExpr)
			if _limit != nil {
				input := _limit.Input
				_const, _ := _limit.Limit.(*memo.ConstExpr)
				if _const != nil {
					if _f.funcs.EqualsNumber(_const.Value, 1) {
						ordering := _limit.Ordering
						private := joinPrivate
						if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateLimitOne) {
							newLeft := _f.funcs.EnsureKey(left)
							_expr := _f.ConstructProject(
								_f.ConstructDistinctOn(
									_f.ConstructLeftJoin(
										newLeft,
										input,
										on,
										private,
									),
									_f.funcs.MakeAggCols2(opt.ConstAggOp, _f.funcs.NonKeyCols(newLeft), opt.FirstAggOp, _f.funcs.OutputCols(input)),
									_f.funcs.MakeGrouping(_f.funcs.KeyCols(newLeft), ordering),
								),
								memo.EmptyProjectionsExpr,
								_f.funcs.OutputCols2(left, _limit),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.TryDecorrelateLimitOne, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateMax1Row]
	{
		if _f.funcs.HasOuterCols(right) {
			_max1Row, _ := right.(*memo.Max1RowExpr)
			if _max1Row != nil {
				input := _max1Row.Input
				errorText := _max1Row.ErrorText
				if len(on) == 0 {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateMax1Row) {
						newLeft := _f.funcs.EnsureKey(left)
						_expr := _f.ConstructProject(
							_f.ConstructEnsureDistinctOn(
								_f.ConstructLeftJoin(
									newLeft,
									input,
									memo.EmptyFiltersExpr,
									private,
								),
								_f.funcs.MakeAggCols(opt.ConstAggOp, _f.funcs.UnionCols(_f.funcs.NonKeyCols(newLeft), _f.funcs.OutputCols(input))),
								_f.funcs.MakeErrorOnDupGrouping(_f.funcs.KeyCols(newLeft), _f.funcs.EmptyOrdering(), errorText),
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols2(left, _max1Row),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateMax1Row, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructLeftJoin(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructLeftJoin(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructLeftJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructLeftJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructLeftJoin(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					rightCols := _f.funcs.OutputCols(right)
					if !_f.funcs.IsBoundBy(item, rightCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinRight) {
								_expr := _f.ConstructLeftJoin(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, rightCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinRight, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapEqualityIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				leftCols := _f.funcs.OutputCols(left)
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.CanMapJoinOpEqualities(on, leftCols, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.MapEqualityIntoJoinLeftAndRight) {
						_expr := _f.ConstructLeftJoin(
							left,
							right,
							_f.funcs.MapJoinOpEqualities(on, leftCols, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.MapEqualityIntoJoinLeftAndRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.IsBoundBy(item, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinRight) {
						_expr := _f.ConstructLeftJoin(
							left,
							_f.ConstructSelect(
								right,
								_f.funcs.ExtractBoundConditions(on, rightCols),
							),
							_f.funcs.ExtractUnboundConditions(on, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifyLeftJoin]
	{
		if _f.funcs.JoinFiltersMatchAllLeftRows(left, right, on) {
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyLeftJoin) {
				_expr := _f.funcs.ConstructNonLeftJoin(opt.LeftJoinOp, left, right, on, private).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyLeftJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [HoistJoinProjectRight]
	{
		_project, _ := right.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			if len(projections) == 0 {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinProjectRight) {
					_expr := _f.ConstructProject(
						_f.ConstructLeftJoin(
							left,
							input,
							on,
							private,
						),
						projections,
						_f.funcs.OutputCols2(left, _project),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinProjectRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [HoistJoinProjectLeft]
	{
		_project, _ := left.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			if len(projections) == 0 {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinProjectLeft) {
					_expr := _f.ConstructProject(
						_f.ConstructLeftJoin(
							input,
							right,
							on,
							private,
						),
						projections,
						_f.funcs.OutputCols2(_project, right),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinProjectLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructLeftJoin(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ExtractJoinComparisons]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				for i := range on {
					item := &on[i]
					if item.Condition.Op() == opt.EqOp || item.Condition.Op() == opt.LtOp || item.Condition.Op() == opt.LeOp || item.Condition.Op() == opt.GtOp || item.Condition.Op() == opt.GeOp {
						a := item.Condition.Child(0).(opt.ScalarExpr)
						if !(opt.IsConstValueOp(a)) {
							b := item.Condition.Child(1).(opt.ScalarExpr)
							if !(opt.IsConstValueOp(b)) {
								if _f.funcs.CanExtractJoinComparison(a, b, _f.funcs.OutputCols(left), _f.funcs.OutputCols(right)) {
									private := joinPrivate
									if _f.matchedRule == nil || _f.matchedRule(opt.ExtractJoinComparisons) {
										_expr := _f.funcs.ExtractJoinComparison(opt.LeftJoinOp, left, right, on, item, private).(memo.RelExpr)
										if _f.appliedRule != nil {
											_f.appliedRule(opt.ExtractJoinComparisons, nil, _expr)
										}
										_f.constructorStackDepth--
										return _expr
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [RemoveJoinNotNullCondition]
	{
		for i := range on {
			item := &on[i]
			_isNot, _ := item.Condition.(*memo.IsNotExpr)
			if _isNot != nil {
				_variable, _ := _isNot.Left.(*memo.VariableExpr)
				if _variable != nil {
					col := _variable.Col
					if _f.funcs.IsColNotNull2(col, left, right) {
						_null, _ := _isNot.Right.(*memo.NullExpr)
						if _null != nil {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.RemoveJoinNotNullCondition) {
								_expr := _f.ConstructLeftJoin(
									left,
									right,
									_f.funcs.RemoveFiltersItem(on, item),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.RemoveJoinNotNullCondition, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [HoistJoinSubquery]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.HasHoistableSubquery(item) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinSubquery) {
					_expr := _f.funcs.HoistJoinSubquery(opt.LeftJoinOp, left, right, on, private).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinSubquery, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [RejectNullsUnderJoinRight]
	{
		rejectCols := _f.funcs.RejectNullCols(right)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinRight) {
					_expr := _f.ConstructLeftJoin(
						left,
						_f.ConstructSelect(
							right,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeLeftJoin(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRightJoin constructs an expression for the RightJoin operator.
func (_f *Factory) ConstructRightJoin(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [CommuteRightJoin]
	{
		private := joinPrivate
		if _f.matchedRule == nil || _f.matchedRule(opt.CommuteRightJoin) {
			_expr := _f.ConstructLeftJoin(
				right,
				left,
				on,
				_f.funcs.CommuteJoinFlags(private),
			)
			if _f.appliedRule != nil {
				_f.appliedRule(opt.CommuteRightJoin, nil, _expr)
			}
			_f.constructorStackDepth--
			return _expr
		}
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructRightJoin(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructRightJoin(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructRightJoin(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructRightJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructRightJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructRightJoin(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructRightJoin(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ExtractJoinComparisons]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				for i := range on {
					item := &on[i]
					if item.Condition.Op() == opt.EqOp || item.Condition.Op() == opt.LtOp || item.Condition.Op() == opt.LeOp || item.Condition.Op() == opt.GtOp || item.Condition.Op() == opt.GeOp {
						a := item.Condition.Child(0).(opt.ScalarExpr)
						if !(opt.IsConstValueOp(a)) {
							b := item.Condition.Child(1).(opt.ScalarExpr)
							if !(opt.IsConstValueOp(b)) {
								if _f.funcs.CanExtractJoinComparison(a, b, _f.funcs.OutputCols(left), _f.funcs.OutputCols(right)) {
									private := joinPrivate
									if _f.matchedRule == nil || _f.matchedRule(opt.ExtractJoinComparisons) {
										_expr := _f.funcs.ExtractJoinComparison(opt.RightJoinOp, left, right, on, item, private).(memo.RelExpr)
										if _f.appliedRule != nil {
											_f.appliedRule(opt.ExtractJoinComparisons, nil, _expr)
										}
										_f.constructorStackDepth--
										return _expr
									}
								}
							}
						}
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeRightJoin(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFullJoin constructs an expression for the FullJoin operator.
func (_f *Factory) ConstructFullJoin(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructFullJoin(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructFullJoin(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructFullJoin(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructFullJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructFullJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructFullJoin(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifyLeftJoin]
	{
		if _f.funcs.JoinFiltersMatchAllLeftRows(left, right, on) {
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyLeftJoin) {
				_expr := _f.funcs.ConstructNonLeftJoin(opt.FullJoinOp, left, right, on, private).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyLeftJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyRightJoin]
	{
		if _f.funcs.JoinFiltersMatchAllLeftRows(right, left, on) {
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyRightJoin) {
				_expr := _f.ConstructLeftJoin(
					left,
					right,
					on,
					private,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyRightJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructFullJoin(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ExtractJoinComparisons]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				for i := range on {
					item := &on[i]
					if item.Condition.Op() == opt.EqOp || item.Condition.Op() == opt.LtOp || item.Condition.Op() == opt.LeOp || item.Condition.Op() == opt.GtOp || item.Condition.Op() == opt.GeOp {
						a := item.Condition.Child(0).(opt.ScalarExpr)
						if !(opt.IsConstValueOp(a)) {
							b := item.Condition.Child(1).(opt.ScalarExpr)
							if !(opt.IsConstValueOp(b)) {
								if _f.funcs.CanExtractJoinComparison(a, b, _f.funcs.OutputCols(left), _f.funcs.OutputCols(right)) {
									private := joinPrivate
									if _f.matchedRule == nil || _f.matchedRule(opt.ExtractJoinComparisons) {
										_expr := _f.funcs.ExtractJoinComparison(opt.FullJoinOp, left, right, on, item, private).(memo.RelExpr)
										if _f.appliedRule != nil {
											_f.appliedRule(opt.ExtractJoinComparisons, nil, _expr)
										}
										_f.constructorStackDepth--
										return _expr
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [RemoveJoinNotNullCondition]
	{
		for i := range on {
			item := &on[i]
			_isNot, _ := item.Condition.(*memo.IsNotExpr)
			if _isNot != nil {
				_variable, _ := _isNot.Left.(*memo.VariableExpr)
				if _variable != nil {
					col := _variable.Col
					if _f.funcs.IsColNotNull2(col, left, right) {
						_null, _ := _isNot.Right.(*memo.NullExpr)
						if _null != nil {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.RemoveJoinNotNullCondition) {
								_expr := _f.ConstructFullJoin(
									left,
									right,
									_f.funcs.RemoveFiltersItem(on, item),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.RemoveJoinNotNullCondition, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeFullJoin(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSemiJoin constructs an expression for the SemiJoin operator.
func (_f *Factory) ConstructSemiJoin(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructSemiJoin(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		if _f.funcs.HasOuterCols(right) {
			_select, _ := right.(*memo.SelectExpr)
			if _select != nil {
				input := _select.Input
				filters := _select.Filters
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSelect) {
					_expr := _f.ConstructSemiJoin(
						left,
						input,
						_f.funcs.ConcatFilters(on, filters),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateSelect, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateInnerJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.InnerJoinOp || right.Op() == opt.InnerJoinApplyOp {
				innerLeft := right.Child(0).(memo.RelExpr)
				innerRight := right.Child(1).(memo.RelExpr)
				innerOn := *right.Child(2).(*memo.FiltersExpr)
				if !_f.funcs.FiltersBoundBy(innerOn, _f.funcs.OutputCols2(innerLeft, innerRight)) {
					innerPrivate := right.Private().(*memo.JoinPrivate)
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerJoin) {
						_expr := _f.ConstructSemiJoin(
							left,
							_f.DynamicConstruct(
								right.Op(),
								innerLeft,
								innerRight,
								&memo.EmptyFiltersExpr,
								innerPrivate,
							).(memo.RelExpr),
							_f.funcs.ConcatFilters(on, innerOn),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateSemiJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if _f.funcs.CanHaveZeroRows(right) {
				if right.Op() == opt.GroupByOp || right.Op() == opt.DistinctOnOp || right.Op() == opt.ProjectOp || right.Op() == opt.ProjectSetOp || right.Op() == opt.WindowOp {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSemiJoin) {
						newLeft := _f.funcs.EnsureKey(left)
						_expr := _f.ConstructProject(
							_f.ConstructGroupBy(
								_f.ConstructInnerJoinApply(
									newLeft,
									right,
									on,
									private,
								),
								_f.funcs.MakeAggCols(opt.ConstAggOp, _f.funcs.NonKeyCols(newLeft)),
								_f.funcs.MakeGrouping(_f.funcs.KeyCols(newLeft), _f.funcs.EmptyOrdering()),
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols(left),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateSemiJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructSemiJoin(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructSemiJoin(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructSemiJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructSemiJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructSemiJoin(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				for i := range on {
					item := &on[i]
					_match := false
					_eq, _ := item.Condition.(*memo.EqExpr)
					if _eq != nil {
						_variable, _ := _eq.Left.(*memo.VariableExpr)
						if _variable != nil {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								_match = true
							}
						}
					}

					if !_match {
						leftCols := _f.funcs.OutputCols(left)
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, leftCols, equivFD) {
							rightCols := _f.funcs.OutputCols(right)
							if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinLeftAndRight) {
									_expr := _f.ConstructSemiJoin(
										_f.ConstructSelect(
											left,
											memo.FiltersExpr{
												_f.ConstructFiltersItem(
													_f.funcs.MapJoinOpFilter(item, leftCols, equivFD),
												),
											},
										),
										_f.ConstructSelect(
											right,
											memo.FiltersExpr{
												_f.ConstructFiltersItem(
													_f.funcs.MapJoinOpFilter(item, rightCols, equivFD),
												),
											},
										),
										_f.funcs.RemoveFiltersItem(on, item),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.PushFilterIntoJoinLeftAndRight, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinLeft]
	{
		if !_f.funcs.HasOuterCols(left) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					leftCols := _f.funcs.OutputCols(left)
					if !_f.funcs.IsBoundBy(item, leftCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, leftCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinLeft) {
								_expr := _f.ConstructSemiJoin(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, leftCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinLeft, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					rightCols := _f.funcs.OutputCols(right)
					if !_f.funcs.IsBoundBy(item, rightCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinRight) {
								_expr := _f.ConstructSemiJoin(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, rightCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinRight, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapEqualityIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				leftCols := _f.funcs.OutputCols(left)
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.CanMapJoinOpEqualities(on, leftCols, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.MapEqualityIntoJoinLeftAndRight) {
						_expr := _f.ConstructSemiJoin(
							left,
							right,
							_f.funcs.MapJoinOpEqualities(on, leftCols, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.MapEqualityIntoJoinLeftAndRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinLeft]
	{
		if !_f.funcs.HasOuterCols(left) {
			for i := range on {
				item := &on[i]
				leftCols := _f.funcs.OutputCols(left)
				if _f.funcs.IsBoundBy(item, leftCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinLeft) {
						_expr := _f.ConstructSemiJoin(
							_f.ConstructSelect(
								left,
								_f.funcs.ExtractBoundConditions(on, leftCols),
							),
							right,
							_f.funcs.ExtractUnboundConditions(on, leftCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinLeft, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.IsBoundBy(item, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinRight) {
						_expr := _f.ConstructSemiJoin(
							left,
							_f.ConstructSelect(
								right,
								_f.funcs.ExtractBoundConditions(on, rightCols),
							),
							_f.funcs.ExtractUnboundConditions(on, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [EliminateSemiJoin]
	{
		if _f.funcs.JoinFiltersMatchAllLeftRows(left, right, on) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateSemiJoin) {
				_expr := left
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateSemiJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyZeroCardinalitySemiJoin]
	{
		if _f.funcs.HasZeroRows(right) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyZeroCardinalitySemiJoin) {
				_expr := _f.funcs.ConstructEmptyValues(_f.funcs.OutputCols(left)).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyZeroCardinalitySemiJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructSemiJoin(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ExtractJoinComparisons]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				for i := range on {
					item := &on[i]
					if item.Condition.Op() == opt.EqOp || item.Condition.Op() == opt.LtOp || item.Condition.Op() == opt.LeOp || item.Condition.Op() == opt.GtOp || item.Condition.Op() == opt.GeOp {
						a := item.Condition.Child(0).(opt.ScalarExpr)
						if !(opt.IsConstValueOp(a)) {
							b := item.Condition.Child(1).(opt.ScalarExpr)
							if !(opt.IsConstValueOp(b)) {
								if _f.funcs.CanExtractJoinComparison(a, b, _f.funcs.OutputCols(left), _f.funcs.OutputCols(right)) {
									private := joinPrivate
									if _f.matchedRule == nil || _f.matchedRule(opt.ExtractJoinComparisons) {
										_expr := _f.funcs.ExtractJoinComparison(opt.SemiJoinOp, left, right, on, item, private).(memo.RelExpr)
										if _f.appliedRule != nil {
											_f.appliedRule(opt.ExtractJoinComparisons, nil, _expr)
										}
										_f.constructorStackDepth--
										return _expr
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PruneSemiAntiJoinRightCols]
	{
		private := joinPrivate
		needed := _f.funcs.FilterOuterCols(on)
		if _f.funcs.CanPruneCols(right, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneSemiAntiJoinRightCols) {
				_expr := _f.ConstructSemiJoin(
					left,
					_f.funcs.PruneCols(right, needed),
					on,
					private,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneSemiAntiJoinRightCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [HoistJoinSubquery]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.HasHoistableSubquery(item) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinSubquery) {
					_expr := _f.funcs.HoistJoinSubquery(opt.SemiJoinOp, left, right, on, private).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinSubquery, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [RejectNullsUnderJoinLeft]
	{
		rejectCols := _f.funcs.RejectNullCols(left)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinLeft) {
					_expr := _f.ConstructSemiJoin(
						_f.ConstructSelect(
							left,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						right,
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [RejectNullsUnderJoinRight]
	{
		rejectCols := _f.funcs.RejectNullCols(right)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinRight) {
					_expr := _f.ConstructSemiJoin(
						left,
						_f.ConstructSelect(
							right,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeSemiJoin(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAntiJoin constructs an expression for the AntiJoin operator.
func (_f *Factory) ConstructAntiJoin(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructAntiJoin(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		if _f.funcs.HasOuterCols(right) {
			_select, _ := right.(*memo.SelectExpr)
			if _select != nil {
				input := _select.Input
				filters := _select.Filters
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSelect) {
					_expr := _f.ConstructAntiJoin(
						left,
						input,
						_f.funcs.ConcatFilters(on, filters),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateSelect, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateInnerJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.InnerJoinOp || right.Op() == opt.InnerJoinApplyOp {
				innerLeft := right.Child(0).(memo.RelExpr)
				innerRight := right.Child(1).(memo.RelExpr)
				innerOn := *right.Child(2).(*memo.FiltersExpr)
				if !_f.funcs.FiltersBoundBy(innerOn, _f.funcs.OutputCols2(innerLeft, innerRight)) {
					innerPrivate := right.Private().(*memo.JoinPrivate)
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerJoin) {
						_expr := _f.ConstructAntiJoin(
							left,
							_f.DynamicConstruct(
								right.Op(),
								innerLeft,
								innerRight,
								&memo.EmptyFiltersExpr,
								innerPrivate,
							).(memo.RelExpr),
							_f.funcs.ConcatFilters(on, innerOn),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructAntiJoin(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructAntiJoin(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructAntiJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructAntiJoin(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructAntiJoin(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					rightCols := _f.funcs.OutputCols(right)
					if !_f.funcs.IsBoundBy(item, rightCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinRight) {
								_expr := _f.ConstructAntiJoin(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, rightCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinRight, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapEqualityIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				leftCols := _f.funcs.OutputCols(left)
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.CanMapJoinOpEqualities(on, leftCols, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.MapEqualityIntoJoinLeftAndRight) {
						_expr := _f.ConstructAntiJoin(
							left,
							right,
							_f.funcs.MapJoinOpEqualities(on, leftCols, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.MapEqualityIntoJoinLeftAndRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.IsBoundBy(item, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinRight) {
						_expr := _f.ConstructAntiJoin(
							left,
							_f.ConstructSelect(
								right,
								_f.funcs.ExtractBoundConditions(on, rightCols),
							),
							_f.funcs.ExtractUnboundConditions(on, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [EliminateAntiJoin]
	{
		if _f.funcs.HasZeroRows(right) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAntiJoin) {
				_expr := left
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateAntiJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyZeroCardinalityAntiJoin]
	{
		if !_f.funcs.CanHaveZeroRows(right) {
			if len(on) == 0 {
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyZeroCardinalityAntiJoin) {
					_expr := _f.funcs.ConstructEmptyValues(_f.funcs.OutputCols(left)).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyZeroCardinalityAntiJoin, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructAntiJoin(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ExtractJoinComparisons]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				for i := range on {
					item := &on[i]
					if item.Condition.Op() == opt.EqOp || item.Condition.Op() == opt.LtOp || item.Condition.Op() == opt.LeOp || item.Condition.Op() == opt.GtOp || item.Condition.Op() == opt.GeOp {
						a := item.Condition.Child(0).(opt.ScalarExpr)
						if !(opt.IsConstValueOp(a)) {
							b := item.Condition.Child(1).(opt.ScalarExpr)
							if !(opt.IsConstValueOp(b)) {
								if _f.funcs.CanExtractJoinComparison(a, b, _f.funcs.OutputCols(left), _f.funcs.OutputCols(right)) {
									private := joinPrivate
									if _f.matchedRule == nil || _f.matchedRule(opt.ExtractJoinComparisons) {
										_expr := _f.funcs.ExtractJoinComparison(opt.AntiJoinOp, left, right, on, item, private).(memo.RelExpr)
										if _f.appliedRule != nil {
											_f.appliedRule(opt.ExtractJoinComparisons, nil, _expr)
										}
										_f.constructorStackDepth--
										return _expr
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PruneSemiAntiJoinRightCols]
	{
		private := joinPrivate
		needed := _f.funcs.FilterOuterCols(on)
		if _f.funcs.CanPruneCols(right, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneSemiAntiJoinRightCols) {
				_expr := _f.ConstructAntiJoin(
					left,
					_f.funcs.PruneCols(right, needed),
					on,
					private,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneSemiAntiJoinRightCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [HoistJoinSubquery]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.HasHoistableSubquery(item) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinSubquery) {
					_expr := _f.funcs.HoistJoinSubquery(opt.AntiJoinOp, left, right, on, private).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinSubquery, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [RejectNullsUnderJoinRight]
	{
		rejectCols := _f.funcs.RejectNullCols(right)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinRight) {
					_expr := _f.ConstructAntiJoin(
						left,
						_f.ConstructSelect(
							right,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeAntiJoin(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIndexJoin constructs an expression for the IndexJoin operator.
// IndexJoin represents an inner join between an input expression and a primary
// index. It is a special case of LookupJoin where the input columns are the PK
// columns of the table we are looking up into, and every input row results in
// exactly one output row.
//
// IndexJoin operators are created from Scan operators (unlike lookup joins which
// are created from Join operators).
func (_f *Factory) ConstructIndexJoin(
	input memo.RelExpr,
	indexJoinPrivate *memo.IndexJoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeIndexJoin(input, indexJoinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLookupJoin constructs an expression for the LookupJoin operator.
// LookupJoin represents a join between an input expression and an index. The
// type of join is in the LookupJoinPrivate field.
func (_f *Factory) ConstructLookupJoin(
	input memo.RelExpr,
	on memo.FiltersExpr,
	lookupJoinPrivate *memo.LookupJoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeLookupJoin(input, on, lookupJoinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructInvertedJoin constructs an expression for the InvertedJoin operator.
// InvertedJoin represents a join between an input expression and an inverted
// index. The type of join is in the InvertedJoinPrivate field.
func (_f *Factory) ConstructInvertedJoin(
	input memo.RelExpr,
	on memo.FiltersExpr,
	invertedJoinPrivate *memo.InvertedJoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeInvertedJoin(input, on, invertedJoinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructMergeJoin constructs an expression for the MergeJoin operator.
// MergeJoin represents a join that is executed using merge-join.
// MergeOn is a scalar which contains the ON condition and merge-join ordering
// information; see the MergeOn scalar operator.
// It can be any type of join (identified in the MergeJoinPrivate field).
func (_f *Factory) ConstructMergeJoin(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	mergeJoinPrivate *memo.MergeJoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeMergeJoin(left, right, on, mergeJoinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructZigzagJoin constructs an expression for the ZigzagJoin operator.
// ZigzagJoin represents a join that is executed using the zigzag joiner.
// All fields except for the ON expression are stored in the private;
// since the zigzag joiner operates directly on indexes and doesn't
// support arbitrary inputs.
//
// TODO(itsbilal): Add support for representing multi-way zigzag joins.
func (_f *Factory) ConstructZigzagJoin(
	on memo.FiltersExpr,
	zigzagJoinPrivate *memo.ZigzagJoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeZigzagJoin(on, zigzagJoinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructInnerJoinApply constructs an expression for the InnerJoinApply operator.
// InnerJoinApply has the same join semantics as InnerJoin. However, unlike
// InnerJoin, it allows the right input to refer to columns projected by the
// left input.
func (_f *Factory) ConstructInnerJoinApply(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructInnerJoinApply(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.funcs.IsCorrelated(right, _f.funcs.OutputCols(left)) {
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.DecorrelateJoin) {
				_expr := _f.funcs.ConstructNonApplyJoin(opt.InnerJoinApplyOp, left, right, on, private).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.DecorrelateJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		if _f.funcs.HasOuterCols(right) {
			_select, _ := right.(*memo.SelectExpr)
			if _select != nil {
				input := _select.Input
				filters := _select.Filters
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSelect) {
					_expr := _f.ConstructInnerJoinApply(
						left,
						input,
						_f.funcs.ConcatFilters(on, filters),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateSelect, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateProject]
	{
		if _f.funcs.HasOuterCols(right) {
			_project, _ := right.(*memo.ProjectExpr)
			if _project != nil {
				input := _project.Input
				projections := _project.Projections
				passthrough := _project.Passthrough
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateProject) {
					_expr := _f.ConstructSelect(
						_f.ConstructProject(
							_f.ConstructInnerJoinApply(
								left,
								input,
								memo.EmptyFiltersExpr,
								private,
							),
							projections,
							_f.funcs.UnionCols(_f.funcs.OutputCols(left), passthrough),
						),
						on,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateInnerJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.InnerJoinOp || right.Op() == opt.InnerJoinApplyOp {
				innerLeft := right.Child(0).(memo.RelExpr)
				innerRight := right.Child(1).(memo.RelExpr)
				innerOn := *right.Child(2).(*memo.FiltersExpr)
				if !_f.funcs.FiltersBoundBy(innerOn, _f.funcs.OutputCols2(innerLeft, innerRight)) {
					innerPrivate := right.Private().(*memo.JoinPrivate)
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerJoin) {
						_expr := _f.ConstructInnerJoinApply(
							left,
							_f.DynamicConstruct(
								right.Op(),
								innerLeft,
								innerRight,
								&memo.EmptyFiltersExpr,
								innerPrivate,
							).(memo.RelExpr),
							_f.funcs.ConcatFilters(on, innerOn),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateInnerLeftJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			_leftJoin, _ := right.(*memo.LeftJoinExpr)
			if _leftJoin != nil {
				innerLeft := _leftJoin.Left
				innerRight := _leftJoin.Right
				innerOn := _leftJoin.On
				innerPrivate := &_leftJoin.JoinPrivate
				if _f.funcs.FiltersBoundBy(on, _f.funcs.OutputCols2(left, innerLeft)) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerLeftJoin) {
						_expr := _f.ConstructLeftJoinApply(
							_f.ConstructInnerJoinApply(
								left,
								innerLeft,
								on,
								innerPrivate,
							),
							innerRight,
							innerOn,
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerLeftJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateGroupBy]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.GroupByOp || right.Op() == opt.DistinctOnOp {
				input := right.Child(0).(memo.RelExpr)
				aggregations := *right.Child(1).(*memo.AggregationsExpr)
				groupingPrivate := right.Private().(*memo.GroupingPrivate)
				if _f.funcs.IsUnorderedGrouping(groupingPrivate) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateGroupBy) {
						newLeft := _f.funcs.EnsureKey(left)
						_arg := _f.funcs.AppendAggCols(aggregations, opt.ConstAggOp, _f.funcs.NonKeyCols(newLeft))
						_expr := _f.ConstructProject(
							_f.ConstructSelect(
								_f.DynamicConstruct(
									right.Op(),
									_f.ConstructInnerJoinApply(
										newLeft,
										input,
										memo.EmptyFiltersExpr,
										private,
									),
									&_arg,
									_f.funcs.AddColsToGrouping(groupingPrivate, _f.funcs.KeyCols(newLeft)),
								).(memo.RelExpr),
								on,
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols2(left, right),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateGroupBy, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateScalarGroupBy]
	{
		if _f.funcs.HasOuterCols(right) {
			_scalarGroupBy, _ := right.(*memo.ScalarGroupByExpr)
			if _scalarGroupBy != nil {
				input := _scalarGroupBy.Input
				aggregations := _scalarGroupBy.Aggregations
				groupingPrivate := &_scalarGroupBy.GroupingPrivate
				if _f.funcs.AggsCanBeDecorrelated(aggregations) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateScalarGroupBy) {
						leftWithKey := _f.funcs.EnsureKey(left)
						canaryCol := _f.funcs.EnsureCanaryCol(input, aggregations)
						rightWithCanary := _f.funcs.EnsureCanary(input, canaryCol)
						translatedAggs := _f.funcs.EnsureAggsCanIgnoreNulls(rightWithCanary, aggregations)
						_expr := _f.ConstructSelect(
							_f.ConstructProject(
								_f.funcs.TranslateNonIgnoreAggs(_f.ConstructGroupBy(
									_f.ConstructLeftJoinApply(
										leftWithKey,
										rightWithCanary,
										memo.EmptyFiltersExpr,
										private,
									),
									_f.funcs.AppendAggCols2(translatedAggs, opt.ConstAggOp, _f.funcs.NonKeyCols(leftWithKey), opt.AnyNotNullAggOp, _f.funcs.CanaryColSet(canaryCol)),
									_f.funcs.MakeGrouping(_f.funcs.KeyCols(leftWithKey), _f.funcs.ExtractGroupingOrdering(groupingPrivate)),
								), translatedAggs, rightWithCanary, aggregations, canaryCol),
								memo.EmptyProjectionsExpr,
								_f.funcs.OutputCols2(left, _scalarGroupBy),
							),
							on,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateScalarGroupBy, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateLimitOne]
	{
		if _f.funcs.HasOuterCols(right) {
			_limit, _ := right.(*memo.LimitExpr)
			if _limit != nil {
				input := _limit.Input
				_const, _ := _limit.Limit.(*memo.ConstExpr)
				if _const != nil {
					if _f.funcs.EqualsNumber(_const.Value, 1) {
						ordering := _limit.Ordering
						private := joinPrivate
						if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateLimitOne) {
							newLeft := _f.funcs.EnsureKey(left)
							_expr := _f.ConstructProject(
								_f.ConstructDistinctOn(
									_f.ConstructInnerJoinApply(
										newLeft,
										input,
										on,
										private,
									),
									_f.funcs.MakeAggCols2(opt.ConstAggOp, _f.funcs.NonKeyCols(newLeft), opt.FirstAggOp, _f.funcs.OutputCols(input)),
									_f.funcs.MakeGrouping(_f.funcs.KeyCols(newLeft), ordering),
								),
								memo.EmptyProjectionsExpr,
								_f.funcs.OutputCols2(left, _limit),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.TryDecorrelateLimitOne, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateLimit]
	{
		_limit, _ := right.(*memo.LimitExpr)
		if _limit != nil {
			input := _limit.Input
			_const, _ := _limit.Limit.(*memo.ConstExpr)
			if _const != nil {
				limit := _const.Value
				ordering := _limit.Ordering
				if _f.funcs.HasOuterCols(_limit) {
					if _f.funcs.IsGreaterThan(limit, tree.NewDInt(1)) {
						private := joinPrivate
						if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateLimit) {
							rowNum, rowNumCol := _f.funcs.MakeRowNumberWindowFunc()
							_expr := _f.ConstructSelect(
								_f.ConstructInnerJoinApply(
									left,
									_f.ConstructWindow(
										input,
										rowNum,
										_f.funcs.MakeWindowPrivate(_f.funcs.MakeEmptyColSet(), ordering),
									),
									on,
									private,
								),
								_f.funcs.LimitToRowNumberFilter(limit, rowNumCol),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.TryDecorrelateLimit, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateProjectSet]
	{
		_projectSet, _ := right.(*memo.ProjectSetExpr)
		if _projectSet != nil {
			input := _projectSet.Input
			zip := _projectSet.Zip
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateProjectSet) {
				_expr := _f.ConstructSelect(
					_f.ConstructProjectSet(
						_f.ConstructInnerJoinApply(
							left,
							input,
							memo.EmptyFiltersExpr,
							private,
						),
						zip,
					),
					on,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.TryDecorrelateProjectSet, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [TryDecorrelateWindow]
	{
		_window, _ := right.(*memo.WindowExpr)
		if _window != nil {
			input := _window.Input
			windows := _window.Windows
			private := &_window.WindowPrivate
			if _f.funcs.HasOuterCols(_window) {
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateWindow) {
					newLeft := _f.funcs.EnsureKey(left)
					_expr := _f.ConstructProject(
						_f.ConstructSelect(
							_f.ConstructWindow(
								_f.ConstructInnerJoinApply(
									newLeft,
									input,
									memo.EmptyFiltersExpr,
									joinPrivate,
								),
								windows,
								_f.funcs.AddColsToPartition(private, _f.funcs.KeyCols(newLeft)),
							),
							on,
						),
						memo.EmptyProjectionsExpr,
						_f.funcs.OutputCols2(left, _window),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateWindow, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateMax1Row]
	{
		if _f.funcs.HasOuterCols(right) {
			_max1Row, _ := right.(*memo.Max1RowExpr)
			if _max1Row != nil {
				input := _max1Row.Input
				errorText := _max1Row.ErrorText
				if len(on) == 0 {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateMax1Row) {
						newLeft := _f.funcs.EnsureKey(left)
						_expr := _f.ConstructProject(
							_f.ConstructEnsureDistinctOn(
								_f.ConstructInnerJoinApply(
									newLeft,
									input,
									memo.EmptyFiltersExpr,
									private,
								),
								_f.funcs.MakeAggCols(opt.ConstAggOp, _f.funcs.UnionCols(_f.funcs.NonKeyCols(newLeft), _f.funcs.OutputCols(input))),
								_f.funcs.MakeErrorOnDupGrouping(_f.funcs.KeyCols(newLeft), _f.funcs.EmptyOrdering(), errorText),
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols2(left, _max1Row),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateMax1Row, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructInnerJoinApply(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructInnerJoinApply(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructInnerJoinApply(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructInnerJoinApply(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructInnerJoinApply(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinLeft]
	{
		if !_f.funcs.HasOuterCols(left) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					leftCols := _f.funcs.OutputCols(left)
					if !_f.funcs.IsBoundBy(item, leftCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, leftCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinLeft) {
								_expr := _f.ConstructInnerJoinApply(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, leftCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinLeft, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					rightCols := _f.funcs.OutputCols(right)
					if !_f.funcs.IsBoundBy(item, rightCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinRight) {
								_expr := _f.ConstructInnerJoinApply(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, rightCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinRight, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapEqualityIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				leftCols := _f.funcs.OutputCols(left)
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.CanMapJoinOpEqualities(on, leftCols, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.MapEqualityIntoJoinLeftAndRight) {
						_expr := _f.ConstructInnerJoinApply(
							left,
							right,
							_f.funcs.MapJoinOpEqualities(on, leftCols, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.MapEqualityIntoJoinLeftAndRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinLeft]
	{
		if !_f.funcs.HasOuterCols(left) {
			for i := range on {
				item := &on[i]
				leftCols := _f.funcs.OutputCols(left)
				if _f.funcs.IsBoundBy(item, leftCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinLeft) {
						_expr := _f.ConstructInnerJoinApply(
							_f.ConstructSelect(
								left,
								_f.funcs.ExtractBoundConditions(on, leftCols),
							),
							right,
							_f.funcs.ExtractUnboundConditions(on, leftCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinLeft, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.IsBoundBy(item, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinRight) {
						_expr := _f.ConstructInnerJoinApply(
							left,
							_f.ConstructSelect(
								right,
								_f.funcs.ExtractBoundConditions(on, rightCols),
							),
							_f.funcs.ExtractUnboundConditions(on, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [EliminateJoinNoColsLeft]
	{
		if _f.funcs.ColsAreEmpty(_f.funcs.OutputCols(left)) {
			if _f.funcs.HasOneRow(left) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinNoColsLeft) {
					_expr := _f.ConstructSelect(
						right,
						on,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateJoinNoColsLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [EliminateJoinNoColsRight]
	{
		if _f.funcs.ColsAreEmpty(_f.funcs.OutputCols(right)) {
			if _f.funcs.HasOneRow(right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinNoColsRight) {
					_expr := _f.ConstructSelect(
						left,
						on,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateJoinNoColsRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [HoistJoinProjectRight]
	{
		_project, _ := right.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			if len(projections) == 0 {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinProjectRight) {
					_expr := _f.ConstructProject(
						_f.ConstructInnerJoinApply(
							left,
							input,
							on,
							private,
						),
						projections,
						_f.funcs.OutputCols2(left, _project),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinProjectRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [HoistJoinProjectLeft]
	{
		_project, _ := left.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			if len(projections) == 0 {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinProjectLeft) {
					_expr := _f.ConstructProject(
						_f.ConstructInnerJoinApply(
							input,
							right,
							on,
							private,
						),
						projections,
						_f.funcs.OutputCols2(_project, right),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinProjectLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructInnerJoinApply(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ProjectInnerJoinValues]
	{
		_values, _ := right.(*memo.ValuesExpr)
		if _values != nil {
			if _f.funcs.HasOneRow(_values) {
				if _f.matchedRule == nil || _f.matchedRule(opt.ProjectInnerJoinValues) {
					_expr := _f.ConstructSelect(
						_f.ConstructProject(
							left,
							_f.funcs.MakeProjectionsFromValues(_values),
							_f.funcs.OutputCols(left),
						),
						on,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.ProjectInnerJoinValues, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [RejectNullsUnderJoinLeft]
	{
		rejectCols := _f.funcs.RejectNullCols(left)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinLeft) {
					_expr := _f.ConstructInnerJoinApply(
						_f.ConstructSelect(
							left,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						right,
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [RejectNullsUnderJoinRight]
	{
		rejectCols := _f.funcs.RejectNullCols(right)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinRight) {
					_expr := _f.ConstructInnerJoinApply(
						left,
						_f.ConstructSelect(
							right,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeInnerJoinApply(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLeftJoinApply constructs an expression for the LeftJoinApply operator.
func (_f *Factory) ConstructLeftJoinApply(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [TryDecorrelateProjectInnerJoin]
	{
		_project, _ := right.(*memo.ProjectExpr)
		if _project != nil {
			join := _project.Input
			if join.Op() == opt.InnerJoinOp || join.Op() == opt.InnerJoinApplyOp {
				innerLeft := join.Child(0).(memo.RelExpr)
				innerRight := join.Child(1).(memo.RelExpr)
				innerOn := *join.Child(2).(*memo.FiltersExpr)
				if !_f.funcs.FiltersBoundBy(innerOn, _f.funcs.OutputCols2(innerLeft, innerRight)) {
					innerPrivate := join.Private().(*memo.JoinPrivate)
					projections := _project.Projections
					passthrough := _project.Passthrough
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateProjectInnerJoin) {
						_expr := _f.ConstructProject(
							_f.ConstructLeftJoinApply(
								left,
								_f.ConstructProject(
									_f.DynamicConstruct(
										join.Op(),
										innerLeft,
										innerRight,
										&memo.EmptyFiltersExpr,
										innerPrivate,
									).(memo.RelExpr),
									projections,
									_f.funcs.UnionCols(passthrough, _f.funcs.OutputCols(join)),
								),
								_f.funcs.ConcatFilters(on, innerOn),
								private,
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols2(left, _project),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateProjectInnerJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructLeftJoinApply(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.funcs.IsCorrelated(right, _f.funcs.OutputCols(left)) {
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.DecorrelateJoin) {
				_expr := _f.funcs.ConstructNonApplyJoin(opt.LeftJoinApplyOp, left, right, on, private).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.DecorrelateJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		if _f.funcs.HasOuterCols(right) {
			_select, _ := right.(*memo.SelectExpr)
			if _select != nil {
				input := _select.Input
				filters := _select.Filters
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSelect) {
					_expr := _f.ConstructLeftJoinApply(
						left,
						input,
						_f.funcs.ConcatFilters(on, filters),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateSelect, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateProjectSelect]
	{
		_project, _ := right.(*memo.ProjectExpr)
		if _project != nil {
			_select, _ := _project.Input.(*memo.SelectExpr)
			if _select != nil {
				selectInput := _select.Input
				filters := _select.Filters
				if !_f.funcs.FiltersBoundBy(filters, _f.funcs.OutputCols(selectInput)) {
					projections := _project.Projections
					passthrough := _project.Passthrough
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateProjectSelect) {
						_expr := _f.ConstructProject(
							_f.ConstructLeftJoinApply(
								left,
								_f.ConstructProject(
									selectInput,
									projections,
									_f.funcs.UnionCols(passthrough, _f.funcs.OutputCols(selectInput)),
								),
								_f.funcs.ConcatFilters(on, filters),
								private,
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols2(left, _project),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateProjectSelect, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateInnerJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.InnerJoinOp || right.Op() == opt.InnerJoinApplyOp {
				innerLeft := right.Child(0).(memo.RelExpr)
				innerRight := right.Child(1).(memo.RelExpr)
				innerOn := *right.Child(2).(*memo.FiltersExpr)
				if !_f.funcs.FiltersBoundBy(innerOn, _f.funcs.OutputCols2(innerLeft, innerRight)) {
					innerPrivate := right.Private().(*memo.JoinPrivate)
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerJoin) {
						_expr := _f.ConstructLeftJoinApply(
							left,
							_f.DynamicConstruct(
								right.Op(),
								innerLeft,
								innerRight,
								&memo.EmptyFiltersExpr,
								innerPrivate,
							).(memo.RelExpr),
							_f.funcs.ConcatFilters(on, innerOn),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateLimitOne]
	{
		if _f.funcs.HasOuterCols(right) {
			_limit, _ := right.(*memo.LimitExpr)
			if _limit != nil {
				input := _limit.Input
				_const, _ := _limit.Limit.(*memo.ConstExpr)
				if _const != nil {
					if _f.funcs.EqualsNumber(_const.Value, 1) {
						ordering := _limit.Ordering
						private := joinPrivate
						if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateLimitOne) {
							newLeft := _f.funcs.EnsureKey(left)
							_expr := _f.ConstructProject(
								_f.ConstructDistinctOn(
									_f.ConstructLeftJoinApply(
										newLeft,
										input,
										on,
										private,
									),
									_f.funcs.MakeAggCols2(opt.ConstAggOp, _f.funcs.NonKeyCols(newLeft), opt.FirstAggOp, _f.funcs.OutputCols(input)),
									_f.funcs.MakeGrouping(_f.funcs.KeyCols(newLeft), ordering),
								),
								memo.EmptyProjectionsExpr,
								_f.funcs.OutputCols2(left, _limit),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.TryDecorrelateLimitOne, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [TryDecorrelateMax1Row]
	{
		if _f.funcs.HasOuterCols(right) {
			_max1Row, _ := right.(*memo.Max1RowExpr)
			if _max1Row != nil {
				input := _max1Row.Input
				errorText := _max1Row.ErrorText
				if len(on) == 0 {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateMax1Row) {
						newLeft := _f.funcs.EnsureKey(left)
						_expr := _f.ConstructProject(
							_f.ConstructEnsureDistinctOn(
								_f.ConstructLeftJoinApply(
									newLeft,
									input,
									memo.EmptyFiltersExpr,
									private,
								),
								_f.funcs.MakeAggCols(opt.ConstAggOp, _f.funcs.UnionCols(_f.funcs.NonKeyCols(newLeft), _f.funcs.OutputCols(input))),
								_f.funcs.MakeErrorOnDupGrouping(_f.funcs.KeyCols(newLeft), _f.funcs.EmptyOrdering(), errorText),
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols2(left, _max1Row),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateMax1Row, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructLeftJoinApply(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructLeftJoinApply(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructLeftJoinApply(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructLeftJoinApply(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructLeftJoinApply(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					rightCols := _f.funcs.OutputCols(right)
					if !_f.funcs.IsBoundBy(item, rightCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinRight) {
								_expr := _f.ConstructLeftJoinApply(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, rightCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinRight, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapEqualityIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				leftCols := _f.funcs.OutputCols(left)
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.CanMapJoinOpEqualities(on, leftCols, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.MapEqualityIntoJoinLeftAndRight) {
						_expr := _f.ConstructLeftJoinApply(
							left,
							right,
							_f.funcs.MapJoinOpEqualities(on, leftCols, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.MapEqualityIntoJoinLeftAndRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.IsBoundBy(item, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinRight) {
						_expr := _f.ConstructLeftJoinApply(
							left,
							_f.ConstructSelect(
								right,
								_f.funcs.ExtractBoundConditions(on, rightCols),
							),
							_f.funcs.ExtractUnboundConditions(on, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifyLeftJoin]
	{
		if _f.funcs.JoinFiltersMatchAllLeftRows(left, right, on) {
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyLeftJoin) {
				_expr := _f.funcs.ConstructNonLeftJoin(opt.LeftJoinApplyOp, left, right, on, private).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyLeftJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [HoistJoinProjectRight]
	{
		_project, _ := right.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			if len(projections) == 0 {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinProjectRight) {
					_expr := _f.ConstructProject(
						_f.ConstructLeftJoinApply(
							left,
							input,
							on,
							private,
						),
						projections,
						_f.funcs.OutputCols2(left, _project),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinProjectRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [HoistJoinProjectLeft]
	{
		_project, _ := left.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			if len(projections) == 0 {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistJoinProjectLeft) {
					_expr := _f.ConstructProject(
						_f.ConstructLeftJoinApply(
							input,
							right,
							on,
							private,
						),
						projections,
						_f.funcs.OutputCols2(_project, right),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistJoinProjectLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructLeftJoinApply(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [RejectNullsUnderJoinRight]
	{
		rejectCols := _f.funcs.RejectNullCols(right)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinRight) {
					_expr := _f.ConstructLeftJoinApply(
						left,
						_f.ConstructSelect(
							right,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeLeftJoinApply(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSemiJoinApply constructs an expression for the SemiJoinApply operator.
func (_f *Factory) ConstructSemiJoinApply(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructSemiJoinApply(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.funcs.IsCorrelated(right, _f.funcs.OutputCols(left)) {
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.DecorrelateJoin) {
				_expr := _f.funcs.ConstructNonApplyJoin(opt.SemiJoinApplyOp, left, right, on, private).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.DecorrelateJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		if _f.funcs.HasOuterCols(right) {
			_select, _ := right.(*memo.SelectExpr)
			if _select != nil {
				input := _select.Input
				filters := _select.Filters
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSelect) {
					_expr := _f.ConstructSemiJoinApply(
						left,
						input,
						_f.funcs.ConcatFilters(on, filters),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateSelect, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateInnerJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.InnerJoinOp || right.Op() == opt.InnerJoinApplyOp {
				innerLeft := right.Child(0).(memo.RelExpr)
				innerRight := right.Child(1).(memo.RelExpr)
				innerOn := *right.Child(2).(*memo.FiltersExpr)
				if !_f.funcs.FiltersBoundBy(innerOn, _f.funcs.OutputCols2(innerLeft, innerRight)) {
					innerPrivate := right.Private().(*memo.JoinPrivate)
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerJoin) {
						_expr := _f.ConstructSemiJoinApply(
							left,
							_f.DynamicConstruct(
								right.Op(),
								innerLeft,
								innerRight,
								&memo.EmptyFiltersExpr,
								innerPrivate,
							).(memo.RelExpr),
							_f.funcs.ConcatFilters(on, innerOn),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [TryDecorrelateSemiJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if _f.funcs.CanHaveZeroRows(right) {
				if right.Op() == opt.GroupByOp || right.Op() == opt.DistinctOnOp || right.Op() == opt.ProjectOp || right.Op() == opt.ProjectSetOp || right.Op() == opt.WindowOp {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSemiJoin) {
						newLeft := _f.funcs.EnsureKey(left)
						_expr := _f.ConstructProject(
							_f.ConstructGroupBy(
								_f.ConstructInnerJoinApply(
									newLeft,
									right,
									on,
									private,
								),
								_f.funcs.MakeAggCols(opt.ConstAggOp, _f.funcs.NonKeyCols(newLeft)),
								_f.funcs.MakeGrouping(_f.funcs.KeyCols(newLeft), _f.funcs.EmptyOrdering()),
							),
							memo.EmptyProjectionsExpr,
							_f.funcs.OutputCols(left),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateSemiJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructSemiJoinApply(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructSemiJoinApply(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructSemiJoinApply(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructSemiJoinApply(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructSemiJoinApply(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinLeft]
	{
		if !_f.funcs.HasOuterCols(left) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					leftCols := _f.funcs.OutputCols(left)
					if !_f.funcs.IsBoundBy(item, leftCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, leftCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinLeft) {
								_expr := _f.ConstructSemiJoinApply(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, leftCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinLeft, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					rightCols := _f.funcs.OutputCols(right)
					if !_f.funcs.IsBoundBy(item, rightCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinRight) {
								_expr := _f.ConstructSemiJoinApply(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, rightCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinRight, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapEqualityIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				leftCols := _f.funcs.OutputCols(left)
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.CanMapJoinOpEqualities(on, leftCols, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.MapEqualityIntoJoinLeftAndRight) {
						_expr := _f.ConstructSemiJoinApply(
							left,
							right,
							_f.funcs.MapJoinOpEqualities(on, leftCols, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.MapEqualityIntoJoinLeftAndRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinLeft]
	{
		if !_f.funcs.HasOuterCols(left) {
			for i := range on {
				item := &on[i]
				leftCols := _f.funcs.OutputCols(left)
				if _f.funcs.IsBoundBy(item, leftCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinLeft) {
						_expr := _f.ConstructSemiJoinApply(
							_f.ConstructSelect(
								left,
								_f.funcs.ExtractBoundConditions(on, leftCols),
							),
							right,
							_f.funcs.ExtractUnboundConditions(on, leftCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinLeft, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.IsBoundBy(item, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinRight) {
						_expr := _f.ConstructSemiJoinApply(
							left,
							_f.ConstructSelect(
								right,
								_f.funcs.ExtractBoundConditions(on, rightCols),
							),
							_f.funcs.ExtractUnboundConditions(on, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [EliminateSemiJoin]
	{
		if _f.funcs.JoinFiltersMatchAllLeftRows(left, right, on) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateSemiJoin) {
				_expr := left
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateSemiJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyZeroCardinalitySemiJoin]
	{
		if _f.funcs.HasZeroRows(right) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyZeroCardinalitySemiJoin) {
				_expr := _f.funcs.ConstructEmptyValues(_f.funcs.OutputCols(left)).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyZeroCardinalitySemiJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructSemiJoinApply(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PruneSemiAntiJoinRightCols]
	{
		private := joinPrivate
		needed := _f.funcs.FilterOuterCols(on)
		if _f.funcs.CanPruneCols(right, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneSemiAntiJoinRightCols) {
				_expr := _f.ConstructSemiJoinApply(
					left,
					_f.funcs.PruneCols(right, needed),
					on,
					private,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneSemiAntiJoinRightCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [RejectNullsUnderJoinLeft]
	{
		rejectCols := _f.funcs.RejectNullCols(left)
		if !_f.funcs.ColsAreEmpty(rejectCols) {
			nullRejectedCols := _f.funcs.IntersectionCols(rejectCols, _f.funcs.GetNullRejectedCols(on))
			if !_f.funcs.ColsAreEmpty(nullRejectedCols) {
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.RejectNullsUnderJoinLeft) {
					_expr := _f.ConstructSemiJoinApply(
						_f.ConstructSelect(
							left,
							_f.funcs.MakeNullRejectFilters(nullRejectedCols),
						),
						right,
						on,
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.RejectNullsUnderJoinLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeSemiJoinApply(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAntiJoinApply constructs an expression for the AntiJoinApply operator.
func (_f *Factory) ConstructAntiJoinApply(
	left memo.RelExpr,
	right memo.RelExpr,
	on memo.FiltersExpr,
	joinPrivate *memo.JoinPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyJoinFilters]
	{
		for i := range on {
			item := &on[i]
			if item.Condition.Op() == opt.AndOp || item.Condition.Op() == opt.TrueOp || item.Condition.Op() == opt.FalseOp || item.Condition.Op() == opt.NullOp || item.Condition.Op() == opt.OrOp || item.Condition.Op() == opt.IsOp {
				if !_f.funcs.IsUnsimplifiableOr(item) {
					if !_f.funcs.IsUnsimplifiableIs(item) {
						if !_f.funcs.IsContradiction(item) {
							if !_f.funcs.IsFilterFalse(on) {
								private := joinPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinFilters) {
									_expr := _f.ConstructAntiJoinApply(
										left,
										right,
										_f.funcs.SimplifyFilters(on),
										private,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.SimplifyJoinFilters, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [DecorrelateJoin]
	{
		if !_f.funcs.IsCorrelated(right, _f.funcs.OutputCols(left)) {
			private := joinPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.DecorrelateJoin) {
				_expr := _f.funcs.ConstructNonApplyJoin(opt.AntiJoinApplyOp, left, right, on, private).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.DecorrelateJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [TryDecorrelateSelect]
	{
		if _f.funcs.HasOuterCols(right) {
			_select, _ := right.(*memo.SelectExpr)
			if _select != nil {
				input := _select.Input
				filters := _select.Filters
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateSelect) {
					_expr := _f.ConstructAntiJoinApply(
						left,
						input,
						_f.funcs.ConcatFilters(on, filters),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.TryDecorrelateSelect, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [TryDecorrelateInnerJoin]
	{
		if _f.funcs.HasOuterCols(right) {
			if right.Op() == opt.InnerJoinOp || right.Op() == opt.InnerJoinApplyOp {
				innerLeft := right.Child(0).(memo.RelExpr)
				innerRight := right.Child(1).(memo.RelExpr)
				innerOn := *right.Child(2).(*memo.FiltersExpr)
				if !_f.funcs.FiltersBoundBy(innerOn, _f.funcs.OutputCols2(innerLeft, innerRight)) {
					innerPrivate := right.Private().(*memo.JoinPrivate)
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.TryDecorrelateInnerJoin) {
						_expr := _f.ConstructAntiJoinApply(
							left,
							_f.DynamicConstruct(
								right.Op(),
								innerLeft,
								innerRight,
								&memo.EmptyFiltersExpr,
								innerPrivate,
							).(memo.RelExpr),
							_f.funcs.ConcatFilters(on, innerOn),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.TryDecorrelateInnerJoin, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeJoinAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_any, _ := item.Condition.(*memo.AnyExpr)
			if _any != nil {
				anyInput := _any.Input
				scalar := _any.Scalar
				anyPrivate := &_any.SubqueryPrivate
				private := joinPrivate
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinAnyFilter) {
					_expr := _f.ConstructAntiJoinApply(
						left,
						right,
						_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructExists(
							_f.ConstructSelect(
								anyInput,
								memo.FiltersExpr{
									_f.ConstructFiltersItem(
										_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
									),
								},
							),
							anyPrivate,
						)),
						private,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeJoinAnyFilter, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeJoinNotAnyFilter]
	{
		for i := range on {
			item := &on[i]
			_not, _ := item.Condition.(*memo.NotExpr)
			if _not != nil {
				_any, _ := _not.Input.(*memo.AnyExpr)
				if _any != nil {
					anyInput := _any.Input
					scalar := _any.Scalar
					anyPrivate := &_any.SubqueryPrivate
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeJoinNotAnyFilter) {
						_expr := _f.ConstructAntiJoinApply(
							left,
							right,
							_f.funcs.ReplaceFiltersItem(on, item, _f.ConstructNot(
								_f.ConstructExists(
									_f.ConstructSelect(
										anyInput,
										memo.FiltersExpr{
											_f.ConstructFiltersItem(
												_f.ConstructIsNot(
													_f.funcs.ConstructAnyCondition(anyInput, scalar, anyPrivate),
													_f.ConstructFalse(),
												),
											),
										},
									),
									anyPrivate,
								),
							)),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.NormalizeJoinNotAnyFilter, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [InlineJoinConstantsLeft]
	{
		constCols := _f.funcs.FindInlinableConstants(left)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsLeft) {
							_expr := _f.ConstructAntiJoinApply(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, left, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [InlineJoinConstantsRight]
	{
		constCols := _f.funcs.FindInlinableConstants(right)
		if !_f.funcs.ColsAreEmpty(constCols) {
			for i := range on {
				item := &on[i]
				if _f.funcs.ColsIntersect(_f.funcs.OuterCols(item), constCols) {
					private := joinPrivate
					if _f.funcs.NoJoinHints(private) {
						if _f.matchedRule == nil || _f.matchedRule(opt.InlineJoinConstantsRight) {
							_expr := _f.ConstructAntiJoinApply(
								left,
								right,
								_f.funcs.InlineFilterConstants(on, right, constCols),
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.InlineJoinConstantsRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [DetectJoinContradiction]
	{
		for i := range on {
			item := &on[i]
			if _f.funcs.IsContradiction(item) {
				if !_f.funcs.IsFilterFalse(on) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.DetectJoinContradiction) {
						_expr := _f.ConstructAntiJoinApply(
							left,
							right,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									_f.ConstructFalse(),
								),
							},
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.DetectJoinContradiction, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [MapFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				_match := false
				_eq, _ := item.Condition.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						_variable2, _ := _eq.Right.(*memo.VariableExpr)
						if _variable2 != nil {
							_match = true
						}
					}
				}

				if !_match {
					rightCols := _f.funcs.OutputCols(right)
					if !_f.funcs.IsBoundBy(item, rightCols) {
						equivFD := _f.funcs.GetEquivFD(on, left, right)
						if _f.funcs.CanMapJoinOpFilter(item, rightCols, equivFD) {
							private := joinPrivate
							if _f.matchedRule == nil || _f.matchedRule(opt.MapFilterIntoJoinRight) {
								_expr := _f.ConstructAntiJoinApply(
									left,
									right,
									_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.MapJoinOpFilter(item, rightCols, equivFD)),
									private,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.MapFilterIntoJoinRight, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [MapEqualityIntoJoinLeftAndRight]
	{
		if !_f.funcs.HasOuterCols(left) {
			if !_f.funcs.HasOuterCols(right) {
				leftCols := _f.funcs.OutputCols(left)
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.CanMapJoinOpEqualities(on, leftCols, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.MapEqualityIntoJoinLeftAndRight) {
						_expr := _f.ConstructAntiJoinApply(
							left,
							right,
							_f.funcs.MapJoinOpEqualities(on, leftCols, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.MapEqualityIntoJoinLeftAndRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushFilterIntoJoinRight]
	{
		if !_f.funcs.HasOuterCols(right) {
			for i := range on {
				item := &on[i]
				rightCols := _f.funcs.OutputCols(right)
				if _f.funcs.IsBoundBy(item, rightCols) {
					private := joinPrivate
					if _f.matchedRule == nil || _f.matchedRule(opt.PushFilterIntoJoinRight) {
						_expr := _f.ConstructAntiJoinApply(
							left,
							_f.ConstructSelect(
								right,
								_f.funcs.ExtractBoundConditions(on, rightCols),
							),
							_f.funcs.ExtractUnboundConditions(on, rightCols),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushFilterIntoJoinRight, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [EliminateAntiJoin]
	{
		if _f.funcs.HasZeroRows(right) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAntiJoin) {
				_expr := left
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateAntiJoin, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyZeroCardinalityAntiJoin]
	{
		if !_f.funcs.CanHaveZeroRows(right) {
			if len(on) == 0 {
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyZeroCardinalityAntiJoin) {
					_expr := _f.funcs.ConstructEmptyValues(_f.funcs.OutputCols(left)).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyZeroCardinalityAntiJoin, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [SimplifyJoinNotNullEquality]
	{
		for i := range on {
			item := &on[i]
			condition := item.Condition
			if condition.Op() == opt.IsOp || condition.Op() == opt.IsNotOp {
				eq := condition.Child(0).(opt.ScalarExpr)
				_eq, _ := eq.(*memo.EqExpr)
				if _eq != nil {
					_variable, _ := _eq.Left.(*memo.VariableExpr)
					if _variable != nil {
						col1 := _variable.Col
						if _f.funcs.IsColNotNull2(col1, left, right) {
							_variable2, _ := _eq.Right.(*memo.VariableExpr)
							if _variable2 != nil {
								col2 := _variable2.Col
								if _f.funcs.IsColNotNull2(col2, left, right) {
									cnst := condition.Child(1).(opt.ScalarExpr)
									if cnst.Op() == opt.TrueOp || cnst.Op() == opt.FalseOp || cnst.Op() == opt.NullOp {
										private := joinPrivate
										if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyJoinNotNullEquality) {
											_expr := _f.ConstructAntiJoinApply(
												left,
												right,
												_f.funcs.ReplaceFiltersItem(on, item, _f.funcs.SimplifyNotNullEquality(_eq, condition.Op(), cnst.Op())),
												private,
											)
											if _f.appliedRule != nil {
												_f.appliedRule(opt.SimplifyJoinNotNullEquality, nil, _expr)
											}
											_f.constructorStackDepth--
											return _expr
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PruneSemiAntiJoinRightCols]
	{
		private := joinPrivate
		needed := _f.funcs.FilterOuterCols(on)
		if _f.funcs.CanPruneCols(right, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneSemiAntiJoinRightCols) {
				_expr := _f.ConstructAntiJoinApply(
					left,
					_f.funcs.PruneCols(right, needed),
					on,
					private,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneSemiAntiJoinRightCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeAntiJoinApply(left, right, on, joinPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructGroupBy constructs an expression for the GroupBy operator.
// GroupBy computes aggregate functions over groups of input rows. Input rows
// that are equal on the grouping columns are grouped together. The set of
// computed aggregate functions is described by the Aggregations field (which is
// always an Aggregations operator).
//
// The arguments of the aggregate functions are columns from the input
// (i.e. Variables), possibly wrapped in aggregate modifiers like AggDistinct.
//
// If the set of input rows is empty, then the output of the GroupBy operator
// will also be empty. If the grouping columns are empty, then all input rows
// form a single group. GroupBy is used for queries with aggregate functions,
// HAVING clauses and/or GROUP BY expressions.
//
// The GroupingPrivate field contains an ordering; this ordering serves a
// dual-purpose:
//   - if we ignore any grouping columns, the remaining columns indicate an
//     intra-group ordering; this is useful if there is an order-dependent
//     aggregation (like ARRAY_AGG).
//   - any prefix containing only grouping columns is used to execute the
//     aggregation in a streaming fashion.
//
// Currently, the initially built GroupBy has all grouping columns as "optional"
// in the ordering (we call this the "canonical" variant). Subsequently, the
// GenerateStreamingGroupBy exploration rule can add more variants, based on
// interesting orderings.
func (_f *Factory) ConstructGroupBy(
	input memo.RelExpr,
	aggregations memo.AggregationsExpr,
	groupingPrivate *memo.GroupingPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [ConvertGroupByToDistinct]
	{
		if len(aggregations) == 0 {
			if _f.matchedRule == nil || _f.matchedRule(opt.ConvertGroupByToDistinct) {
				_expr := _f.ConstructDistinctOn(
					input,
					aggregations,
					groupingPrivate,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ConvertGroupByToDistinct, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateGroupByProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			innerInput := _project.Input
			if _f.funcs.ColsAreSubset(_f.funcs.OutputCols(_project), _f.funcs.OutputCols(innerInput)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateGroupByProject) {
					_expr := _f.ConstructGroupBy(
						innerInput,
						aggregations,
						groupingPrivate,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateGroupByProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [EliminateJoinUnderGroupByLeft]
	{
		if input.Op() == opt.InnerJoinOp || input.Op() == opt.LeftJoinOp {
			left := input.Child(0).(memo.RelExpr)
			aggs := aggregations
			private := groupingPrivate
			groupingCols := private.GroupingCols
			ordering := private.Ordering
			leftCols := _f.funcs.OutputCols(left)
			if _f.funcs.OrderingCanProjectCols(ordering, leftCols) {
				if _f.funcs.ColsAreSubset(_f.funcs.UnionCols(groupingCols, _f.funcs.AggregationOuterCols(aggs)), leftCols) {
					if _f.funcs.CanEliminateJoinUnderGroupByLeft(input, aggs) {
						if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinUnderGroupByLeft) {
							_expr := _f.ConstructGroupBy(
								left,
								aggs,
								_f.funcs.MakeGrouping(groupingCols, _f.funcs.PruneOrdering(ordering, leftCols)),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.EliminateJoinUnderGroupByLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [EliminateJoinUnderGroupByRight]
	{
		_innerJoin, _ := input.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			right := _innerJoin.Right
			aggs := aggregations
			private := groupingPrivate
			groupingCols := private.GroupingCols
			ordering := private.Ordering
			rightCols := _f.funcs.OutputCols(right)
			if _f.funcs.OrderingCanProjectCols(ordering, rightCols) {
				if _f.funcs.ColsAreSubset(_f.funcs.UnionCols(groupingCols, _f.funcs.AggregationOuterCols(aggs)), rightCols) {
					if _f.funcs.CanEliminateJoinUnderGroupByRight(_innerJoin, aggs) {
						if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinUnderGroupByRight) {
							_expr := _f.ConstructGroupBy(
								right,
								aggs,
								_f.funcs.MakeGrouping(groupingCols, _f.funcs.PruneOrdering(ordering, rightCols)),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.EliminateJoinUnderGroupByRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [ReduceGroupingCols]
	{
		redundantCols := _f.funcs.RedundantCols(input, _f.funcs.GroupingCols(groupingPrivate))
		if !_f.funcs.ColsAreEmpty(redundantCols) {
			if _f.matchedRule == nil || _f.matchedRule(opt.ReduceGroupingCols) {
				_expr := _f.ConstructGroupBy(
					input,
					_f.funcs.AppendAggCols(aggregations, opt.ConstAggOp, redundantCols),
					_f.funcs.RemoveGroupingCols(groupingPrivate, redundantCols),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ReduceGroupingCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateAggDistinctForKeys]
	{
		if _f.funcs.HasStrictKey(input) {
			for i := range aggregations {
				item := &aggregations[i]
				_aggDistinct, _ := item.Agg.(*memo.AggDistinctExpr)
				if _aggDistinct != nil {
					agg := _aggDistinct.Input
					if _f.funcs.CanRemoveAggDistinctForKeys(input, groupingPrivate, agg) {
						if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAggDistinctForKeys) {
							_expr := _f.ConstructGroupBy(
								input,
								_f.funcs.ReplaceAggregationsItem(aggregations, item, agg),
								groupingPrivate,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.EliminateAggDistinctForKeys, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [EliminateAggFilteredDistinctForKeys]
	{
		if _f.funcs.HasStrictKey(input) {
			for i := range aggregations {
				item := &aggregations[i]
				_aggFilter, _ := item.Agg.(*memo.AggFilterExpr)
				if _aggFilter != nil {
					_aggDistinct, _ := _aggFilter.Input.(*memo.AggDistinctExpr)
					if _aggDistinct != nil {
						agg := _aggDistinct.Input
						filter := _aggFilter.Filter
						if _f.funcs.CanRemoveAggDistinctForKeys(input, groupingPrivate, agg) {
							if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAggFilteredDistinctForKeys) {
								_expr := _f.ConstructGroupBy(
									input,
									_f.funcs.ReplaceAggregationsItem(aggregations, item, _f.ConstructAggFilter(
										agg,
										filter,
									)),
									groupingPrivate,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.EliminateAggFilteredDistinctForKeys, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [PushAggDistinctIntoGroupBy]
	{
		if len(aggregations) == 1 {
			item := &aggregations[0]
			_aggDistinct, _ := item.Agg.(*memo.AggDistinctExpr)
			if _aggDistinct != nil {
				agg := _aggDistinct.Input
				aggColID := item.Col
				if _f.matchedRule == nil || _f.matchedRule(opt.PushAggDistinctIntoGroupBy) {
					_expr := _f.ConstructGroupBy(
						_f.ConstructDistinctOn(
							input,
							_f.funcs.MakeAggCols(opt.FirstAggOp, _f.funcs.OrderingCols(_f.funcs.ExtractGroupingOrdering(groupingPrivate))),
							_f.funcs.MakeGrouping(_f.funcs.UnionCols(_f.funcs.GroupingCols(groupingPrivate), _f.funcs.ExtractAggInputColumns(agg)), _f.funcs.EmptyOrdering()),
						),
						memo.AggregationsExpr{
							_f.ConstructAggregationsItem(
								agg,
								aggColID,
							),
						},
						groupingPrivate,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PushAggDistinctIntoGroupBy, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [ConvertCountToCountRows]
	{
		for i := range aggregations {
			item := &aggregations[i]
			_count, _ := item.Agg.(*memo.CountExpr)
			if _count != nil {
				arg := _count.Input
				if _f.funcs.ExprIsNeverNull(arg, _f.funcs.NotNullCols(input)) {
					if _f.matchedRule == nil || _f.matchedRule(opt.ConvertCountToCountRows) {
						_expr := _f.ConstructGroupBy(
							input,
							_f.funcs.ReplaceAggregationsItem(aggregations, item, _f.ConstructCountRows()),
							groupingPrivate,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.ConvertCountToCountRows, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [ConvertRegressionCountToCount]
	{
		for i := range aggregations {
			item := &aggregations[i]
			_regressionCount, _ := item.Agg.(*memo.RegressionCountExpr)
			if _regressionCount != nil {
				arg1 := _regressionCount.Y
				arg2 := _regressionCount.X
				newArg, ok := _f.funcs.SingleRegressionCountArgument(arg1, arg2, input)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.ConvertRegressionCountToCount) {
						_expr := _f.ConstructGroupBy(
							input,
							_f.funcs.ReplaceAggregationsItem(aggregations, item, _f.ConstructCount(
								newArg,
							)),
							groupingPrivate,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.ConvertRegressionCountToCount, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [FoldGroupingOperators]
	{
		if input.Op() == opt.GroupByOp || input.Op() == opt.DistinctOnOp {
			innerInput := input.Child(0).(memo.RelExpr)
			innerAggs := *input.Child(1).(*memo.AggregationsExpr)
			innerGrouping := input.Private().(*memo.GroupingPrivate)
			if _f.funcs.IsUnorderedGrouping(innerGrouping) {
				outerAggs := aggregations
				outerGrouping := groupingPrivate
				if _f.funcs.IsUnorderedGrouping(outerGrouping) {
					outerGroupingCols := _f.funcs.GroupingCols(outerGrouping)
					innerGroupingCols := _f.funcs.GroupingCols(innerGrouping)
					if _f.funcs.ColsAreDeterminedBy(outerGroupingCols, innerGroupingCols, innerInput) {
						if _f.funcs.CanMergeAggs(innerAggs, outerAggs, innerGroupingCols) {
							if _f.matchedRule == nil || _f.matchedRule(opt.FoldGroupingOperators) {
								_expr := _f.ConstructGroupBy(
									innerInput,
									_f.funcs.MergeAggs(innerAggs, outerAggs, innerGroupingCols),
									_f.funcs.MakeGrouping(outerGroupingCols, _f.funcs.EmptyOrdering()),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.FoldGroupingOperators, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [SimplifyGroupByOrdering]
	{
		if _f.funcs.CanSimplifyGroupingOrdering(input, groupingPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyGroupByOrdering) {
				_expr := _f.ConstructGroupBy(
					input,
					aggregations,
					_f.funcs.SimplifyGroupingOrdering(input, groupingPrivate),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyGroupByOrdering, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PruneGroupByCols]
	{
		needed := _f.funcs.UnionCols(_f.funcs.AggregationOuterCols(aggregations), _f.funcs.NeededGroupingCols(groupingPrivate))
		if _f.funcs.CanPruneCols(input, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneGroupByCols) {
				_expr := _f.ConstructGroupBy(
					_f.funcs.PruneCols(input, needed),
					aggregations,
					_f.funcs.PruneOrderingGroupBy(groupingPrivate, needed),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneGroupByCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeGroupBy(input, aggregations, groupingPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructScalarGroupBy constructs an expression for the ScalarGroupBy operator.
// ScalarGroupBy computes aggregate functions over the complete set of input
// rows. This is similar to GroupBy with empty grouping columns, where all input
// rows form a single group. However, there is an important difference. If the
// input set is empty, then the output of the ScalarGroupBy operator will have a
// single row containing default values for each aggregate function (typically
// null or zero, depending on the function). ScalarGroupBy always returns exactly
// one row - either the single-group aggregates or the default aggregate values.
//
// ScalarGroupBy uses the GroupingPrivate struct so that it's polymorphic with
// GroupBy and can be used in the same rules (when appropriate). In the
// ScalarGroupBy case, the grouping column field in GroupingPrivate is always
// empty.
func (_f *Factory) ConstructScalarGroupBy(
	input memo.RelExpr,
	aggregations memo.AggregationsExpr,
	groupingPrivate *memo.GroupingPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateGroupByProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			innerInput := _project.Input
			if _f.funcs.ColsAreSubset(_f.funcs.OutputCols(_project), _f.funcs.OutputCols(innerInput)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateGroupByProject) {
					_expr := _f.ConstructScalarGroupBy(
						innerInput,
						aggregations,
						groupingPrivate,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateGroupByProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [EliminateJoinUnderGroupByLeft]
	{
		if input.Op() == opt.InnerJoinOp || input.Op() == opt.LeftJoinOp {
			left := input.Child(0).(memo.RelExpr)
			aggs := aggregations
			private := groupingPrivate
			groupingCols := private.GroupingCols
			ordering := private.Ordering
			leftCols := _f.funcs.OutputCols(left)
			if _f.funcs.OrderingCanProjectCols(ordering, leftCols) {
				if _f.funcs.ColsAreSubset(_f.funcs.UnionCols(groupingCols, _f.funcs.AggregationOuterCols(aggs)), leftCols) {
					if _f.funcs.CanEliminateJoinUnderGroupByLeft(input, aggs) {
						if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinUnderGroupByLeft) {
							_expr := _f.ConstructScalarGroupBy(
								left,
								aggs,
								_f.funcs.MakeGrouping(groupingCols, _f.funcs.PruneOrdering(ordering, leftCols)),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.EliminateJoinUnderGroupByLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [EliminateJoinUnderGroupByRight]
	{
		_innerJoin, _ := input.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			right := _innerJoin.Right
			aggs := aggregations
			private := groupingPrivate
			groupingCols := private.GroupingCols
			ordering := private.Ordering
			rightCols := _f.funcs.OutputCols(right)
			if _f.funcs.OrderingCanProjectCols(ordering, rightCols) {
				if _f.funcs.ColsAreSubset(_f.funcs.UnionCols(groupingCols, _f.funcs.AggregationOuterCols(aggs)), rightCols) {
					if _f.funcs.CanEliminateJoinUnderGroupByRight(_innerJoin, aggs) {
						if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinUnderGroupByRight) {
							_expr := _f.ConstructScalarGroupBy(
								right,
								aggs,
								_f.funcs.MakeGrouping(groupingCols, _f.funcs.PruneOrdering(ordering, rightCols)),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.EliminateJoinUnderGroupByRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [EliminateAggDistinctForKeys]
	{
		if _f.funcs.HasStrictKey(input) {
			for i := range aggregations {
				item := &aggregations[i]
				_aggDistinct, _ := item.Agg.(*memo.AggDistinctExpr)
				if _aggDistinct != nil {
					agg := _aggDistinct.Input
					if _f.funcs.CanRemoveAggDistinctForKeys(input, groupingPrivate, agg) {
						if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAggDistinctForKeys) {
							_expr := _f.ConstructScalarGroupBy(
								input,
								_f.funcs.ReplaceAggregationsItem(aggregations, item, agg),
								groupingPrivate,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.EliminateAggDistinctForKeys, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [EliminateAggFilteredDistinctForKeys]
	{
		if _f.funcs.HasStrictKey(input) {
			for i := range aggregations {
				item := &aggregations[i]
				_aggFilter, _ := item.Agg.(*memo.AggFilterExpr)
				if _aggFilter != nil {
					_aggDistinct, _ := _aggFilter.Input.(*memo.AggDistinctExpr)
					if _aggDistinct != nil {
						agg := _aggDistinct.Input
						filter := _aggFilter.Filter
						if _f.funcs.CanRemoveAggDistinctForKeys(input, groupingPrivate, agg) {
							if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAggFilteredDistinctForKeys) {
								_expr := _f.ConstructScalarGroupBy(
									input,
									_f.funcs.ReplaceAggregationsItem(aggregations, item, _f.ConstructAggFilter(
										agg,
										filter,
									)),
									groupingPrivate,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.EliminateAggFilteredDistinctForKeys, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [PushAggDistinctIntoGroupBy]
	{
		if len(aggregations) == 1 {
			item := &aggregations[0]
			_aggDistinct, _ := item.Agg.(*memo.AggDistinctExpr)
			if _aggDistinct != nil {
				agg := _aggDistinct.Input
				aggColID := item.Col
				if _f.matchedRule == nil || _f.matchedRule(opt.PushAggDistinctIntoGroupBy) {
					_expr := _f.ConstructScalarGroupBy(
						_f.ConstructDistinctOn(
							input,
							_f.funcs.MakeAggCols(opt.FirstAggOp, _f.funcs.OrderingCols(_f.funcs.ExtractGroupingOrdering(groupingPrivate))),
							_f.funcs.MakeGrouping(_f.funcs.UnionCols(_f.funcs.GroupingCols(groupingPrivate), _f.funcs.ExtractAggInputColumns(agg)), _f.funcs.EmptyOrdering()),
						),
						memo.AggregationsExpr{
							_f.ConstructAggregationsItem(
								agg,
								aggColID,
							),
						},
						groupingPrivate,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PushAggDistinctIntoGroupBy, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PushAggFilterIntoScalarGroupBy]
	{
		if len(aggregations) == 1 {
			item := &aggregations[0]
			_aggFilter, _ := item.Agg.(*memo.AggFilterExpr)
			if _aggFilter != nil {
				agg := _aggFilter.Input
				condition := _aggFilter.Filter
				aggColID := item.Col
				if _f.matchedRule == nil || _f.matchedRule(opt.PushAggFilterIntoScalarGroupBy) {
					_expr := _f.ConstructScalarGroupBy(
						_f.ConstructSelect(
							input,
							memo.FiltersExpr{
								_f.ConstructFiltersItem(
									condition,
								),
							},
						),
						memo.AggregationsExpr{
							_f.ConstructAggregationsItem(
								agg,
								aggColID,
							),
						},
						groupingPrivate,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PushAggFilterIntoScalarGroupBy, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [ConvertCountToCountRows]
	{
		for i := range aggregations {
			item := &aggregations[i]
			_count, _ := item.Agg.(*memo.CountExpr)
			if _count != nil {
				arg := _count.Input
				if _f.funcs.ExprIsNeverNull(arg, _f.funcs.NotNullCols(input)) {
					if _f.matchedRule == nil || _f.matchedRule(opt.ConvertCountToCountRows) {
						_expr := _f.ConstructScalarGroupBy(
							input,
							_f.funcs.ReplaceAggregationsItem(aggregations, item, _f.ConstructCountRows()),
							groupingPrivate,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.ConvertCountToCountRows, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [ConvertRegressionCountToCount]
	{
		for i := range aggregations {
			item := &aggregations[i]
			_regressionCount, _ := item.Agg.(*memo.RegressionCountExpr)
			if _regressionCount != nil {
				arg1 := _regressionCount.Y
				arg2 := _regressionCount.X
				newArg, ok := _f.funcs.SingleRegressionCountArgument(arg1, arg2, input)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.ConvertRegressionCountToCount) {
						_expr := _f.ConstructScalarGroupBy(
							input,
							_f.funcs.ReplaceAggregationsItem(aggregations, item, _f.ConstructCount(
								newArg,
							)),
							groupingPrivate,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.ConvertRegressionCountToCount, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [FoldGroupingOperators]
	{
		if input.Op() == opt.GroupByOp || input.Op() == opt.DistinctOnOp {
			innerInput := input.Child(0).(memo.RelExpr)
			innerAggs := *input.Child(1).(*memo.AggregationsExpr)
			innerGrouping := input.Private().(*memo.GroupingPrivate)
			if _f.funcs.IsUnorderedGrouping(innerGrouping) {
				outerAggs := aggregations
				outerGrouping := groupingPrivate
				if _f.funcs.IsUnorderedGrouping(outerGrouping) {
					outerGroupingCols := _f.funcs.GroupingCols(outerGrouping)
					innerGroupingCols := _f.funcs.GroupingCols(innerGrouping)
					if _f.funcs.ColsAreDeterminedBy(outerGroupingCols, innerGroupingCols, innerInput) {
						if _f.funcs.CanMergeAggs(innerAggs, outerAggs, innerGroupingCols) {
							if _f.matchedRule == nil || _f.matchedRule(opt.FoldGroupingOperators) {
								_expr := _f.ConstructScalarGroupBy(
									innerInput,
									_f.funcs.MergeAggs(innerAggs, outerAggs, innerGroupingCols),
									_f.funcs.MakeGrouping(outerGroupingCols, _f.funcs.EmptyOrdering()),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.FoldGroupingOperators, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [SimplifyGroupByOrdering]
	{
		if _f.funcs.CanSimplifyGroupingOrdering(input, groupingPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyGroupByOrdering) {
				_expr := _f.ConstructScalarGroupBy(
					input,
					aggregations,
					_f.funcs.SimplifyGroupingOrdering(input, groupingPrivate),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyGroupByOrdering, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PruneGroupByCols]
	{
		needed := _f.funcs.UnionCols(_f.funcs.AggregationOuterCols(aggregations), _f.funcs.NeededGroupingCols(groupingPrivate))
		if _f.funcs.CanPruneCols(input, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneGroupByCols) {
				_expr := _f.ConstructScalarGroupBy(
					_f.funcs.PruneCols(input, needed),
					aggregations,
					_f.funcs.PruneOrderingGroupBy(groupingPrivate, needed),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneGroupByCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeScalarGroupBy(input, aggregations, groupingPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructDistinctOn constructs an expression for the DistinctOn operator.
// DistinctOn filters out rows that are identical on the set of grouping columns;
// only the first row (according to an ordering) is kept for each set of possible
// values. It is roughly equivalent with a GroupBy on the same grouping columns
// except that it uses FirstAgg functions that ensure the value on the first row
// is chosen (across all aggregations).
//
// In addition, the value on that first row must be chosen for all the grouping
// columns as well; this is relevant in the case of equal but non-identical
// values, like decimals. For example, if we have rows (1, 2.0) and (1.0, 2) and
// we are grouping on these two columns, the values output can be either (1, 2.0)
// or (1.0, 2), but not (1.0, 2.0).
//
// The execution of DistinctOn resembles that of Select more than that of
// GroupBy: each row is tested against a map of what groups we have seen already,
// and is either passed through or discarded. In particular, note that this
// preserves the input ordering.
//
// The ordering in the GroupingPrivate field will be required of the input; it
// determines which row can get "chosen" for each group of values on the grouping
// columns. There is no restriction on the ordering; but note that grouping
// columns are inconsequential - they can appear anywhere in the ordering and
// they won't change the results (other than the result ordering).
//
// Currently when we build DistinctOn, we set all grouping columns as optional
// cols in Ordering (but this is not required by the operator).
//
// TODO(radu): in the future we may want an exploration transform to try out more
// specific interesting orderings because execution is more efficient when we can
// rely on an ordering on the grouping columns (or a subset of them).
//
// DistinctOn uses an Aggregations child and the GroupingPrivate struct so that
// it's polymorphic with GroupBy and can be used in the same rules (when
// appropriate). In the DistinctOn case, the aggregations can be only FirstAgg or
// ConstAgg.
func (_f *Factory) ConstructDistinctOn(
	input memo.RelExpr,
	aggregations memo.AggregationsExpr,
	groupingPrivate *memo.GroupingPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateGroupByProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			innerInput := _project.Input
			if _f.funcs.ColsAreSubset(_f.funcs.OutputCols(_project), _f.funcs.OutputCols(innerInput)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateGroupByProject) {
					_expr := _f.ConstructDistinctOn(
						innerInput,
						aggregations,
						groupingPrivate,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateGroupByProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [EliminateJoinUnderGroupByLeft]
	{
		if input.Op() == opt.InnerJoinOp || input.Op() == opt.LeftJoinOp {
			left := input.Child(0).(memo.RelExpr)
			aggs := aggregations
			private := groupingPrivate
			groupingCols := private.GroupingCols
			ordering := private.Ordering
			leftCols := _f.funcs.OutputCols(left)
			if _f.funcs.OrderingCanProjectCols(ordering, leftCols) {
				if _f.funcs.ColsAreSubset(_f.funcs.UnionCols(groupingCols, _f.funcs.AggregationOuterCols(aggs)), leftCols) {
					if _f.funcs.CanEliminateJoinUnderGroupByLeft(input, aggs) {
						if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinUnderGroupByLeft) {
							_expr := _f.ConstructDistinctOn(
								left,
								aggs,
								_f.funcs.MakeGrouping(groupingCols, _f.funcs.PruneOrdering(ordering, leftCols)),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.EliminateJoinUnderGroupByLeft, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [EliminateJoinUnderGroupByRight]
	{
		_innerJoin, _ := input.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			right := _innerJoin.Right
			aggs := aggregations
			private := groupingPrivate
			groupingCols := private.GroupingCols
			ordering := private.Ordering
			rightCols := _f.funcs.OutputCols(right)
			if _f.funcs.OrderingCanProjectCols(ordering, rightCols) {
				if _f.funcs.ColsAreSubset(_f.funcs.UnionCols(groupingCols, _f.funcs.AggregationOuterCols(aggs)), rightCols) {
					if _f.funcs.CanEliminateJoinUnderGroupByRight(_innerJoin, aggs) {
						if _f.matchedRule == nil || _f.matchedRule(opt.EliminateJoinUnderGroupByRight) {
							_expr := _f.ConstructDistinctOn(
								right,
								aggs,
								_f.funcs.MakeGrouping(groupingCols, _f.funcs.PruneOrdering(ordering, rightCols)),
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.EliminateJoinUnderGroupByRight, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [EliminateDistinct]
	{
		aggs := aggregations
		if _f.funcs.ColsAreStrictKey(_f.funcs.GroupingCols(groupingPrivate), input) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinct) {
				_expr := _f.ConstructProject(
					input,
					memo.EmptyProjectionsExpr,
					_f.funcs.GroupingOutputCols(groupingPrivate, aggs),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinct, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [ReduceGroupingCols]
	{
		redundantCols := _f.funcs.RedundantCols(input, _f.funcs.GroupingCols(groupingPrivate))
		if !_f.funcs.ColsAreEmpty(redundantCols) {
			if _f.matchedRule == nil || _f.matchedRule(opt.ReduceGroupingCols) {
				_expr := _f.ConstructDistinctOn(
					input,
					_f.funcs.AppendAggCols(aggregations, opt.ConstAggOp, redundantCols),
					_f.funcs.RemoveGroupingCols(groupingPrivate, redundantCols),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ReduceGroupingCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateDistinctNoColumns]
	{
		if _f.funcs.HasNoGroupingCols(groupingPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinctNoColumns) {
				_expr := _f.funcs.ConstructProjectionFromDistinctOn(_f.ConstructLimit(
					input,
					_f.funcs.IntConst(tree.NewDInt(1)),
					_f.funcs.GroupingInputOrdering(groupingPrivate),
				), _f.funcs.MakeEmptyColSet(), aggregations).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinctNoColumns, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateDistinctOnValues]
	{
		if _f.funcs.AreValuesDistinct(input, _f.funcs.GroupingCols(groupingPrivate), _f.funcs.NullsAreDistinct(groupingPrivate)) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinctOnValues) {
				_expr := _f.funcs.ConstructProjectionFromDistinctOn(input, _f.funcs.GroupingCols(groupingPrivate), aggregations).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinctOnValues, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldGroupingOperators]
	{
		if input.Op() == opt.GroupByOp || input.Op() == opt.DistinctOnOp {
			innerInput := input.Child(0).(memo.RelExpr)
			innerAggs := *input.Child(1).(*memo.AggregationsExpr)
			innerGrouping := input.Private().(*memo.GroupingPrivate)
			if _f.funcs.IsUnorderedGrouping(innerGrouping) {
				outerAggs := aggregations
				outerGrouping := groupingPrivate
				if _f.funcs.IsUnorderedGrouping(outerGrouping) {
					outerGroupingCols := _f.funcs.GroupingCols(outerGrouping)
					innerGroupingCols := _f.funcs.GroupingCols(innerGrouping)
					if _f.funcs.ColsAreDeterminedBy(outerGroupingCols, innerGroupingCols, innerInput) {
						if _f.funcs.CanMergeAggs(innerAggs, outerAggs, innerGroupingCols) {
							if _f.matchedRule == nil || _f.matchedRule(opt.FoldGroupingOperators) {
								_expr := _f.ConstructDistinctOn(
									innerInput,
									_f.funcs.MergeAggs(innerAggs, outerAggs, innerGroupingCols),
									_f.funcs.MakeGrouping(outerGroupingCols, _f.funcs.EmptyOrdering()),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.FoldGroupingOperators, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [SimplifyGroupByOrdering]
	{
		if _f.funcs.CanSimplifyGroupingOrdering(input, groupingPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyGroupByOrdering) {
				_expr := _f.ConstructDistinctOn(
					input,
					aggregations,
					_f.funcs.SimplifyGroupingOrdering(input, groupingPrivate),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyGroupByOrdering, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PruneGroupByCols]
	{
		needed := _f.funcs.UnionCols(_f.funcs.AggregationOuterCols(aggregations), _f.funcs.NeededGroupingCols(groupingPrivate))
		if _f.funcs.CanPruneCols(input, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneGroupByCols) {
				_expr := _f.ConstructDistinctOn(
					_f.funcs.PruneCols(input, needed),
					aggregations,
					_f.funcs.PruneOrderingGroupBy(groupingPrivate, needed),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneGroupByCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeDistinctOn(input, aggregations, groupingPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructEnsureDistinctOn constructs an expression for the EnsureDistinctOn operator.
// EnsureDistinctOn is a variation on DistinctOn that is only used to replace a
// Max1Row operator in a decorrelation attempt. It raises an error if any
// distinct grouping contains more than one row. Or in other words, it "ensures"
// that the input is distinct on the grouping columns.
//
// EnsureDistinctOn is used when nulls are not considered distinct for grouping
// purposes and an error should be raised when duplicates are detected.
//
// Rules should only "push through" or eliminate an EnsureDistinctOn if they
// preserve the expected error behavior. For example, it would be invalid to
// push a Select filter into an EnsureDistinctOn, as it might eliminate rows
// that would otherwise trigger the EnsureDistinctOn error.
func (_f *Factory) ConstructEnsureDistinctOn(
	input memo.RelExpr,
	aggregations memo.AggregationsExpr,
	groupingPrivate *memo.GroupingPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateGroupByProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			innerInput := _project.Input
			if _f.funcs.ColsAreSubset(_f.funcs.OutputCols(_project), _f.funcs.OutputCols(innerInput)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateGroupByProject) {
					_expr := _f.ConstructEnsureDistinctOn(
						innerInput,
						aggregations,
						groupingPrivate,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateGroupByProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [EliminateDistinct]
	{
		aggs := aggregations
		if _f.funcs.ColsAreStrictKey(_f.funcs.GroupingCols(groupingPrivate), input) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinct) {
				_expr := _f.ConstructProject(
					input,
					memo.EmptyProjectionsExpr,
					_f.funcs.GroupingOutputCols(groupingPrivate, aggs),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinct, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateEnsureDistinctNoColumns]
	{
		if _f.funcs.HasNoGroupingCols(groupingPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateEnsureDistinctNoColumns) {
				_expr := _f.funcs.ConstructProjectionFromDistinctOn(_f.ConstructMax1Row(
					input,
					_f.funcs.ErrorOnDup(groupingPrivate),
				), _f.funcs.MakeEmptyColSet(), aggregations).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateEnsureDistinctNoColumns, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PruneGroupByCols]
	{
		needed := _f.funcs.UnionCols(_f.funcs.AggregationOuterCols(aggregations), _f.funcs.NeededGroupingCols(groupingPrivate))
		if _f.funcs.CanPruneCols(input, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneGroupByCols) {
				_expr := _f.ConstructEnsureDistinctOn(
					_f.funcs.PruneCols(input, needed),
					aggregations,
					_f.funcs.PruneOrderingGroupBy(groupingPrivate, needed),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneGroupByCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeEnsureDistinctOn(input, aggregations, groupingPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUpsertDistinctOn constructs an expression for the UpsertDistinctOn operator.
// UpsertDistinctOn is a variation on DistinctOn that is only used with UPSERT
// and INSERT..ON CONFLICT statements. Unlike DistinctOn, UpsertDistinctOn treats
// NULL values as not equal to one another for purposes of grouping. Two rows
// having a NULL-valued grouping column will be placed in different groups. This
// differs from DistinctOn behavior, where the two rows would be grouped
// together. This behavior difference reflects SQL semantics, in which a unique
// index key still allows multiple NULL values.
//
// UpsertDistinctOn is used when nulls are considered distinct for grouping
// purposes and duplicates should be filtered out without raising an error.
func (_f *Factory) ConstructUpsertDistinctOn(
	input memo.RelExpr,
	aggregations memo.AggregationsExpr,
	groupingPrivate *memo.GroupingPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [ReduceNotNullGroupingCols]
	{
		redundantCols := _f.funcs.IntersectionCols(_f.funcs.RedundantCols(input, _f.funcs.GroupingCols(groupingPrivate)), _f.funcs.NotNullCols(input))
		if !_f.funcs.ColsAreEmpty(redundantCols) {
			if _f.matchedRule == nil || _f.matchedRule(opt.ReduceNotNullGroupingCols) {
				_expr := _f.ConstructUpsertDistinctOn(
					input,
					_f.funcs.AppendAggCols(aggregations, opt.ConstAggOp, redundantCols),
					_f.funcs.RemoveGroupingCols(groupingPrivate, redundantCols),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ReduceNotNullGroupingCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateDistinctNoColumns]
	{
		if _f.funcs.HasNoGroupingCols(groupingPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinctNoColumns) {
				_expr := _f.funcs.ConstructProjectionFromDistinctOn(_f.ConstructLimit(
					input,
					_f.funcs.IntConst(tree.NewDInt(1)),
					_f.funcs.GroupingInputOrdering(groupingPrivate),
				), _f.funcs.MakeEmptyColSet(), aggregations).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinctNoColumns, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateDistinctOnValues]
	{
		if _f.funcs.AreValuesDistinct(input, _f.funcs.GroupingCols(groupingPrivate), _f.funcs.NullsAreDistinct(groupingPrivate)) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinctOnValues) {
				_expr := _f.funcs.ConstructProjectionFromDistinctOn(input, _f.funcs.GroupingCols(groupingPrivate), aggregations).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinctOnValues, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUpsertDistinctOn(input, aggregations, groupingPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructEnsureUpsertDistinctOn constructs an expression for the EnsureUpsertDistinctOn operator.
// EnsureUpsertDistinctOn is a variation on UpsertDistinctOn that is only used
// with UPSERT and INSERT..ON CONFLICT statements. Like UpsertDistinctOn,
// EnsureUpsertDistinctOn treats NULL values as not equal to one another for
// purposes of grouping. Unlike UpsertDistinctOn, it raises an error if any
// distinct grouping contains more than one row. Or in other words, it "ensures"
// that the input is distinct on the grouping columns.
//
// EnsureUpsertDistinctOn is used when nulls are considered distinct for grouping
// purposes and an error should be raised when duplicates are detected.
//
// Rules should only "push through" or eliminate an EnsureUpsertDistinctOn if
// they preserve the expected error behavior. For example, it would be invalid to
// push a Select filter into an EnsureUpsertDistinctOn, as it might eliminate
// rows that would otherwise trigger the EnsureUpsertDistinctOn error.
func (_f *Factory) ConstructEnsureUpsertDistinctOn(
	input memo.RelExpr,
	aggregations memo.AggregationsExpr,
	groupingPrivate *memo.GroupingPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateGroupByProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			innerInput := _project.Input
			if _f.funcs.ColsAreSubset(_f.funcs.OutputCols(_project), _f.funcs.OutputCols(innerInput)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateGroupByProject) {
					_expr := _f.ConstructEnsureUpsertDistinctOn(
						innerInput,
						aggregations,
						groupingPrivate,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateGroupByProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [ReduceNotNullGroupingCols]
	{
		redundantCols := _f.funcs.IntersectionCols(_f.funcs.RedundantCols(input, _f.funcs.GroupingCols(groupingPrivate)), _f.funcs.NotNullCols(input))
		if !_f.funcs.ColsAreEmpty(redundantCols) {
			if _f.matchedRule == nil || _f.matchedRule(opt.ReduceNotNullGroupingCols) {
				_expr := _f.ConstructEnsureUpsertDistinctOn(
					input,
					_f.funcs.AppendAggCols(aggregations, opt.ConstAggOp, redundantCols),
					_f.funcs.RemoveGroupingCols(groupingPrivate, redundantCols),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ReduceNotNullGroupingCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateEnsureDistinctNoColumns]
	{
		if _f.funcs.HasNoGroupingCols(groupingPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateEnsureDistinctNoColumns) {
				_expr := _f.funcs.ConstructProjectionFromDistinctOn(_f.ConstructMax1Row(
					input,
					_f.funcs.ErrorOnDup(groupingPrivate),
				), _f.funcs.MakeEmptyColSet(), aggregations).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateEnsureDistinctNoColumns, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateDistinctOnValues]
	{
		if _f.funcs.AreValuesDistinct(input, _f.funcs.GroupingCols(groupingPrivate), _f.funcs.NullsAreDistinct(groupingPrivate)) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinctOnValues) {
				_expr := _f.funcs.ConstructProjectionFromDistinctOn(input, _f.funcs.GroupingCols(groupingPrivate), aggregations).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinctOnValues, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeEnsureUpsertDistinctOn(input, aggregations, groupingPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUnion constructs an expression for the Union operator.
// Union is an operator used to combine the Left and Right input relations into
// a single set containing rows from both inputs. Duplicate rows are discarded.
// The SetPrivate field matches columns from the Left and Right inputs of the
// Union with the output columns. See the comment above SetPrivate for more
// details.
func (_f *Factory) ConstructUnion(
	left memo.RelExpr,
	right memo.RelExpr,
	setPrivate *memo.SetPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateDistinctSetLeft]
	{
		if _f.funcs.HasZeroRows(right) {
			colMap := setPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinctSetLeft) {
				project := _f.ConstructProject(
					left,
					_f.funcs.ProjectColMapLeft(colMap),
					_f.funcs.ProjectPassthroughLeft(colMap),
				)
				_expr := _f.ConstructDistinctOn(
					project,
					memo.EmptyAggregationsExpr,
					_f.funcs.MakeGrouping(_f.funcs.OutputCols(project), _f.funcs.EmptyOrdering()),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinctSetLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateDistinctSetRight]
	{
		if _f.funcs.HasZeroRows(left) {
			colMap := setPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinctSetRight) {
				project := _f.ConstructProject(
					right,
					_f.funcs.ProjectColMapRight(colMap),
					_f.funcs.ProjectPassthroughRight(colMap),
				)
				_expr := _f.ConstructDistinctOn(
					project,
					memo.EmptyAggregationsExpr,
					_f.funcs.MakeGrouping(_f.funcs.OutputCols(project), _f.funcs.EmptyOrdering()),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinctSetRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [ConvertUnionToDistinctUnionAll]
	{
		private := setPrivate
		leftCols := private.LeftCols
		rightCols := private.RightCols
		outCols := private.OutCols
		keyCols, ok := _f.funcs.CanConvertUnionToDistinctUnionAll(leftCols, rightCols)
		if ok {
			if _f.matchedRule == nil || _f.matchedRule(opt.ConvertUnionToDistinctUnionAll) {
				_expr := _f.ConstructDistinctOn(
					_f.ConstructUnionAll(
						left,
						right,
						private,
					),
					_f.funcs.MakeAggCols(opt.ConstAggOp, _f.funcs.TranslateColSet(_f.funcs.DifferenceCols(_f.funcs.OutputCols(left), keyCols), leftCols, outCols)),
					_f.funcs.MakeGrouping(_f.funcs.TranslateColSet(keyCols, leftCols, outCols), _f.funcs.EmptyOrdering()),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ConvertUnionToDistinctUnionAll, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUnion(left, right, setPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIntersect constructs an expression for the Intersect operator.
// Intersect is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that are also present in the Right relation. Duplicate rows are
// discarded.
// The SetPrivate field matches columns from the Left and Right inputs of the
// Intersect with the output columns. See the comment above SetPrivate for more
// details.
// Note that Intersect is symmetric in most cases, but there are exceptions:
// some types allow values that are equal but not identical (e.g. collated
// strings) in which case it could be visible which side a row is coming from.
func (_f *Factory) ConstructIntersect(
	left memo.RelExpr,
	right memo.RelExpr,
	setPrivate *memo.SetPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyIntersectLeft]
	{
		if _f.funcs.HasStrictKey(left) {
			colMap := setPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyIntersectLeft) {
				_expr := _f.ConstructIntersectAll(
					left,
					right,
					colMap,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyIntersectLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyIntersectRight]
	{
		if _f.funcs.HasStrictKey(right) {
			colMap := setPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyIntersectRight) {
				_expr := _f.ConstructIntersectAll(
					left,
					right,
					colMap,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyIntersectRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeIntersect(left, right, setPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructExcept constructs an expression for the Except operator.
// Except is an operator used to perform a set difference between the Left and
// Right input relations. The result consists only of rows in the Left relation
// that are not present in the Right relation. Duplicate rows are discarded.
// The SetPrivate field matches columns from the Left and Right inputs of the Except
// with the output columns. See the comment above SetPrivate for more details.
func (_f *Factory) ConstructExcept(
	left memo.RelExpr,
	right memo.RelExpr,
	setPrivate *memo.SetPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateDistinctSetLeft]
	{
		if _f.funcs.HasZeroRows(right) {
			colMap := setPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateDistinctSetLeft) {
				project := _f.ConstructProject(
					left,
					_f.funcs.ProjectColMapLeft(colMap),
					_f.funcs.ProjectPassthroughLeft(colMap),
				)
				_expr := _f.ConstructDistinctOn(
					project,
					memo.EmptyAggregationsExpr,
					_f.funcs.MakeGrouping(_f.funcs.OutputCols(project), _f.funcs.EmptyOrdering()),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateDistinctSetLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyExcept]
	{
		if _f.funcs.HasStrictKey(left) {
			colMap := setPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyExcept) {
				_expr := _f.ConstructExceptAll(
					left,
					right,
					colMap,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyExcept, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeExcept(left, right, setPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUnionAll constructs an expression for the UnionAll operator.
// UnionAll is an operator used to combine the Left and Right input relations
// into a single set containing rows from both inputs. Duplicate rows are
// not discarded. For example:
//
//	SELECT x FROM xx UNION ALL SELECT y FROM yy
//	  x       y         out
//	-----   -----      -----
//	  1       1          1
//	  1       2    ->    1
//	  2       3          1
//	                     2
//	                     2
//	                     3
//
// The SetPrivate field matches columns from the Left and Right inputs of the
// UnionAll with the output columns. See the comment above SetPrivate for more
// details.
func (_f *Factory) ConstructUnionAll(
	left memo.RelExpr,
	right memo.RelExpr,
	setPrivate *memo.SetPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateSetLeft]
	{
		if _f.funcs.HasZeroRows(right) {
			colmap := setPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateSetLeft) {
				_expr := _f.ConstructProject(
					left,
					_f.funcs.ProjectColMapLeft(colmap),
					_f.funcs.ProjectPassthroughLeft(colmap),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateSetLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateSetRight]
	{
		if _f.funcs.HasZeroRows(left) {
			colmap := setPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateSetRight) {
				_expr := _f.ConstructProject(
					right,
					_f.funcs.ProjectColMapRight(colmap),
					_f.funcs.ProjectPassthroughRight(colmap),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateSetRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUnionAll(left, right, setPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIntersectAll constructs an expression for the IntersectAll operator.
// IntersectAll is an operator used to perform an intersection between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that have a corresponding row in the Right relation. Duplicate rows
// are not discarded. This effectively creates a one-to-one mapping between the
// Left and Right rows. For example:
//
//	SELECT x FROM xx INTERSECT ALL SELECT y FROM yy
//	  x       y         out
//	-----   -----      -----
//	  1       1          1
//	  1       1    ->    1
//	  1       2          2
//	  2       2          2
//	  2       3
//	  4
//
// The SetPrivate field matches columns from the Left and Right inputs of the
// IntersectAll with the output columns. See the comment above SetPrivate for more
// details.
// Note that IntersectAll is symmetric in most cases, but there are exceptions:
// some types allow values that are equal but not identical (e.g. collated
// strings) in which case it could be visible which side a row is coming from.
func (_f *Factory) ConstructIntersectAll(
	left memo.RelExpr,
	right memo.RelExpr,
	setPrivate *memo.SetPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeIntersectAll(left, right, setPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructExceptAll constructs an expression for the ExceptAll operator.
// ExceptAll is an operator used to perform a set difference between the Left
// and Right input relations. The result consists only of rows in the Left
// relation that do not have a corresponding row in the Right relation.
// Duplicate rows are not discarded. This effectively creates a one-to-one
// mapping between the Left and Right rows. For example:
//
//	SELECT x FROM xx EXCEPT ALL SELECT y FROM yy
//	  x       y         out
//	-----   -----      -----
//	  1       1    ->    1
//	  1       1          4
//	  1       2
//	  2       2
//	  2       3
//	  4
//
// The SetPrivate field matches columns from the Left and Right inputs of the
// ExceptAll with the output columns. See the comment above SetPrivate for more
// details.
func (_f *Factory) ConstructExceptAll(
	left memo.RelExpr,
	right memo.RelExpr,
	setPrivate *memo.SetPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateSetLeft]
	{
		if _f.funcs.HasZeroRows(right) {
			colmap := setPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateSetLeft) {
				_expr := _f.ConstructProject(
					left,
					_f.funcs.ProjectColMapLeft(colmap),
					_f.funcs.ProjectPassthroughLeft(colmap),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateSetLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeExceptAll(left, right, setPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLocalityOptimizedSearch constructs an expression for the LocalityOptimizedSearch operator.
// LocalityOptimizedSearch is similar to UnionAll, but it is designed to avoid
// communicating with remote nodes (relative to the gateway region) if at all
// possible. LocalityOptimizedSearch can be planned when a scan is known to
// produce at most one row, but it is not known which region contains that row
// (if any). In this case, the scan can be split in two, and the resulting scans
// will become the children of the LocalityOptimizedSearch operator. The left
// scan should only contain spans targeting partitions on local nodes, and the
// right scan should contain the remaining spans. The LocalityOptimizedSearch
// operator ensures that the right child (containing remote spans) is only
// executed if the left child (containing local spans) does not return any rows.
//
// This is a useful optimization if there is locality of access in the workload,
// such that rows tend to be accessed from the region where they are located.
// If there is no locality of access, using LocalityOptimizedSearch could be a
// slight pessimization, since rows residing in remote regions will be fetched
// slightly more slowly than they would be otherwise.
//
// For example, suppose we have a multi-region database with regions 'us-east1',
// 'us-west1' and 'europe-west1', and we have the following table and query,
// issued from 'us-east1':
//
//	CREATE TABLE tab (
//	  k INT PRIMARY KEY,
//	  v INT
//	) LOCALITY REGIONAL BY ROW;
//
//	SELECT * FROM tab WHERE k = 10;
//
// Normally, this would produce the following plan:
//
//	scan tab
//	  constraint: /3/1
//	       [/'europe-west1'/10 - /'europe-west1'/10]
//	       [/'us-east1'/10 - /'us-east1'/10]
//	       [/'us-west1'/10 - /'us-west1'/10]
//
// but if the session setting locality_optimized_partitioned_index_scan is enabled,
// the optimizer will produce this plan, using locality optimized search:
//
//	locality-optimized-search
//	  scan tab
//	      constraint: /9/7: [/'us-east1'/10 - /'us-east1'/10]
//	  scan tab
//	       constraint: /14/12
//	            [/'europe-west1'/10 - /'europe-west1'/10]
//	            [/'us-west1'/10 - /'us-west1'/10]
//
// As long as k = 10 is located in 'us-east1', the second plan will be much faster.
// But if k = 10 is located in one of the other regions, the first plan would be
// slightly faster.
func (_f *Factory) ConstructLocalityOptimizedSearch(
	local memo.RelExpr,
	remote memo.RelExpr,
	setPrivate *memo.SetPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeLocalityOptimizedSearch(local, remote, setPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLimit constructs an expression for the Limit operator.
// Limit returns a limited subset of the results in the input relation. The limit
// expression is a scalar value; the operator returns at most this many rows. The
// Ordering field is a physical.OrderingChoice which indicates the row ordering
// required from the input (the first rows with respect to this ordering are
// returned).
func (_f *Factory) ConstructLimit(
	input memo.RelExpr,
	limit opt.ScalarExpr,
	ordering props.OrderingChoice,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateLimit]
	{
		_const, _ := limit.(*memo.ConstExpr)
		if _const != nil {
			limit := _const.Value
			if _f.funcs.LimitGeMaxRows(limit, input) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateLimit) {
					_expr := input
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateLimit, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PushLimitIntoProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			passthrough := _project.Passthrough
			cols := _f.funcs.OutputCols(input)
			if _f.funcs.OrderingCanProjectCols(ordering, cols) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PushLimitIntoProject) {
					_expr := _f.ConstructProject(
						_f.ConstructLimit(
							input,
							limit,
							_f.funcs.PruneOrdering(ordering, cols),
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PushLimitIntoProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PushLimitIntoOffset]
	{
		_offset, _ := input.(*memo.OffsetExpr)
		if _offset != nil {
			input := _offset.Input
			offsetExpr := _offset.Offset
			_const, _ := offsetExpr.(*memo.ConstExpr)
			if _const != nil {
				offset := _const.Value
				if _f.funcs.IsPositiveInt(offset) {
					offsetOrdering := _offset.Ordering
					_const2, _ := limit.(*memo.ConstExpr)
					if _const2 != nil {
						limit := _const2.Value
						if _f.funcs.IsPositiveInt(limit) {
							limitOrdering := ordering
							if _f.funcs.IsSameOrdering(offsetOrdering, limitOrdering) {
								if _f.funcs.CanAddConstInts(limit, offset) {
									if _f.matchedRule == nil || _f.matchedRule(opt.PushLimitIntoOffset) {
										_expr := _f.ConstructOffset(
											_f.ConstructLimit(
												input,
												_f.funcs.AddConstInts(offset, limit),
												limitOrdering,
											),
											_const,
											offsetOrdering,
										)
										if _f.appliedRule != nil {
											_f.appliedRule(opt.PushLimitIntoOffset, nil, _expr)
										}
										_f.constructorStackDepth--
										return _expr
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoOrdinality]
	{
		_ordinality, _ := input.(*memo.OrdinalityExpr)
		if _ordinality != nil {
			input := _ordinality.Input
			private := &_ordinality.OrdinalityPrivate
			limitOrdering := ordering
			if _f.funcs.OrderingCanProjectCols(limitOrdering, _f.funcs.OutputCols(input)) {
				if _f.funcs.OrderingIntersects(_f.funcs.OrdinalityOrdering(private), limitOrdering) {
					if _f.matchedRule == nil || _f.matchedRule(opt.PushLimitIntoOrdinality) {
						_expr := _f.ConstructOrdinality(
							_f.ConstructLimit(
								input,
								limit,
								_f.funcs.OrderingIntersection(_f.funcs.OrdinalityOrdering(private), limitOrdering),
							),
							private,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.PushLimitIntoOrdinality, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [PushLimitIntoJoinLeft]
	{
		if input.Op() == opt.InnerJoinOp || input.Op() == opt.LeftJoinOp {
			left := input.Child(0).(memo.RelExpr)
			if !_f.funcs.HasOuterCols(left) {
				right := input.Child(1).(memo.RelExpr)
				on := *input.Child(2).(*memo.FiltersExpr)
				private := input.Private().(*memo.JoinPrivate)
				if _f.funcs.JoinPreservesLeftRows(input) {
					limitExpr := limit
					_const, _ := limitExpr.(*memo.ConstExpr)
					if _const != nil {
						limit := _const.Value
						if _f.funcs.IsPositiveInt(limit) {
							if !_f.funcs.LimitGeMaxRows(limit, left) {
								cols := _f.funcs.OutputCols(left)
								if _f.funcs.OrderingCanProjectCols(ordering, cols) {
									if _f.matchedRule == nil || _f.matchedRule(opt.PushLimitIntoJoinLeft) {
										on := on
										_expr := _f.ConstructLimit(
											_f.DynamicConstruct(
												input.Op(),
												_f.ConstructLimit(
													left,
													_const,
													_f.funcs.PruneOrdering(ordering, cols),
												),
												right,
												&on,
												private,
											).(memo.RelExpr),
											_const,
											ordering,
										)
										if _f.appliedRule != nil {
											_f.appliedRule(opt.PushLimitIntoJoinLeft, nil, _expr)
										}
										_f.constructorStackDepth--
										return _expr
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoJoinRight]
	{
		_innerJoin, _ := input.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			left := _innerJoin.Left
			right := _innerJoin.Right
			if !_f.funcs.HasOuterCols(right) {
				on := _innerJoin.On
				private := &_innerJoin.JoinPrivate
				if _f.funcs.JoinPreservesRightRows(_innerJoin) {
					limitExpr := limit
					_const, _ := limitExpr.(*memo.ConstExpr)
					if _const != nil {
						limit := _const.Value
						if _f.funcs.IsPositiveInt(limit) {
							if !_f.funcs.LimitGeMaxRows(limit, right) {
								cols := _f.funcs.OutputCols(right)
								if _f.funcs.OrderingCanProjectCols(ordering, cols) {
									if _f.matchedRule == nil || _f.matchedRule(opt.PushLimitIntoJoinRight) {
										_expr := _f.ConstructLimit(
											_f.ConstructInnerJoin(
												left,
												_f.ConstructLimit(
													right,
													_const,
													_f.funcs.PruneOrdering(ordering, cols),
												),
												on,
												private,
											),
											_const,
											ordering,
										)
										if _f.appliedRule != nil {
											_f.appliedRule(opt.PushLimitIntoJoinRight, nil, _expr)
										}
										_f.constructorStackDepth--
										return _expr
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [FoldLimits]
	{
		_limit, _ := input.(*memo.LimitExpr)
		if _limit != nil {
			innerInput := _limit.Input
			innerLimitExpr := _limit.Limit
			_const, _ := innerLimitExpr.(*memo.ConstExpr)
			if _const != nil {
				innerLimit := _const.Value
				innerOrdering := _limit.Ordering
				outerLimitExpr := limit
				_const2, _ := outerLimitExpr.(*memo.ConstExpr)
				if _const2 != nil {
					outerLimit := _const2.Value
					if !_f.funcs.IsGreaterThan(outerLimit, innerLimit) {
						outerOrdering := ordering
						if _f.funcs.OrderingImplies(innerOrdering, outerOrdering) {
							if _f.matchedRule == nil || _f.matchedRule(opt.FoldLimits) {
								_expr := _f.ConstructLimit(
									innerInput,
									_const2,
									innerOrdering,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.FoldLimits, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [SimplifyLimitOrdering]
	{
		if _f.funcs.CanSimplifyLimitOffsetOrdering(input, ordering) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyLimitOrdering) {
				_expr := _f.ConstructLimit(
					input,
					limit,
					_f.funcs.SimplifyLimitOffsetOrdering(input, ordering),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyLimitOrdering, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PushLimitIntoWindow]
	{
		_window, _ := input.(*memo.WindowExpr)
		if _window != nil {
			input := _window.Input
			fns := _window.Windows
			if _f.funcs.AllArePrefixSafe(fns) {
				private := &_window.WindowPrivate
				inputCols := _f.funcs.OutputCols(input)
				if _f.funcs.OrderingCanProjectCols(ordering, inputCols) {
					newOrdering, ok := _f.funcs.MakeSegmentedOrdering(input, _f.funcs.WindowPartition(private), _f.funcs.WindowOrdering(private), ordering)
					if ok {
						if _f.matchedRule == nil || _f.matchedRule(opt.PushLimitIntoWindow) {
							_expr := _f.ConstructWindow(
								_f.ConstructLimit(
									input,
									limit,
									_f.funcs.PruneOrdering(_f.funcs.DerefOrderingChoice(newOrdering), inputCols),
								),
								fns,
								private,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.PushLimitIntoWindow, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

	// [AssociateLimitJoinsLeft]
	{
		limitInput := input
		_innerJoin, _ := limitInput.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			outsideLeft := _innerJoin.Left
			_leftJoin, _ := outsideLeft.(*memo.LeftJoinExpr)
			if _leftJoin != nil {
				insideLeft := _leftJoin.Left
				insideRight := _leftJoin.Right
				insideOn := _leftJoin.On
				insidePrivate := &_leftJoin.JoinPrivate
				if _f.funcs.NoJoinHints(insidePrivate) {
					outsideRight := _innerJoin.Right
					outsideOn := _innerJoin.On
					if !_f.funcs.ColsIntersect(_f.funcs.FilterOuterCols(outsideOn), _f.funcs.OutputCols(insideRight)) {
						outsidePrivate := &_innerJoin.JoinPrivate
						if _f.funcs.NoJoinHints(outsidePrivate) {
							if !_f.funcs.JoinPreservesLeftRows(_innerJoin) {
								limitValue := limit
								limitOrdering := ordering
								if _f.matchedRule == nil || _f.matchedRule(opt.AssociateLimitJoinsLeft) {
									_expr := _f.ConstructLimit(
										_f.ConstructLeftJoin(
											_f.ConstructInnerJoin(
												insideLeft,
												outsideRight,
												outsideOn,
												_f.funcs.EmptyJoinPrivate(),
											),
											insideRight,
											insideOn,
											_f.funcs.EmptyJoinPrivate(),
										),
										limitValue,
										limitOrdering,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.AssociateLimitJoinsLeft, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [AssociateLimitJoinsRight]
	{
		limitInput := input
		_innerJoin, _ := limitInput.(*memo.InnerJoinExpr)
		if _innerJoin != nil {
			outsideLeft := _innerJoin.Left
			outsideRight := _innerJoin.Right
			_leftJoin, _ := outsideRight.(*memo.LeftJoinExpr)
			if _leftJoin != nil {
				insideLeft := _leftJoin.Left
				insideRight := _leftJoin.Right
				insideOn := _leftJoin.On
				insidePrivate := &_leftJoin.JoinPrivate
				if _f.funcs.NoJoinHints(insidePrivate) {
					outsideOn := _innerJoin.On
					if !_f.funcs.ColsIntersect(_f.funcs.FilterOuterCols(outsideOn), _f.funcs.OutputCols(insideRight)) {
						outsidePrivate := &_innerJoin.JoinPrivate
						if _f.funcs.NoJoinHints(outsidePrivate) {
							if !_f.funcs.JoinPreservesRightRows(_innerJoin) {
								limitValue := limit
								limitOrdering := ordering
								if _f.matchedRule == nil || _f.matchedRule(opt.AssociateLimitJoinsRight) {
									_expr := _f.ConstructLimit(
										_f.ConstructLeftJoin(
											_f.ConstructInnerJoin(
												insideLeft,
												outsideLeft,
												outsideOn,
												_f.funcs.EmptyJoinPrivate(),
											),
											insideRight,
											insideOn,
											_f.funcs.EmptyJoinPrivate(),
										),
										limitValue,
										limitOrdering,
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.AssociateLimitJoinsRight, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeLimit(input, limit, ordering)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructOffset constructs an expression for the Offset operator.
// Offset filters out the first Offset rows of the input relation; used in
// conjunction with Limit.
func (_f *Factory) ConstructOffset(
	input memo.RelExpr,
	offset opt.ScalarExpr,
	ordering props.OrderingChoice,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateOffset]
	{
		_const, _ := offset.(*memo.ConstExpr)
		if _const != nil {
			if _f.funcs.EqualsNumber(_const.Value, 0) {
				if _f.matchedRule == nil || _f.matchedRule(opt.EliminateOffset) {
					_expr := input
					if _f.appliedRule != nil {
						_f.appliedRule(opt.EliminateOffset, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [PushOffsetIntoProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			projections := _project.Projections
			passthrough := _project.Passthrough
			cols := _f.funcs.OutputCols(input)
			if _f.funcs.OrderingCanProjectCols(ordering, cols) {
				if _f.matchedRule == nil || _f.matchedRule(opt.PushOffsetIntoProject) {
					_expr := _f.ConstructProject(
						_f.ConstructOffset(
							input,
							offset,
							_f.funcs.PruneOrdering(ordering, cols),
						),
						projections,
						passthrough,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.PushOffsetIntoProject, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [SimplifyOffsetOrdering]
	{
		if _f.funcs.CanSimplifyLimitOffsetOrdering(input, ordering) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyOffsetOrdering) {
				_expr := _f.ConstructOffset(
					input,
					offset,
					_f.funcs.SimplifyLimitOffsetOrdering(input, ordering),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyOffsetOrdering, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeOffset(input, offset, ordering)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructTopK constructs an expression for the TopK operator.
// TopK returns the top K, where K is a constant, rows from the input set
// according to its sort ordering, discarding the remaining rows. The Limit is a
// constant positive integer; the operator returns at most Limit rows. Rows can
// be sorted by one or more of the input columns, each of which can be sorted in
// either ascending or descending order. See the Ordering field in the
// PhysicalProps struct.
//
// Unlike the Limit relational operator, TopK does not require its input to be
// ordered. However, if the input is known to have a partial ordering of the
// required ordering, TopK can take advantage of optimizations. TopK can be used
// to substitute a Limit that requires its input to be ordered and performs best
// when the input is not already fully ordered. TopK scans the input, storing the
// K rows that best meet the ordering requirement in a max heap, then sorts the K
// rows.
func (_f *Factory) ConstructTopK(
	input memo.RelExpr,
	topKPrivate *memo.TopKPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeTopK(input, topKPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructMax1Row constructs an expression for the Max1Row operator.
// Max1Row enforces that its input must return at most one row. If the input
// has more than one row, Max1Row raises an error with the specified error text.
//
// Max1Row is most often used as input to the Subquery operator. See the comment
// above Subquery for more details.
func (_f *Factory) ConstructMax1Row(
	input memo.RelExpr,
	errorText string,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateMax1Row]
	{
		if _f.funcs.HasZeroOrOneRow(input) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateMax1Row) {
				_expr := input
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateMax1Row, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeMax1Row(input, errorText)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructOrdinality constructs an expression for the Ordinality operator.
// Ordinality adds a column to each row in its input containing a unique,
// increasing number.
func (_f *Factory) ConstructOrdinality(
	input memo.RelExpr,
	ordinalityPrivate *memo.OrdinalityPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyOrdinalityOrdering]
	{
		if _f.funcs.CanSimplifyOrdinalityOrdering(input, ordinalityPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyOrdinalityOrdering) {
				_expr := _f.ConstructOrdinality(
					input,
					_f.funcs.SimplifyOrdinalityOrdering(input, ordinalityPrivate),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyOrdinalityOrdering, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeOrdinality(input, ordinalityPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructProjectSet constructs an expression for the ProjectSet operator.
// ProjectSet represents a relational operator which zips through a list of
// generators for every row of the input.
//
// As a reminder, a functional zip over generators a,b,c returns tuples of
// values from a,b,c picked "simultaneously". NULLs are used when a generator is
// "shorter" than another.  For example:
//
//	zip([1,2,3], ['a','b']) = [(1,'a'), (2,'b'), (3, null)]
//
// ProjectSet corresponds to a relational operator project(R, a, b, c, ...)
// which, for each row in R, produces all the rows produced by zip(a, b, c, ...)
// with the values of R prefixed. Formally, this performs a lateral cross join
// of R with zip(a,b,c).
//
// See the Zip header for more details.
func (_f *Factory) ConstructProjectSet(
	input memo.RelExpr,
	zip memo.ZipExpr,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [DecorrelateProjectSet]
	{
		_values, _ := input.(*memo.ValuesExpr)
		if _values == nil {
			if !_f.funcs.IsZipCorrelated(zip, _f.funcs.OutputCols(input)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.DecorrelateProjectSet) {
					_expr := _f.ConstructInnerJoin(
						input,
						_f.ConstructProjectSet(
							_f.funcs.ConstructNoColsRow(),
							zip,
						),
						memo.EmptyFiltersExpr,
						_f.funcs.EmptyJoinPrivate(),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.DecorrelateProjectSet, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [ConvertZipArraysToValues]
	{
		if _f.funcs.CanConstructValuesFromZips(zip) {
			if _f.matchedRule == nil || _f.matchedRule(opt.ConvertZipArraysToValues) {
				_expr := _f.ConstructInnerJoinApply(
					input,
					_f.funcs.ConstructValuesFromZips(zip),
					memo.EmptyFiltersExpr,
					_f.funcs.EmptyJoinPrivate(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ConvertZipArraysToValues, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [HoistProjectSetSubquery]
	{
		for i := range zip {
			item := &zip[i]
			if _f.funcs.HasHoistableSubquery(item) {
				if _f.matchedRule == nil || _f.matchedRule(opt.HoistProjectSetSubquery) {
					_expr := _f.funcs.HoistProjectSetSubquery(input, zip).(memo.RelExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.HoistProjectSetSubquery, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeProjectSet(input, zip)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructWindow constructs an expression for the Window operator.
// Window represents a window function. Window functions are operators which
// allow computations that take into consideration other rows in the same result
// set.
//
// More concretely, a window function is a relational operator that takes in a
// result set and appends a single new column whose value depends on the other
// rows within the result set, and that row's relative position in it.
//
// Depending on the exact window function being computed, the value of the new
// column could be the position of the row in the output (`row_number`), or a
// cumulative sum, or something else.
func (_f *Factory) ConstructWindow(
	input memo.RelExpr,
	windows memo.WindowsExpr,
	windowPrivate *memo.WindowPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateWindow]
	{
		if len(windows) == 0 {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateWindow) {
				_expr := input
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateWindow, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [ReduceWindowPartitionCols]
	{
		fn := windows
		private := windowPrivate
		redundantCols := _f.funcs.RedundantCols(input, _f.funcs.WindowPartition(private))
		if !_f.funcs.ColsAreEmpty(redundantCols) {
			if _f.matchedRule == nil || _f.matchedRule(opt.ReduceWindowPartitionCols) {
				_expr := _f.ConstructWindow(
					input,
					fn,
					_f.funcs.RemoveWindowPartitionCols(private, redundantCols),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ReduceWindowPartitionCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyWindowOrdering]
	{
		fn := windows
		private := windowPrivate
		if _f.funcs.CanSimplifyWindowOrdering(input, private) {
			if !_f.funcs.HasRangeFrameWithOffset(fn) {
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyWindowOrdering) {
					_expr := _f.ConstructWindow(
						input,
						fn,
						_f.funcs.SimplifyWindowOrdering(input, private),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyWindowOrdering, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeWindow(input, windows, windowPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructWith constructs an expression for the With operator.
// With executes Binding, making its results available to Main. Within Main, the
// results of Binding may be referenced by a WithScan expression containing the
// ID of this With.
func (_f *Factory) ConstructWith(
	binding memo.RelExpr,
	main memo.RelExpr,
	withPrivate *memo.WithPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyWithBindingOrdering]
	{
		if _f.funcs.CanSimplifyWithBindingOrdering(binding, withPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyWithBindingOrdering) {
				_expr := _f.ConstructWith(
					binding,
					main,
					_f.funcs.SimplifyWithBindingOrdering(binding, withPrivate),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyWithBindingOrdering, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [InlineWith]
	{
		input := main
		if _f.funcs.CanInlineWith(binding, input, withPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.InlineWith) {
				_expr := _f.funcs.InlineWith(binding, input, withPrivate).(memo.RelExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.InlineWith, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeWith(binding, main, withPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructWithScan constructs an expression for the WithScan operator.
// WithScan returns the results present in the With expression referenced
// by ID.
// Note that in order to construct a WithScan, the WithID must have a bound
// expression in the metadata.
func (_f *Factory) ConstructWithScan(
	withScanPrivate *memo.WithScanPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeWithScan(withScanPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRecursiveCTE constructs an expression for the RecursiveCTE operator.
// RecursiveCTE implements the logic of a recursive CTE:
//   - the Initial query is evaluated; the results are emitted and also saved into
//     a "working table".
//   - so long as the working table is not empty:
//   - the Recursive query (which refers to the working table using a specific
//     WithID) is evaluated; the results are emitted and also saved into a new
//     "working table" for the next iteration.
func (_f *Factory) ConstructRecursiveCTE(
	binding memo.RelExpr,
	initial memo.RelExpr,
	recursive memo.RelExpr,
	recursiveCTEPrivate *memo.RecursiveCTEPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRecursiveCTE(binding, initial, recursive, recursiveCTEPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFakeRel constructs an expression for the FakeRel operator.
// FakeRel is a mock relational operator used for testing and as a dummy binding
// relation for building cascades; its logical properties are pre-determined and
// stored in the private. It can be used as the child of an operator for which we
// are calculating properties or statistics.
func (_f *Factory) ConstructFakeRel(
	fakeRelPrivate *memo.FakeRelPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeFakeRel(fakeRelPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSubquery constructs an expression for the Subquery operator.
// Subquery is a subquery in a single-row context. Here are some examples:
//
//	SELECT 1 = (SELECT 1)
//	SELECT (1, 'a') = (SELECT 1, 'a')`
//
// In a single-row context, the outer query is only valid if the subquery returns
// at most one row. Subqueries in a multi-row context can be transformed to a
// single row context using the Any operator. See the comment above the Any
// operator for more details.
//
// The Input field contains the subquery itself, which should be wrapped in a
// Max1Row operator to enforce that the subquery can return at most one row
// (Max1Row may be removed by the optimizer later if it can determine statically
// that the subquery will always return at most one row). In addition, the
// subquery must project exactly one output column. If the subquery returns one
// row, then that column is bound to the single column value in that row. If the
// subquery returns zero rows, then that column is bound to NULL.
func (_f *Factory) ConstructSubquery(
	input memo.RelExpr,
	subqueryPrivate *memo.SubqueryPrivate,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeSubquery(input, subqueryPrivate)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAny constructs an expression for the Any operator.
// Any is a SQL operator that applies a comparison to every row of an input
// subquery and returns true if any of the comparisons are true, else returns
// null if any of the comparisons are null, else returns false. The following
// transformations map from various SQL operators into the Any operator:
//
//	<scalar> IN (<subquery>)
//	==> (Any <subquery> <scalar> EqOp)
//
//	<scalar> NOT IN (<subquery>)
//	==> (Not (Any <subquery> <scalar> EqOp))
//
//	<scalar> <cmp> {SOME|ANY}(<subquery>)
//	==> (Any <subquery> <scalar> <cmp>)
//
//	<scalar> <cmp> ALL(<subquery>)
//	==> (Not (Any <subquery> <scalar> <negated-cmp>))
//
// Any expects the input subquery to return a single column of any data type. The
// scalar value is compared with that column using the specified comparison
// operator.
func (_f *Factory) ConstructAny(
	input memo.RelExpr,
	scalar opt.ScalarExpr,
	subqueryPrivate *memo.SubqueryPrivate,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [InlineAnyValuesSingleCol]
	{
		values := input
		_values, _ := values.(*memo.ValuesExpr)
		if _values != nil {
			private := subqueryPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.InlineAnyValuesSingleCol) {
				_expr := _f.ConstructAnyScalar(
					scalar,
					_f.funcs.InlineValues(_values),
					_f.funcs.SubqueryCmp(private),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.InlineAnyValuesSingleCol, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [InlineAnyValuesMultiCol]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			values := _project.Input
			_values, _ := values.(*memo.ValuesExpr)
			if _values != nil {
				valuesPrivate := &_values.ValuesPrivate
				if len(_project.Projections) == 1 {
					_item := &_project.Projections[0]
					tuple := _item.Element
					_tuple, _ := tuple.(*memo.TupleExpr)
					if _tuple != nil {
						if _f.funcs.IsTupleOfVars(_tuple, _f.funcs.ValuesCols(valuesPrivate)) {
							passthrough := _project.Passthrough
							if _f.funcs.ColsAreEmpty(passthrough) {
								private := subqueryPrivate
								if _f.matchedRule == nil || _f.matchedRule(opt.InlineAnyValuesMultiCol) {
									_expr := _f.ConstructAnyScalar(
										scalar,
										_f.funcs.InlineValues(_values),
										_f.funcs.SubqueryCmp(private),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.InlineAnyValuesMultiCol, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeAny(input, scalar, subqueryPrivate)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructExists constructs an expression for the Exists operator.
// Exists takes a relational query as its input, and evaluates to true if the
// query returns at least one row.
func (_f *Factory) ConstructExists(
	input memo.RelExpr,
	subqueryPrivate *memo.SubqueryPrivate,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateExistsZeroRows]
	{
		if _f.funcs.HasZeroRows(input) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateExistsZeroRows) {
				_expr := _f.ConstructFalse()
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateExistsZeroRows, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateExistsProject]
	{
		_project, _ := input.(*memo.ProjectExpr)
		if _project != nil {
			input := _project.Input
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateExistsProject) {
				_expr := _f.ConstructExists(
					input,
					subqueryPrivate,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateExistsProject, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [EliminateExistsGroupBy]
	{
		if input.Op() == opt.GroupByOp || input.Op() == opt.DistinctOnOp {
			input := input.Child(0).(memo.RelExpr)
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateExistsGroupBy) {
				_expr := _f.ConstructExists(
					input,
					subqueryPrivate,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateExistsGroupBy, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [InlineExistsSelectTuple]
	{
		_select, _ := input.(*memo.SelectExpr)
		if _select != nil {
			_project, _ := _select.Input.(*memo.ProjectExpr)
			if _project != nil {
				input := _project.Input
				for i := range _project.Projections {
					_item := &_project.Projections[i]
					tuple := _item.Element
					_tuple, _ := tuple.(*memo.TupleExpr)
					if _tuple != nil {
						tupleCol := _item.Col
						filters := _select.Filters
						for i := range filters {
							item := &filters[i]
							_eq, _ := item.Condition.(*memo.EqExpr)
							if _eq != nil {
								_variable, _ := _eq.Left.(*memo.VariableExpr)
								if _variable != nil {
									varCol := _variable.Col
									if _f.funcs.EqualsColumn(varCol, tupleCol) {
										rhs := _eq.Right
										_tuple2, _ := rhs.(*memo.TupleExpr)
										if _tuple2 != nil {
											if _f.funcs.TuplesHaveSameLength(_tuple, _tuple2) {
												if _f.matchedRule == nil || _f.matchedRule(opt.InlineExistsSelectTuple) {
													_expr := _f.ConstructExists(
														_f.ConstructSelect(
															input,
															_f.funcs.ConcatFilters(_f.funcs.RemoveFiltersItem(filters, item), _f.funcs.SplitTupleEq(_tuple, _tuple2)),
														),
														subqueryPrivate,
													)
													if _f.appliedRule != nil {
														_f.appliedRule(opt.InlineExistsSelectTuple, nil, _expr)
													}
													_f.constructorStackDepth--
													return _expr
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [IntroduceExistsLimit]
	{
		if !_f.funcs.HasOuterCols(input) {
			if !_f.funcs.HasZeroOrOneRow(input) {
				if !_f.funcs.IsLimited(subqueryPrivate) {
					if _f.matchedRule == nil || _f.matchedRule(opt.IntroduceExistsLimit) {
						_expr := _f.ConstructExists(
							_f.ConstructLimit(
								input,
								_f.funcs.IntConst(tree.NewDInt(1)),
								_f.funcs.EmptyOrdering(),
							),
							_f.funcs.MakeLimited(subqueryPrivate),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.IntroduceExistsLimit, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [EliminateExistsLimit]
	{
		_limit, _ := input.(*memo.LimitExpr)
		if _limit != nil {
			input := _limit.Input
			if _f.funcs.HasOuterCols(input) {
				_const, _ := _limit.Limit.(*memo.ConstExpr)
				if _const != nil {
					limit := _const.Value
					if _f.funcs.IsPositiveInt(limit) {
						if _f.matchedRule == nil || _f.matchedRule(opt.EliminateExistsLimit) {
							_expr := _f.ConstructExists(
								input,
								subqueryPrivate,
							)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.EliminateExistsLimit, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeExists(input, subqueryPrivate)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructVariable constructs an expression for the Variable operator.
// Variable is the typed scalar value of a column in the query. The Col field is
// a metadata ColumnID value that references the column by index.
func (_f *Factory) ConstructVariable(
	col opt.ColumnID,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeVariable(col)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructConst constructs an expression for the Const operator.
// Const is a typed scalar constant value. The Value field is a tree.Datum value
// having any datum type that's legal in the expression's context. Do NOT call
// ConstructConst directly; use ConstructConstVal instead.
func (_f *Factory) ConstructConst(
	value tree.Datum,
	typ *types.T,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeConst(value, typ)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNull constructs an expression for the Null operator.
// Null is the constant SQL null value that has "unknown value" semantics. If
// the Typ field is not types.Unknown, then the value is known to be in the
// domain of that type. This is important for preserving correct types in
// replacement patterns. For example:
//
//	(Plus (Function ...) (Const 1))
//
// If the function in that expression has a static type of Int, but then it gets
// constant folded to (Null), then its type must remain as Int. Any other type
// violates logical equivalence of the expression, breaking type inference and
// possibly changing the results of execution. The solution is to tag the null
// with the correct type:
//
//	(Plus (Null (Int)) (Const 1))
//
// Null is its own operator rather than a Const datum in order to make matching
// and replacement easier and more efficient, as patterns can contain (Null)
// expressions.
func (_f *Factory) ConstructNull(
	typ *types.T,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeNull(typ)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructTrue constructs an expression for the True operator.
// True is the boolean true value that is equivalent to the tree.DBoolTrue datum
// value. It is a separate operator to make matching and replacement simpler and
// more efficient, as patterns can contain (True) expressions.
func (_f *Factory) ConstructTrue() opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeTrue()
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFalse constructs an expression for the False operator.
// False is the boolean false value that is equivalent to the tree.DBoolFalse
// datum value. It is a separate operator to make matching and replacement
// simpler and more efficient, as patterns can contain (False) expressions.
func (_f *Factory) ConstructFalse() opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeFalse()
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructPlaceholder constructs an expression for the Placeholder operator.
func (_f *Factory) ConstructPlaceholder(
	value tree.TypedExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizePlaceholder(value)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructTuple constructs an expression for the Tuple operator.
func (_f *Factory) ConstructTuple(
	elems memo.ScalarListExpr,
	typ *types.T,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeTuple(elems, typ)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructProjectionsItem constructs an expression for the ProjectionsItem operator.
// ProjectionsItem encapsulates the information needed to synthesize an output
// column, including its ColumnID and the scalar expression that produces its
// value. In addition, the ProjectionsItem caches a set of scalar properties that
// are lazily calculated by traversing the Element scalar expression. This allows
// the properties for the entire expression subtree to be calculated once and
// then repeatedly reused.
//
// The Element scalar expression cannot contain a simple VariableOp with the same
// ColumnID as the one stored in the Col field, since that would make it a
// pass-through column. Pass-through columns are always stored on the containing
// Project operator instead. However, the Element field can contain a VariableOp
// when a new ColumnID is being assigned, such as in the case of an outer column
// reference.
func (_f *Factory) ConstructProjectionsItem(
	element opt.ScalarExpr,
	col opt.ColumnID,
) memo.ProjectionsItem {
	item := memo.ProjectionsItem{Element: element, Col: col}
	item.PopulateProps(_f.mem)
	return item
}

// ConstructAggregationsItem constructs an expression for the AggregationsItem operator.
// AggregationsItem encapsulates the information for constructing an aggregate
// output column, including its ColumnID and the aggregate expression that
// produces its value. In addition, the AggregationsItem caches a set of scalar
// properties that are lazily calculated by traversing the Agg scalar expression.
// This allows the properties for the aggregate expression to be calculated once
// and then repeatedly reused.
//
// The aggregate expression can only consist of aggregate functions, variable
// references, and modifiers like AggDistinct. Examples of valid expressions:
//
//	(Min (Variable 1))
//	(Count (AggDistinct (Variable 1)))
//
// More complex arguments must be formulated using a Project operator as input to
// the grouping operator.
func (_f *Factory) ConstructAggregationsItem(
	agg opt.ScalarExpr,
	col opt.ColumnID,
) memo.AggregationsItem {
	item := memo.AggregationsItem{Agg: agg, Col: col}
	item.PopulateProps(_f.mem)
	return item
}

// ConstructFiltersItem constructs an expression for the FiltersItem operator.
// FiltersItem contains a filter condition that's evaluated to determine whether
// Select or Join rows should be filtered. In addition, the FiltersItem caches a
// set of scalar properties that are calculated by traversing the Condition
// scalar expression. This allows the properties for the entire expression
// subtree to be calculated once and then repeatedly reused.
func (_f *Factory) ConstructFiltersItem(
	condition opt.ScalarExpr,
) memo.FiltersItem {
	item := memo.FiltersItem{Condition: condition}
	item.PopulateProps(_f.mem)
	return item
}

// ConstructZipItem constructs an expression for the ZipItem operator.
// ZipItem contains a generator function or scalar expression that is contained
// in a Zip. It also contains the list of output columns for the generator or
// scalar expression in the ZipItem. Cols is a list since a single function may
// output multiple columns (e.g. pg_get_keywords() outputs three columns).
//
// See the Zip header for more details.
func (_f *Factory) ConstructZipItem(
	fn opt.ScalarExpr,
	cols opt.ColList,
) memo.ZipItem {
	item := memo.ZipItem{Fn: fn, Cols: cols}
	item.PopulateProps(_f.mem)
	return item
}

// ConstructAnd constructs an expression for the And operator.
// And is the boolean conjunction operator that evaluates to true only if both of
// its conditions evaluate to true.
func (_f *Factory) ConstructAnd(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [NormalizeNestedAnds]
	{
		_and, _ := right.(*memo.AndExpr)
		if _and != nil {
			innerLeft := _and.Left
			innerRight := _and.Right
			if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeNestedAnds) {
				_expr := _f.ConstructAnd(
					_f.funcs.ConcatLeftDeepAnds(left, innerLeft),
					innerRight,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.NormalizeNestedAnds, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyTrueAnd]
	{
		_true, _ := left.(*memo.TrueExpr)
		if _true != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyTrueAnd) {
				_expr := right
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyTrueAnd, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyAndTrue]
	{
		_true, _ := right.(*memo.TrueExpr)
		if _true != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyAndTrue) {
				_expr := left
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyAndTrue, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyFalseAnd]
	{
		_false, _ := left.(*memo.FalseExpr)
		if _false != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyFalseAnd) {
				_expr := _false
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyFalseAnd, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyAndFalse]
	{
		_false, _ := right.(*memo.FalseExpr)
		if _false != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyAndFalse) {
				_expr := _false
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyAndFalse, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullAndOr]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			_null2, _ := right.(*memo.NullExpr)
			if _null2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullAndOr) {
					_expr := _f.ConstructNull(
						_f.funcs.BoolType(),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullAndOr, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeAnd(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructOr constructs an expression for the Or operator.
// Or is the boolean disjunction operator that evaluates to true if either one of
// its conditions evaluates to true.
func (_f *Factory) ConstructOr(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyTrueOr]
	{
		_true, _ := left.(*memo.TrueExpr)
		if _true != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyTrueOr) {
				_expr := _true
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyTrueOr, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyOrTrue]
	{
		_true, _ := right.(*memo.TrueExpr)
		if _true != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyOrTrue) {
				_expr := _true
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyOrTrue, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyFalseOr]
	{
		_false, _ := left.(*memo.FalseExpr)
		if _false != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyFalseOr) {
				_expr := right
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyFalseOr, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyOrFalse]
	{
		_false, _ := right.(*memo.FalseExpr)
		if _false != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyOrFalse) {
				_expr := left
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyOrFalse, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullAndOr]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			_null2, _ := right.(*memo.NullExpr)
			if _null2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullAndOr) {
					_expr := _f.ConstructNull(
						_f.funcs.BoolType(),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullAndOr, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [ExtractRedundantConjunct]
	{
		_or, _ := left.(*memo.OrExpr)
		if _or == nil {
			_or2, _ := right.(*memo.OrExpr)
			if _or2 == nil {
				conjunct, ok := _f.funcs.FindRedundantConjunct(left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.ExtractRedundantConjunct) {
						_expr := _f.funcs.ExtractRedundantConjunct(conjunct, left, right).(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.ExtractRedundantConjunct, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeOr(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRange constructs an expression for the Range operator.
// Range contains an And expression that constrains a single variable to a
// range. For example, the And expression might be x > 5 AND x < 10. The
// children of the And expression can be arbitrary expressions (including nested
// And expressions), but they must all constrain the same variable, and the
// constraints must be tight.
//
// Currently, Range expressions are only created by the ConsolidateSelectFilters
// normalization rule.
func (_f *Factory) ConstructRange(
	and opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyRange]
	{
		input := and
		_and, _ := input.(*memo.AndExpr)
		if _and == nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyRange) {
				_expr := input
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyRange, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeRange(and)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNot constructs an expression for the Not operator.
// Not is the boolean negation operator that evaluates to true if its input
// evaluates to false.
func (_f *Factory) ConstructNot(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNotTrue]
	{
		_true, _ := input.(*memo.TrueExpr)
		if _true != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNotTrue) {
				_expr := _f.ConstructFalse()
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNotTrue, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNotFalse]
	{
		_false, _ := input.(*memo.FalseExpr)
		if _false != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNotFalse) {
				_expr := _f.ConstructTrue()
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNotFalse, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNotNull]
	{
		_null, _ := input.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNotNull) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNotNull, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [NegateComparison]
	{
		if opt.IsComparisonOp(input) {
			left := input.Child(0).(opt.ScalarExpr)
			right := input.Child(1).(opt.ScalarExpr)
			op := input.Op()
			if _f.funcs.CanNegateComparison(op) {
				if _f.matchedRule == nil || _f.matchedRule(opt.NegateComparison) {
					_expr := _f.funcs.NegateComparison(op, left, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NegateComparison, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [EliminateNot]
	{
		_not, _ := input.(*memo.NotExpr)
		if _not != nil {
			input := _not.Input
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateNot) {
				_expr := input
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateNot, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [NegateAnd]
	{
		_and, _ := input.(*memo.AndExpr)
		if _and != nil {
			left := _and.Left
			right := _and.Right
			if _f.matchedRule == nil || _f.matchedRule(opt.NegateAnd) {
				_expr := _f.ConstructOr(
					_f.ConstructNot(
						left,
					),
					_f.ConstructNot(
						right,
					),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.NegateAnd, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [NegateOr]
	{
		_or, _ := input.(*memo.OrExpr)
		if _or != nil {
			left := _or.Left
			right := _or.Right
			if _f.matchedRule == nil || _f.matchedRule(opt.NegateOr) {
				_expr := _f.ConstructAnd(
					_f.ConstructNot(
						left,
					),
					_f.ConstructNot(
						right,
					),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.NegateOr, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyNotDisjoint]
	{
		_function, _ := input.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_disjoint") {
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyNotDisjoint) {
					_expr := _f.funcs.MakeIntersectionFunction(args).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyNotDisjoint, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeNot(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIsTupleNull constructs an expression for the IsTupleNull operator.
// IsTupleNull is the boolean expression with a tuple input that evaluates to
// true if the tuple is null or all elements in the tuple are null.
func (_f *Factory) ConstructIsTupleNull(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullTupleIsTupleNull]
	{
		_tuple, _ := input.(*memo.TupleExpr)
		if _tuple != nil {
			if _f.funcs.HasAllNullElements(_tuple) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullTupleIsTupleNull) {
					_expr := _f.ConstructTrue()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullTupleIsTupleNull, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNonNullTupleIsTupleNull]
	{
		_tuple, _ := input.(*memo.TupleExpr)
		if _tuple != nil {
			if _f.funcs.HasNonNullElement(_tuple) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNonNullTupleIsTupleNull) {
					_expr := _f.ConstructFalse()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNonNullTupleIsTupleNull, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeIsTupleNull(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIsTupleNotNull constructs an expression for the IsTupleNotNull operator.
// IsTupleNotNull is the boolean expression with a tuple input that evaluates to
// true if the tuple is not null and all elements in the tuple are not null.
func (_f *Factory) ConstructIsTupleNotNull(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNonNullTupleIsTupleNotNull]
	{
		_tuple, _ := input.(*memo.TupleExpr)
		if _tuple != nil {
			if _f.funcs.HasAllNonNullElements(_tuple) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNonNullTupleIsTupleNotNull) {
					_expr := _f.ConstructTrue()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNonNullTupleIsTupleNotNull, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullTupleIsTupleNotNull]
	{
		_tuple, _ := input.(*memo.TupleExpr)
		if _tuple != nil {
			if _f.funcs.HasNullElement(_tuple) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullTupleIsTupleNotNull) {
					_expr := _f.ConstructFalse()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullTupleIsTupleNotNull, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeIsTupleNotNull(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructEq constructs an expression for the Eq operator.
func (_f *Factory) ConstructEq(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [NormalizeCmpPlusConst]
	{
		_plus, _ := left.(*memo.PlusExpr)
		if _plus != nil {
			leftLeft := _plus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _plus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpPlusConst) {
								_expr := _f.ConstructEq(
									leftLeft,
									_f.ConstructMinus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpPlusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _minus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.PlusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpMinusConst) {
								_expr := _f.ConstructEq(
									leftLeft,
									_f.ConstructPlus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpMinusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if opt.IsConstValueOp(leftLeft) {
				leftRight := _minus.Right
				if !(opt.IsConstValueOp(leftRight)) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, leftLeft, right) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpConstMinus) {
								_expr := _f.ConstructEq(
									_f.ConstructMinus(
										leftLeft,
										right,
									),
									leftRight,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpConstMinus, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeTupleEquality]
	{
		_tuple, _ := left.(*memo.TupleExpr)
		if _tuple != nil {
			left := _tuple.Elems
			_tuple2, _ := right.(*memo.TupleExpr)
			if _tuple2 != nil {
				right := _tuple2.Elems
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeTupleEquality) {
					_expr := _f.funcs.NormalizeTupleEquality(left, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeTupleEquality, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [NormalizeCmpTimeZoneFunction]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestampTZ(right) {
						ts := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestamp(ts) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(ts) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunction) {
									_expr := _f.ConstructEq(
										ts,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunction, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpTimeZoneFunctionTZ]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestamp(right) {
						tz := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestampTZ(tz) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(tz) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunctionTZ) {
									_expr := _f.ConstructEq(
										tz,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunctionTZ, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [FoldEqZeroSTDistance]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_distance") {
				if !_f.funcs.STDistanceUseSpheroid(args) {
					_const, _ := right.(*memo.ConstExpr)
					if _const != nil {
						value := _const.Value
						if _f.funcs.IsFloatDatum(value) {
							if _f.funcs.DatumsEqual(value, tree.NewDInt(0)) {
								if _f.matchedRule == nil || _f.matchedRule(opt.FoldEqZeroSTDistance) {
									_expr := _f.funcs.MakeIntersectionFunction(args).(opt.ScalarExpr)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.FoldEqZeroSTDistance, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [FoldEqTrue]
	{
		_true, _ := right.(*memo.TrueExpr)
		if _true != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldEqTrue) {
				_expr := left
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldEqTrue, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldEqFalse]
	{
		_false, _ := right.(*memo.FalseExpr)
		if _false != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldEqFalse) {
				_expr := _f.ConstructNot(
					left,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldEqFalse, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.EqOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [CommuteVar]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVar) {
					_expr := _f.ConstructEq(
						_variable2,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVar, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConst]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConst) {
					_expr := _f.ConstructEq(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructEq(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifySameVarEqualities]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.funcs.VarsAreSame(_variable, _variable2) {
					if _f.matchedRule == nil || _f.matchedRule(opt.SimplifySameVarEqualities) {
						_expr := _f.ConstructOr(
							_f.ConstructIsNot(
								_variable,
								_f.ConstructNull(
									_f.funcs.TypeOf(_variable),
								),
							),
							_f.ConstructNull(
								_f.funcs.BoolType(),
							),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.SimplifySameVarEqualities, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeEq(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLt constructs an expression for the Lt operator.
func (_f *Factory) ConstructLt(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [CommuteVarInequality]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVarInequality) {
					_expr := _f.funcs.CommuteInequality(opt.LtOp, left, _variable2).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVarInequality, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConstInequality]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConstInequality) {
					_expr := _f.funcs.CommuteInequality(opt.LtOp, left, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConstInequality, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeCmpPlusConst]
	{
		_plus, _ := left.(*memo.PlusExpr)
		if _plus != nil {
			leftLeft := _plus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _plus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpPlusConst) {
								_expr := _f.ConstructLt(
									leftLeft,
									_f.ConstructMinus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpPlusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _minus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.PlusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpMinusConst) {
								_expr := _f.ConstructLt(
									leftLeft,
									_f.ConstructPlus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpMinusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if opt.IsConstValueOp(leftLeft) {
				leftRight := _minus.Right
				if !(opt.IsConstValueOp(leftRight)) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, leftLeft, right) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpConstMinus) {
								_expr := _f.ConstructLt(
									_f.ConstructMinus(
										leftLeft,
										right,
									),
									leftRight,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpConstMinus, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [NormalizeCmpTimeZoneFunction]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestampTZ(right) {
						ts := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestamp(ts) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(ts) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunction) {
									_expr := _f.ConstructLt(
										ts,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunction, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpTimeZoneFunctionTZ]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestamp(right) {
						tz := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestampTZ(tz) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(tz) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunctionTZ) {
									_expr := _f.ConstructLt(
										tz,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunctionTZ, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [FoldCmpSTDistanceLeft]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_distance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTDistanceLeft) {
					_expr := _f.funcs.MakeSTDWithinLeft(opt.LtOp, args, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTDistanceLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTDistanceRight]
	{
		_function, _ := right.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_distance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTDistanceRight) {
					_expr := _f.funcs.MakeSTDWithinRight(opt.LtOp, args, left).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTDistanceRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTMaxDistanceLeft]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_maxdistance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTMaxDistanceLeft) {
					_expr := _f.funcs.MakeSTDFullyWithinLeft(opt.LtOp, args, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTMaxDistanceLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTMaxDistanceRight]
	{
		_function, _ := right.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_maxdistance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTMaxDistanceRight) {
					_expr := _f.funcs.MakeSTDFullyWithinRight(opt.LtOp, args, left).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTMaxDistanceRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.LtOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructLt(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifySameVarInequalities]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.funcs.VarsAreSame(_variable, _variable2) {
					if _f.matchedRule == nil || _f.matchedRule(opt.SimplifySameVarInequalities) {
						_expr := _f.ConstructAnd(
							_f.ConstructIs(
								_variable,
								_f.ConstructNull(
									_f.funcs.TypeOf(_variable),
								),
							),
							_f.ConstructNull(
								_f.funcs.BoolType(),
							),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.SimplifySameVarInequalities, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeLt(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructGt constructs an expression for the Gt operator.
func (_f *Factory) ConstructGt(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [CommuteVarInequality]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVarInequality) {
					_expr := _f.funcs.CommuteInequality(opt.GtOp, left, _variable2).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVarInequality, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConstInequality]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConstInequality) {
					_expr := _f.funcs.CommuteInequality(opt.GtOp, left, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConstInequality, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeCmpPlusConst]
	{
		_plus, _ := left.(*memo.PlusExpr)
		if _plus != nil {
			leftLeft := _plus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _plus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpPlusConst) {
								_expr := _f.ConstructGt(
									leftLeft,
									_f.ConstructMinus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpPlusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _minus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.PlusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpMinusConst) {
								_expr := _f.ConstructGt(
									leftLeft,
									_f.ConstructPlus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpMinusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if opt.IsConstValueOp(leftLeft) {
				leftRight := _minus.Right
				if !(opt.IsConstValueOp(leftRight)) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, leftLeft, right) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpConstMinus) {
								_expr := _f.ConstructGt(
									_f.ConstructMinus(
										leftLeft,
										right,
									),
									leftRight,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpConstMinus, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [NormalizeCmpTimeZoneFunction]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestampTZ(right) {
						ts := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestamp(ts) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(ts) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunction) {
									_expr := _f.ConstructGt(
										ts,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunction, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpTimeZoneFunctionTZ]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestamp(right) {
						tz := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestampTZ(tz) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(tz) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunctionTZ) {
									_expr := _f.ConstructGt(
										tz,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunctionTZ, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [FoldCmpSTDistanceLeft]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_distance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTDistanceLeft) {
					_expr := _f.funcs.MakeSTDWithinLeft(opt.GtOp, args, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTDistanceLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTDistanceRight]
	{
		_function, _ := right.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_distance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTDistanceRight) {
					_expr := _f.funcs.MakeSTDWithinRight(opt.GtOp, args, left).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTDistanceRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTMaxDistanceLeft]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_maxdistance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTMaxDistanceLeft) {
					_expr := _f.funcs.MakeSTDFullyWithinLeft(opt.GtOp, args, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTMaxDistanceLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTMaxDistanceRight]
	{
		_function, _ := right.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_maxdistance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTMaxDistanceRight) {
					_expr := _f.funcs.MakeSTDFullyWithinRight(opt.GtOp, args, left).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTMaxDistanceRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.GtOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructGt(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifySameVarInequalities]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.funcs.VarsAreSame(_variable, _variable2) {
					if _f.matchedRule == nil || _f.matchedRule(opt.SimplifySameVarInequalities) {
						_expr := _f.ConstructAnd(
							_f.ConstructIs(
								_variable,
								_f.ConstructNull(
									_f.funcs.TypeOf(_variable),
								),
							),
							_f.ConstructNull(
								_f.funcs.BoolType(),
							),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.SimplifySameVarInequalities, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeGt(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLe constructs an expression for the Le operator.
func (_f *Factory) ConstructLe(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [CommuteVarInequality]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVarInequality) {
					_expr := _f.funcs.CommuteInequality(opt.LeOp, left, _variable2).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVarInequality, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConstInequality]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConstInequality) {
					_expr := _f.funcs.CommuteInequality(opt.LeOp, left, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConstInequality, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeCmpPlusConst]
	{
		_plus, _ := left.(*memo.PlusExpr)
		if _plus != nil {
			leftLeft := _plus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _plus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpPlusConst) {
								_expr := _f.ConstructLe(
									leftLeft,
									_f.ConstructMinus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpPlusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _minus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.PlusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpMinusConst) {
								_expr := _f.ConstructLe(
									leftLeft,
									_f.ConstructPlus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpMinusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if opt.IsConstValueOp(leftLeft) {
				leftRight := _minus.Right
				if !(opt.IsConstValueOp(leftRight)) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, leftLeft, right) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpConstMinus) {
								_expr := _f.ConstructLe(
									_f.ConstructMinus(
										leftLeft,
										right,
									),
									leftRight,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpConstMinus, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [NormalizeCmpTimeZoneFunction]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestampTZ(right) {
						ts := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestamp(ts) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(ts) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunction) {
									_expr := _f.ConstructLe(
										ts,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunction, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpTimeZoneFunctionTZ]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestamp(right) {
						tz := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestampTZ(tz) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(tz) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunctionTZ) {
									_expr := _f.ConstructLe(
										tz,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunctionTZ, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [FoldCmpSTDistanceLeft]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_distance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTDistanceLeft) {
					_expr := _f.funcs.MakeSTDWithinLeft(opt.LeOp, args, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTDistanceLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTDistanceRight]
	{
		_function, _ := right.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_distance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTDistanceRight) {
					_expr := _f.funcs.MakeSTDWithinRight(opt.LeOp, args, left).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTDistanceRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTMaxDistanceLeft]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_maxdistance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTMaxDistanceLeft) {
					_expr := _f.funcs.MakeSTDFullyWithinLeft(opt.LeOp, args, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTMaxDistanceLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTMaxDistanceRight]
	{
		_function, _ := right.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_maxdistance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTMaxDistanceRight) {
					_expr := _f.funcs.MakeSTDFullyWithinRight(opt.LeOp, args, left).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTMaxDistanceRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.LeOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructLe(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifySameVarEqualities]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.funcs.VarsAreSame(_variable, _variable2) {
					if _f.matchedRule == nil || _f.matchedRule(opt.SimplifySameVarEqualities) {
						_expr := _f.ConstructOr(
							_f.ConstructIsNot(
								_variable,
								_f.ConstructNull(
									_f.funcs.TypeOf(_variable),
								),
							),
							_f.ConstructNull(
								_f.funcs.BoolType(),
							),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.SimplifySameVarEqualities, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeLe(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructGe constructs an expression for the Ge operator.
func (_f *Factory) ConstructGe(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [CommuteVarInequality]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVarInequality) {
					_expr := _f.funcs.CommuteInequality(opt.GeOp, left, _variable2).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVarInequality, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConstInequality]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConstInequality) {
					_expr := _f.funcs.CommuteInequality(opt.GeOp, left, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConstInequality, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [NormalizeCmpPlusConst]
	{
		_plus, _ := left.(*memo.PlusExpr)
		if _plus != nil {
			leftLeft := _plus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _plus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpPlusConst) {
								_expr := _f.ConstructGe(
									leftLeft,
									_f.ConstructMinus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpPlusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpMinusConst]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if !(opt.IsConstValueOp(leftLeft)) {
				leftRight := _minus.Right
				if opt.IsConstValueOp(leftRight) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.PlusOp, right, leftRight) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpMinusConst) {
								_expr := _f.ConstructGe(
									leftLeft,
									_f.ConstructPlus(
										right,
										leftRight,
									),
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpMinusConst, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpConstMinus]
	{
		_minus, _ := left.(*memo.MinusExpr)
		if _minus != nil {
			leftLeft := _minus.Left
			if opt.IsConstValueOp(leftLeft) {
				leftRight := _minus.Right
				if !(opt.IsConstValueOp(leftRight)) {
					if opt.IsConstValueOp(right) {
						if _f.funcs.CanConstructBinary(opt.MinusOp, leftLeft, right) {
							if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpConstMinus) {
								_expr := _f.ConstructGe(
									_f.ConstructMinus(
										leftLeft,
										right,
									),
									leftRight,
								)
								if _f.appliedRule != nil {
									_f.appliedRule(opt.NormalizeCmpConstMinus, nil, _expr)
								}
								_f.constructorStackDepth--
								return _expr
							}
						}
					}
				}
			}
		}
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [NormalizeCmpTimeZoneFunction]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestampTZ(right) {
						ts := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestamp(ts) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(ts) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunction) {
									_expr := _f.ConstructGe(
										ts,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunction, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [NormalizeCmpTimeZoneFunctionTZ]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "timezone") {
				if opt.IsConstValueOp(right) {
					if _f.funcs.IsTimestamp(right) {
						tz := _f.funcs.SecondScalarListExpr(args)
						if _f.funcs.IsTimestampTZ(tz) {
							if !_f.funcs.IsConstValueOrGroupOfConstValues(tz) {
								if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeCmpTimeZoneFunctionTZ) {
									_expr := _f.ConstructGe(
										tz,
										_f.funcs.MakeTimeZoneFunction(_f.funcs.FirstScalarListExpr(args), right),
									)
									if _f.appliedRule != nil {
										_f.appliedRule(opt.NormalizeCmpTimeZoneFunctionTZ, nil, _expr)
									}
									_f.constructorStackDepth--
									return _expr
								}
							}
						}
					}
				}
			}
		}
	}

	// [FoldCmpSTDistanceLeft]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_distance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTDistanceLeft) {
					_expr := _f.funcs.MakeSTDWithinLeft(opt.GeOp, args, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTDistanceLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTDistanceRight]
	{
		_function, _ := right.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_distance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTDistanceRight) {
					_expr := _f.funcs.MakeSTDWithinRight(opt.GeOp, args, left).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTDistanceRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTMaxDistanceLeft]
	{
		_function, _ := left.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_maxdistance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTMaxDistanceLeft) {
					_expr := _f.funcs.MakeSTDFullyWithinLeft(opt.GeOp, args, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTMaxDistanceLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldCmpSTMaxDistanceRight]
	{
		_function, _ := right.(*memo.FunctionExpr)
		if _function != nil {
			args := _function.Args
			private := &_function.FunctionPrivate
			if _f.funcs.EqualsString(private.Name, "st_maxdistance") {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCmpSTMaxDistanceRight) {
					_expr := _f.funcs.MakeSTDFullyWithinRight(opt.GeOp, args, left).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCmpSTMaxDistanceRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.GeOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructGe(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifySameVarEqualities]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.funcs.VarsAreSame(_variable, _variable2) {
					if _f.matchedRule == nil || _f.matchedRule(opt.SimplifySameVarEqualities) {
						_expr := _f.ConstructOr(
							_f.ConstructIsNot(
								_variable,
								_f.ConstructNull(
									_f.funcs.TypeOf(_variable),
								),
							),
							_f.ConstructNull(
								_f.funcs.BoolType(),
							),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.SimplifySameVarEqualities, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeGe(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNe constructs an expression for the Ne operator.
func (_f *Factory) ConstructNe(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNeTrue]
	{
		_true, _ := right.(*memo.TrueExpr)
		if _true != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNeTrue) {
				_expr := _f.ConstructNot(
					left,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNeTrue, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNeFalse]
	{
		_false, _ := right.(*memo.FalseExpr)
		if _false != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNeFalse) {
				_expr := left
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNeFalse, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.NeOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [CommuteVar]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVar) {
					_expr := _f.ConstructNe(
						_variable2,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVar, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConst]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConst) {
					_expr := _f.ConstructNe(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructNe(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifySameVarInequalities]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.funcs.VarsAreSame(_variable, _variable2) {
					if _f.matchedRule == nil || _f.matchedRule(opt.SimplifySameVarInequalities) {
						_expr := _f.ConstructAnd(
							_f.ConstructIs(
								_variable,
								_f.ConstructNull(
									_f.funcs.TypeOf(_variable),
								),
							),
							_f.ConstructNull(
								_f.funcs.BoolType(),
							),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.SimplifySameVarInequalities, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeNe(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIn constructs an expression for the In operator.
func (_f *Factory) ConstructIn(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullInNonEmpty]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			_tuple, _ := right.(*memo.TupleExpr)
			if _tuple != nil {
				if len(_tuple.Elems) != 0 {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullInNonEmpty) {
						_expr := _f.ConstructNull(
							_f.funcs.BoolType(),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldNullInNonEmpty, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [FoldInEmpty]
	{
		_tuple, _ := right.(*memo.TupleExpr)
		if _tuple != nil {
			if len(_tuple.Elems) == 0 {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldInEmpty) {
					_expr := _f.ConstructFalse()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldInEmpty, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.InOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeInConst]
	{
		_tuple, _ := right.(*memo.TupleExpr)
		if _tuple != nil {
			elems := _tuple.Elems
			if _f.funcs.NeedSortedUniqueList(elems) {
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeInConst) {
					_expr := _f.ConstructIn(
						left,
						_f.ConstructTuple(
							_f.funcs.ConstructSortedUniqueList(elems),
						),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeInConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldInNull]
	{
		_tuple, _ := right.(*memo.TupleExpr)
		if _tuple != nil {
			if len(_tuple.Elems) == 1 {
				_item := _tuple.Elems[0]
				_null, _ := _item.(*memo.NullExpr)
				if _null != nil {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldInNull) {
						_expr := _f.ConstructNull(
							_f.funcs.BoolType(),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldInNull, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifyInSingleElement]
	{
		_tuple, _ := right.(*memo.TupleExpr)
		if _tuple != nil {
			if len(_tuple.Elems) == 1 {
				right := _tuple.Elems[0]
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyInSingleElement) {
					_expr := _f.ConstructEq(
						left,
						right,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyInSingleElement, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructIn(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeIn(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNotIn constructs an expression for the NotIn operator.
func (_f *Factory) ConstructNotIn(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullInNonEmpty]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			_tuple, _ := right.(*memo.TupleExpr)
			if _tuple != nil {
				if len(_tuple.Elems) != 0 {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullInNonEmpty) {
						_expr := _f.ConstructNull(
							_f.funcs.BoolType(),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldNullInNonEmpty, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [FoldNotInEmpty]
	{
		_tuple, _ := right.(*memo.TupleExpr)
		if _tuple != nil {
			if len(_tuple.Elems) == 0 {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNotInEmpty) {
					_expr := _f.ConstructTrue()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNotInEmpty, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.NotInOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [NormalizeInConst]
	{
		_tuple, _ := right.(*memo.TupleExpr)
		if _tuple != nil {
			elems := _tuple.Elems
			if _f.funcs.NeedSortedUniqueList(elems) {
				if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeInConst) {
					_expr := _f.ConstructNotIn(
						left,
						_f.ConstructTuple(
							_f.funcs.ConstructSortedUniqueList(elems),
						),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.NormalizeInConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldInNull]
	{
		_tuple, _ := right.(*memo.TupleExpr)
		if _tuple != nil {
			if len(_tuple.Elems) == 1 {
				_item := _tuple.Elems[0]
				_null, _ := _item.(*memo.NullExpr)
				if _null != nil {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldInNull) {
						_expr := _f.ConstructNull(
							_f.funcs.BoolType(),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldInNull, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [SimplifyNotInSingleElement]
	{
		_tuple, _ := right.(*memo.TupleExpr)
		if _tuple != nil {
			if len(_tuple.Elems) == 1 {
				right := _tuple.Elems[0]
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyNotInSingleElement) {
					_expr := _f.ConstructNe(
						left,
						right,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyNotInSingleElement, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructNotIn(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeNotIn(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLike constructs an expression for the Like operator.
func (_f *Factory) ConstructLike(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.LikeOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructLike(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeLike(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNotLike constructs an expression for the NotLike operator.
func (_f *Factory) ConstructNotLike(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.NotLikeOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructNotLike(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeNotLike(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructILike constructs an expression for the ILike operator.
func (_f *Factory) ConstructILike(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.ILikeOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructILike(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeILike(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNotILike constructs an expression for the NotILike operator.
func (_f *Factory) ConstructNotILike(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.NotILikeOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructNotILike(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeNotILike(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSimilarTo constructs an expression for the SimilarTo operator.
func (_f *Factory) ConstructSimilarTo(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.SimilarToOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructSimilarTo(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeSimilarTo(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNotSimilarTo constructs an expression for the NotSimilarTo operator.
func (_f *Factory) ConstructNotSimilarTo(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.NotSimilarToOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructNotSimilarTo(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeNotSimilarTo(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegMatch constructs an expression for the RegMatch operator.
func (_f *Factory) ConstructRegMatch(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.RegMatchOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructRegMatch(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegMatch(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNotRegMatch constructs an expression for the NotRegMatch operator.
func (_f *Factory) ConstructNotRegMatch(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.NotRegMatchOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructNotRegMatch(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeNotRegMatch(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegIMatch constructs an expression for the RegIMatch operator.
func (_f *Factory) ConstructRegIMatch(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.RegIMatchOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructRegIMatch(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegIMatch(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNotRegIMatch constructs an expression for the NotRegIMatch operator.
func (_f *Factory) ConstructNotRegIMatch(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.NotRegIMatchOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructNotRegIMatch(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeNotRegIMatch(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIs constructs an expression for the Is operator.
// Is maps to the IS NOT DISTINCT FROM operator which is equivalent to IS for
// non-tuples. See IsTupleNull for the tuple-specific IS NULL operator.
func (_f *Factory) ConstructIs(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldIsNull]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			_null2, _ := right.(*memo.NullExpr)
			if _null2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldIsNull) {
					_expr := _f.ConstructTrue()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldIsNull, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNonNullIsNull]
	{
		if _f.funcs.IsNeverNull(left) {
			_null, _ := right.(*memo.NullExpr)
			if _null != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNonNullIsNull) {
					_expr := _f.ConstructFalse()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNonNullIsNull, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteNullIs]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			_null2, _ := right.(*memo.NullExpr)
			if _null2 == nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteNullIs) {
					_expr := _f.ConstructIs(
						right,
						_null,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteNullIs, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.IsOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [CommuteVar]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVar) {
					_expr := _f.ConstructIs(
						_variable2,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVar, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConst]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConst) {
					_expr := _f.ConstructIs(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructIs(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeIs(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIsNot constructs an expression for the IsNot operator.
// IsNot is the inverse of Is. It maps to the IS DISTINCT FROM operator which is
// equivalent to IS NOT for non-tuples. See IsTupleNotNull for the
// tuple-specific IS NOT NULL operator.
func (_f *Factory) ConstructIsNot(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldIsNotNull]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			_null2, _ := right.(*memo.NullExpr)
			if _null2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldIsNotNull) {
					_expr := _f.ConstructFalse()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldIsNotNull, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNonNullIsNotNull]
	{
		if _f.funcs.IsNeverNull(left) {
			_null, _ := right.(*memo.NullExpr)
			if _null != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNonNullIsNotNull) {
					_expr := _f.ConstructTrue()
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNonNullIsNotNull, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteNullIs]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			_null2, _ := right.(*memo.NullExpr)
			if _null2 == nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteNullIs) {
					_expr := _f.ConstructIsNot(
						right,
						_null,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteNullIs, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.IsNotOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [CommuteVar]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVar) {
					_expr := _f.ConstructIsNot(
						_variable2,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVar, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConst]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConst) {
					_expr := _f.ConstructIsNot(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructIsNot(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeIsNot(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructContains constructs an expression for the Contains operator.
func (_f *Factory) ConstructContains(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.ContainsOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructContains(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeContains(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructContainedBy constructs an expression for the ContainedBy operator.
func (_f *Factory) ConstructContainedBy(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.ContainedByOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructContainedBy(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeContainedBy(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructJsonExists constructs an expression for the JsonExists operator.
func (_f *Factory) ConstructJsonExists(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.JsonExistsOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructJsonExists(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeJsonExists(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructJsonAllExists constructs an expression for the JsonAllExists operator.
func (_f *Factory) ConstructJsonAllExists(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.JsonAllExistsOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructJsonAllExists(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeJsonAllExists(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructJsonSomeExists constructs an expression for the JsonSomeExists operator.
func (_f *Factory) ConstructJsonSomeExists(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.JsonSomeExistsOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructJsonSomeExists(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeJsonSomeExists(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructOverlaps constructs an expression for the Overlaps operator.
func (_f *Factory) ConstructOverlaps(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullComparisonLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonLeft) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonLeft, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullComparisonRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullComparisonRight) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullComparisonRight, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.OverlapsOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructOverlaps(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeOverlaps(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructBBoxCovers constructs an expression for the BBoxCovers operator.
// BBoxCovers is the ~ operator when used with geometry or bounding box
// operands. It maps to tree.RegMatch.
func (_f *Factory) ConstructBBoxCovers(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.BBoxCoversOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructBBoxCovers(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeBBoxCovers(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructBBoxIntersects constructs an expression for the BBoxIntersects operator.
// BBoxIntersects is the && operator when used with geometry or bounding box
// operands. It maps to tree.Overlaps.
func (_f *Factory) ConstructBBoxIntersects(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldComparison]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldComparison(opt.BBoxIntersectsOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldComparison) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldComparison, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [UnifyComparisonTypes]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable != nil {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				result, ok := _f.funcs.UnifyComparison(_variable, _const)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.UnifyComparisonTypes) {
						_expr := _f.ConstructBBoxIntersects(
							_variable,
							result,
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.UnifyComparisonTypes, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeBBoxIntersects(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAnyScalar constructs an expression for the AnyScalar operator.
// AnyScalar is the form of ANY which refers to an ANY operation on a
// tuple or array, as opposed to Any which operates on a subquery.
func (_f *Factory) ConstructAnyScalar(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
	cmp opt.Operator,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldEqualsAnyNull]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldEqualsAnyNull) {
				_expr := _f.ConstructNull(
					_f.funcs.BoolType(),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldEqualsAnyNull, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyEqualsAnyTuple]
	{
		input := left
		tuple := right
		_tuple, _ := tuple.(*memo.TupleExpr)
		if _tuple != nil {
			if _f.funcs.OpsAreSame(cmp, opt.EqOp) {
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyEqualsAnyTuple) {
					_expr := _f.ConstructIn(
						input,
						_tuple,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyEqualsAnyTuple, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [SimplifyAnyScalarArray]
	{
		input := left
		ary := right
		_const, _ := ary.(*memo.ConstExpr)
		if _const != nil {
			if _f.funcs.IsConstArray(_const) {
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyAnyScalarArray) {
					_expr := _f.ConstructAnyScalar(
						input,
						_f.funcs.ConvertConstArrayToTuple(_const),
						cmp,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyAnyScalarArray, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeAnyScalar(left, right, cmp)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructBitand constructs an expression for the Bitand operator.
func (_f *Factory) ConstructBitand(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.BitandOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.BitandOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.BitandOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.BitandOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.BitandOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [CommuteVar]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVar) {
					_expr := _f.ConstructBitand(
						_variable2,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVar, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConst]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConst) {
					_expr := _f.ConstructBitand(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeBitand(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructBitor constructs an expression for the Bitor operator.
func (_f *Factory) ConstructBitor(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.BitorOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.BitorOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.BitorOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.BitorOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.BitorOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [CommuteVar]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVar) {
					_expr := _f.ConstructBitor(
						_variable2,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVar, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConst]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConst) {
					_expr := _f.ConstructBitor(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeBitor(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructBitxor constructs an expression for the Bitxor operator.
func (_f *Factory) ConstructBitxor(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.BitxorOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.BitxorOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.BitxorOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.BitxorOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.BitxorOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [CommuteVar]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVar) {
					_expr := _f.ConstructBitxor(
						_variable2,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVar, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConst]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConst) {
					_expr := _f.ConstructBitxor(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeBitxor(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructPlus constructs an expression for the Plus operator.
func (_f *Factory) ConstructPlus(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.PlusOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.PlusOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.PlusOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.PlusOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.PlusOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [FoldPlusZero]
	{
		_const, _ := right.(*memo.ConstExpr)
		if _const != nil {
			if _f.funcs.EqualsNumber(_const.Value, 0) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldPlusZero) {
					_expr := _f.ConstructCast(
						left,
						_f.funcs.BinaryType(opt.PlusOp, left, _const),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldPlusZero, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldZeroPlus]
	{
		_const, _ := left.(*memo.ConstExpr)
		if _const != nil {
			if _f.funcs.EqualsNumber(_const.Value, 0) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldZeroPlus) {
					_expr := _f.ConstructCast(
						right,
						_f.funcs.BinaryType(opt.PlusOp, _const, right),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldZeroPlus, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteVar]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVar) {
					_expr := _f.ConstructPlus(
						_variable2,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVar, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConst]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConst) {
					_expr := _f.ConstructPlus(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizePlus(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructMinus constructs an expression for the Minus operator.
func (_f *Factory) ConstructMinus(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.MinusOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.MinusOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.MinusOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.MinusOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.MinusOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [FoldMinusZero]
	{
		if _f.funcs.IsAdditiveType(_f.funcs.TypeOf(left)) {
			_const, _ := right.(*memo.ConstExpr)
			if _const != nil {
				if _f.funcs.EqualsNumber(_const.Value, 0) {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldMinusZero) {
						_expr := _f.ConstructCast(
							left,
							_f.funcs.BinaryType(opt.MinusOp, left, _const),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldMinusZero, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeMinus(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructMult constructs an expression for the Mult operator.
func (_f *Factory) ConstructMult(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.MultOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.MultOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.MultOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.MultOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.MultOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [FoldMultOne]
	{
		_const, _ := right.(*memo.ConstExpr)
		if _const != nil {
			if _f.funcs.EqualsNumber(_const.Value, 1) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldMultOne) {
					_expr := _f.ConstructCast(
						left,
						_f.funcs.BinaryType(opt.MultOp, left, _const),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldMultOne, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldOneMult]
	{
		_const, _ := left.(*memo.ConstExpr)
		if _const != nil {
			if _f.funcs.EqualsNumber(_const.Value, 1) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldOneMult) {
					_expr := _f.ConstructCast(
						right,
						_f.funcs.BinaryType(opt.MultOp, _const, right),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldOneMult, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteVar]
	{
		_variable, _ := left.(*memo.VariableExpr)
		if _variable == nil {
			_variable2, _ := right.(*memo.VariableExpr)
			if _variable2 != nil {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteVar) {
					_expr := _f.ConstructMult(
						_variable2,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteVar, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [CommuteConst]
	{
		if opt.IsConstValueOp(left) {
			if !(opt.IsConstValueOp(right)) {
				if _f.matchedRule == nil || _f.matchedRule(opt.CommuteConst) {
					_expr := _f.ConstructMult(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.CommuteConst, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeMult(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructDiv constructs an expression for the Div operator.
func (_f *Factory) ConstructDiv(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.DivOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.DivOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.DivOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.DivOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.DivOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [FoldDivOne]
	{
		_const, _ := right.(*memo.ConstExpr)
		if _const != nil {
			if _f.funcs.EqualsNumber(_const.Value, 1) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldDivOne) {
					_expr := _f.ConstructCast(
						left,
						_f.funcs.BinaryType(opt.DivOp, left, _const),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldDivOne, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeDiv(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFloorDiv constructs an expression for the FloorDiv operator.
func (_f *Factory) ConstructFloorDiv(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.FloorDivOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.FloorDivOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.FloorDivOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.FloorDivOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.FloorDivOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

	// [FoldFloorDivOne]
	{
		_const, _ := right.(*memo.ConstExpr)
		if _const != nil {
			if _f.funcs.EqualsNumber(_const.Value, 1) {
				if _f.funcs.IsInt(left) {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldFloorDivOne) {
						_expr := _f.ConstructCast(
							left,
							_f.funcs.BinaryType(opt.FloorDivOp, left, _const),
						)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldFloorDivOne, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeFloorDiv(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructMod constructs an expression for the Mod operator.
func (_f *Factory) ConstructMod(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.ModOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.ModOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.ModOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.ModOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.ModOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeMod(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructPow constructs an expression for the Pow operator.
func (_f *Factory) ConstructPow(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.PowOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.PowOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.PowOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.PowOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.PowOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizePow(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructConcat constructs an expression for the Concat operator.
func (_f *Factory) ConstructConcat(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.ConcatOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.ConcatOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.ConcatOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.ConcatOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.ConcatOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeConcat(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLShift constructs an expression for the LShift operator.
func (_f *Factory) ConstructLShift(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.LShiftOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.LShiftOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.LShiftOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.LShiftOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.LShiftOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeLShift(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRShift constructs an expression for the RShift operator.
func (_f *Factory) ConstructRShift(
	left opt.ScalarExpr,
	right opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.RShiftOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.RShiftOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.RShiftOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.RShiftOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.RShiftOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeRShift(left, right)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFetchVal constructs an expression for the FetchVal operator.
func (_f *Factory) ConstructFetchVal(
	json opt.ScalarExpr,
	index opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		left := json
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			right := index
			if !_f.funcs.AllowNullArgs(opt.FetchValOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.FetchValOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		left := json
		right := index
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.FetchValOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.FetchValOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		left := json
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			right := index
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.FetchValOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeFetchVal(json, index)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFetchText constructs an expression for the FetchText operator.
func (_f *Factory) ConstructFetchText(
	json opt.ScalarExpr,
	index opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		left := json
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			right := index
			if !_f.funcs.AllowNullArgs(opt.FetchTextOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.FetchTextOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		left := json
		right := index
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.FetchTextOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.FetchTextOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		left := json
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			right := index
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.FetchTextOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeFetchText(json, index)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFetchValPath constructs an expression for the FetchValPath operator.
func (_f *Factory) ConstructFetchValPath(
	json opt.ScalarExpr,
	path opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		left := json
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			right := path
			if !_f.funcs.AllowNullArgs(opt.FetchValPathOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.FetchValPathOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		left := json
		right := path
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.FetchValPathOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.FetchValPathOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		left := json
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			right := path
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.FetchValPathOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeFetchValPath(json, path)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFetchTextPath constructs an expression for the FetchTextPath operator.
func (_f *Factory) ConstructFetchTextPath(
	json opt.ScalarExpr,
	path opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullBinaryLeft]
	{
		left := json
		_null, _ := left.(*memo.NullExpr)
		if _null != nil {
			right := path
			if !_f.funcs.AllowNullArgs(opt.FetchTextPathOp, _null, right) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryLeft) {
					_expr := _f.funcs.FoldNullBinary(opt.FetchTextPathOp, _null, right).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryLeft, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldNullBinaryRight]
	{
		left := json
		right := path
		_null, _ := right.(*memo.NullExpr)
		if _null != nil {
			if !_f.funcs.AllowNullArgs(opt.FetchTextPathOp, left, _null) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullBinaryRight) {
					_expr := _f.funcs.FoldNullBinary(opt.FetchTextPathOp, left, _null).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldNullBinaryRight, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldBinary]
	{
		left := json
		if _f.funcs.IsConstValueOrGroupOfConstValues(left) {
			right := path
			if _f.funcs.IsConstValueOrGroupOfConstValues(right) {
				result, ok := _f.funcs.FoldBinary(opt.FetchTextPathOp, left, right)
				if ok {
					if _f.matchedRule == nil || _f.matchedRule(opt.FoldBinary) {
						_expr := result.(opt.ScalarExpr)
						if _f.appliedRule != nil {
							_f.appliedRule(opt.FoldBinary, nil, _expr)
						}
						_f.constructorStackDepth--
						return _expr
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeFetchTextPath(json, path)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUnaryMinus constructs an expression for the UnaryMinus operator.
func (_f *Factory) ConstructUnaryMinus(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullUnary]
	{
		_null, _ := input.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullUnary) {
				_expr := _f.funcs.FoldNullUnary(opt.UnaryMinusOp, _null).(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullUnary, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldUnary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(input) {
			result, ok := _f.funcs.FoldUnary(opt.UnaryMinusOp, input)
			if ok {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldUnary) {
					_expr := result.(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldUnary, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [InvertMinus]
	{
		_minus, _ := input.(*memo.MinusExpr)
		if _minus != nil {
			left := _minus.Left
			right := _minus.Right
			if _f.funcs.CanConstructBinary(opt.MinusOp, right, left) {
				if _f.matchedRule == nil || _f.matchedRule(opt.InvertMinus) {
					_expr := _f.ConstructMinus(
						right,
						left,
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.InvertMinus, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [EliminateUnaryMinus]
	{
		_unaryMinus, _ := input.(*memo.UnaryMinusExpr)
		if _unaryMinus != nil {
			input := _unaryMinus.Input
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateUnaryMinus) {
				_expr := input
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateUnaryMinus, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUnaryMinus(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUnaryPlus constructs an expression for the UnaryPlus operator.
func (_f *Factory) ConstructUnaryPlus(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullUnary]
	{
		_null, _ := input.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullUnary) {
				_expr := _f.funcs.FoldNullUnary(opt.UnaryPlusOp, _null).(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullUnary, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldUnary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(input) {
			result, ok := _f.funcs.FoldUnary(opt.UnaryPlusOp, input)
			if ok {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldUnary) {
					_expr := result.(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldUnary, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUnaryPlus(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUnaryComplement constructs an expression for the UnaryComplement operator.
func (_f *Factory) ConstructUnaryComplement(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullUnary]
	{
		_null, _ := input.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullUnary) {
				_expr := _f.funcs.FoldNullUnary(opt.UnaryComplementOp, _null).(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullUnary, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldUnary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(input) {
			result, ok := _f.funcs.FoldUnary(opt.UnaryComplementOp, input)
			if ok {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldUnary) {
					_expr := result.(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldUnary, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUnaryComplement(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUnarySqrt constructs an expression for the UnarySqrt operator.
func (_f *Factory) ConstructUnarySqrt(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullUnary]
	{
		_null, _ := input.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullUnary) {
				_expr := _f.funcs.FoldNullUnary(opt.UnarySqrtOp, _null).(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullUnary, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldUnary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(input) {
			result, ok := _f.funcs.FoldUnary(opt.UnarySqrtOp, input)
			if ok {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldUnary) {
					_expr := result.(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldUnary, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUnarySqrt(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUnaryCbrt constructs an expression for the UnaryCbrt operator.
func (_f *Factory) ConstructUnaryCbrt(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldNullUnary]
	{
		_null, _ := input.(*memo.NullExpr)
		if _null != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullUnary) {
				_expr := _f.funcs.FoldNullUnary(opt.UnaryCbrtOp, _null).(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullUnary, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldUnary]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(input) {
			result, ok := _f.funcs.FoldUnary(opt.UnaryCbrtOp, input)
			if ok {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldUnary) {
					_expr := result.(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldUnary, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeUnaryCbrt(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCast constructs an expression for the Cast operator.
// Cast converts the input expression into an expression of the target type. Note
// that the conversion may cause truncation based on the target types' width,
// such as in this example:
//
//	'hello'::VARCHAR(2)
//
// That expression has the effect of truncating the string to just 'he', since
// the target data type allows a maximum of two characters. This is one example
// of a "lossy" cast.
func (_f *Factory) ConstructCast(
	input opt.ScalarExpr,
	typ *types.T,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateCast]
	{
		targetTyp := typ
		if _f.funcs.HasColType(input, targetTyp) {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateCast) {
				_expr := input
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateCast, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldNullCast]
	{
		_null, _ := input.(*memo.NullExpr)
		if _null != nil {
			targetTyp := typ
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldNullCast) {
				_expr := _f.ConstructNull(
					targetTyp,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldNullCast, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [FoldCast]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(input) {
			result, ok := _f.funcs.FoldCast(input, typ)
			if ok {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldCast) {
					_expr := result.(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldCast, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeCast(input, typ)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAssignmentCast constructs an expression for the AssignmentCast operator.
// AssignmentCast is similar to CastExpr, but is performed in the context of an
// INSERT, UPDATE, or UPSERT to match the type of a mutation value to the type of
// the target column. An expression separate from CastExpr is required because it
// behaves slightly differently than an explicit cast. For example, while an
// explicit cast will truncate a value to fit the width of a type, an assignment
// cast will error instead if the value does not fit the type. See
// tree.CastContext for more details.
//
// An assignment cast is represented as a distinct expression within the
// optimizer, but is built into a crdb_internal.assignment_cast function call in
// execbuilder.
func (_f *Factory) ConstructAssignmentCast(
	input opt.ScalarExpr,
	typ *types.T,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldAssignmentCast]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(input) {
			result, ok := _f.funcs.FoldAssignmentCast(input, typ)
			if ok {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldAssignmentCast) {
					_expr := result.(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldAssignmentCast, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeAssignmentCast(input, typ)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIfErr constructs an expression for the IfErr operator.
// IfErr is roughly a runtime try-catch operator. It has different semantics
// depending on which of its fields are set.
//
// If ErrCode is set, only errors which match the given error code will be
// caught. If ErrCode is not set, all errors will be caught.
//
// If OrElse is not set, IfErr evaluates to true or false indicating whether an
// error was caught.  If OrElse is set, IfErr evaluates to Cond if no error was
// caught and to OrElse if an error was caught.
//
// TODO(justin): The implementation here is a hack: ErrCode and OrElse are
// optional, so we repurpose lists as an optional field (since it's not
// valid to use nil). If this comes up again, we might want to consider
// adding an explicit Option type.
func (_f *Factory) ConstructIfErr(
	cond opt.ScalarExpr,
	orElse memo.ScalarListExpr,
	errCode memo.ScalarListExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeIfErr(cond, orElse, errCode)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCase constructs an expression for the Case operator.
// Case is a CASE statement of the form:
//
//	CASE [ <Input> ]
//	    WHEN <condval1> THEN <expr1>
//	  [ WHEN <condval2> THEN <expr2> ] ...
//	  [ ELSE <expr> ]
//	END
//
// The Case operator evaluates <Input> (if not provided, Input is set to True),
// then picks the WHEN branch where <condval> is equal to <Input>, then evaluates
// and returns the corresponding THEN expression. If no WHEN branch matches, the
// ELSE expression is evaluated and returned, if any. Otherwise, NULL is
// returned.
//
// Note that the Whens list inside Case is used to represent all the WHEN
// branches. It is of the form:
//
//	[(When <condval1> <expr1>),(When <condval2> <expr2>),...]
func (_f *Factory) ConstructCase(
	input opt.ScalarExpr,
	whens memo.ScalarListExpr,
	orElse opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyCaseWhenConstValue]
	{
		condition := input
		if opt.IsConstValueOp(condition) {
			for i := range whens {
				_item := whens[i]
				_when, _ := _item.(*memo.WhenExpr)
				if _when != nil {
					if opt.IsConstValueOp(_when.Condition) {
						if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyCaseWhenConstValue) {
							_expr := _f.funcs.SimplifyWhens(condition, whens, orElse).(opt.ScalarExpr)
							if _f.appliedRule != nil {
								_f.appliedRule(opt.SimplifyCaseWhenConstValue, nil, _expr)
							}
							_f.constructorStackDepth--
							return _expr
						}
					}
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeCase(input, whens, orElse)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructWhen constructs an expression for the When operator.
// When represents a single WHEN ... THEN ... condition inside a CASE statement.
// It is the type of each list item in Whens (except for the last item which is
// a raw expression for the ELSE statement).
func (_f *Factory) ConstructWhen(
	condition opt.ScalarExpr,
	value opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeWhen(condition, value)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructArray constructs an expression for the Array operator.
// Array is an ARRAY literal of the form ARRAY[<expr1>, <expr2>, ..., <exprN>].
func (_f *Factory) ConstructArray(
	elems memo.ScalarListExpr,
	typ *types.T,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldArray]
	{
		if _f.funcs.IsListOfConstants(elems) {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldArray) {
				_expr := _f.funcs.FoldArray(elems, typ).(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldArray, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeArray(elems, typ)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructIndirection constructs an expression for the Indirection operator.
// Indirection is a subscripting expression of the form <expr>[<index>].
// Input must be an Array type and Index must be an int. Multiple indirections
// and slicing are not supported.
func (_f *Factory) ConstructIndirection(
	input opt.ScalarExpr,
	index opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldIndirection]
	{
		if _f.funcs.IsConstValueOrGroupOfConstValues(index) {
			result, ok := _f.funcs.FoldIndirection(input, index)
			if ok {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldIndirection) {
					_expr := result.(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldIndirection, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [ConvertJSONSubscriptToFetchValue]
	{
		if _f.funcs.IsJSON(input) {
			if _f.matchedRule == nil || _f.matchedRule(opt.ConvertJSONSubscriptToFetchValue) {
				_expr := _f.ConstructFetchVal(
					input,
					index,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.ConvertJSONSubscriptToFetchValue, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeIndirection(input, index)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructArrayFlatten constructs an expression for the ArrayFlatten operator.
// ArrayFlatten is an ARRAY(<subquery>) expression. ArrayFlatten takes as input
// a subquery which returns a single column and constructs a scalar array as the
// output. Any NULLs are included in the results, and if the subquery has an
// ORDER BY clause that ordering will be respected by the resulting array.
func (_f *Factory) ConstructArrayFlatten(
	input memo.RelExpr,
	subqueryPrivate *memo.SubqueryPrivate,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [NormalizeArrayFlattenToAgg]
	{
		if _f.funcs.HasOuterCols(input) {
			subquery := subqueryPrivate
			if _f.matchedRule == nil || _f.matchedRule(opt.NormalizeArrayFlattenToAgg) {
				requestedCol := _f.funcs.SubqueryRequestedCol(subquery)
				_expr := _f.ConstructCoalesce(
					memo.ScalarListExpr{
						_f.ConstructSubquery(
							_f.ConstructScalarGroupBy(
								input,
								memo.AggregationsExpr{
									_f.ConstructAggregationsItem(
										_f.ConstructArrayAgg(
											_f.ConstructVariable(
												requestedCol,
											),
										),
										_f.funcs.MakeArrayAggCol(_f.funcs.ArrayType(requestedCol)),
									),
								},
								_f.funcs.MakeGrouping(_f.funcs.MakeEmptyColSet(), _f.funcs.SubqueryOrdering(subquery)),
							),
							_f.funcs.MakeUnorderedSubquery(),
						),
						_f.ConstructArray(
							memo.EmptyScalarListExpr,
							_f.funcs.ArrayType(requestedCol),
						),
					},
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.NormalizeArrayFlattenToAgg, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeArrayFlatten(input, subqueryPrivate)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFunction constructs an expression for the Function operator.
// Function invokes a builtin SQL function like CONCAT or NOW, passing the given
// arguments. The FunctionPrivate field contains the name of the function as well
// as pointers to its type and properties.
func (_f *Factory) ConstructFunction(
	args memo.ScalarListExpr,
	functionPrivate *memo.FunctionPrivate,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldFunctionWithNullArg]
	{
		private := functionPrivate
		if _f.funcs.CanFoldFunctionWithNullArg(private) {
			if _f.funcs.HasNullArg(args) {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldFunctionWithNullArg) {
					_expr := _f.ConstructNull(
						_f.funcs.FunctionReturnType(private),
					)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldFunctionWithNullArg, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

	// [FoldFunction]
	{
		if _f.funcs.IsListOfConstants(args) {
			private := functionPrivate
			result, ok := _f.funcs.FoldFunction(args, private)
			if ok {
				if _f.matchedRule == nil || _f.matchedRule(opt.FoldFunction) {
					_expr := result.(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.FoldFunction, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeFunction(args, functionPrivate)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCollate constructs an expression for the Collate operator.
// Collate is an expression of the form
//
//	x COLLATE y
//
// Where x is a "string type" (meaning either a normal string or a collated string),
// and y is a locale. It evaluates to the string collated to the given locale.
func (_f *Factory) ConstructCollate(
	input opt.ScalarExpr,
	locale string,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldCollate]
	{
		_const, _ := input.(*memo.ConstExpr)
		if _const != nil {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldCollate) {
				_expr := _f.funcs.CastToCollatedString(_const, locale).(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldCollate, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeCollate(input, locale)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCoalesce constructs an expression for the Coalesce operator.
func (_f *Factory) ConstructCoalesce(
	args memo.ScalarListExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateCoalesce]
	{
		if len(args) == 1 {
			item := args[0]
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateCoalesce) {
				_expr := item.(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateCoalesce, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [SimplifyCoalesce]
	{
		if len(args) > 0 {
			arg := args[0]
			if _f.funcs.IsConstValueOrGroupOfConstValues(arg) {
				if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyCoalesce) {
					_expr := _f.funcs.SimplifyCoalesce(args).(opt.ScalarExpr)
					if _f.appliedRule != nil {
						_f.appliedRule(opt.SimplifyCoalesce, nil, _expr)
					}
					_f.constructorStackDepth--
					return _expr
				}
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeCoalesce(args)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructColumnAccess constructs an expression for the ColumnAccess operator.
// ColumnAccess is a scalar expression that returns a column from the given
// input expression (which is assumed to be of type Tuple). Idx is the ordinal
// index of the column in Input.
func (_f *Factory) ConstructColumnAccess(
	input opt.ScalarExpr,
	idx memo.TupleOrdinal,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [FoldColumnAccess]
	{
		result, ok := _f.funcs.FoldColumnAccess(input, idx)
		if ok {
			if _f.matchedRule == nil || _f.matchedRule(opt.FoldColumnAccess) {
				_expr := result.(opt.ScalarExpr)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.FoldColumnAccess, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeColumnAccess(input, idx)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructArrayAgg constructs an expression for the ArrayAgg operator.
func (_f *Factory) ConstructArrayAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeArrayAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAvg constructs an expression for the Avg operator.
func (_f *Factory) ConstructAvg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeAvg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructBitAndAgg constructs an expression for the BitAndAgg operator.
func (_f *Factory) ConstructBitAndAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeBitAndAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructBitOrAgg constructs an expression for the BitOrAgg operator.
func (_f *Factory) ConstructBitOrAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeBitOrAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructBoolAnd constructs an expression for the BoolAnd operator.
func (_f *Factory) ConstructBoolAnd(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeBoolAnd(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructBoolOr constructs an expression for the BoolOr operator.
func (_f *Factory) ConstructBoolOr(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeBoolOr(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructConcatAgg constructs an expression for the ConcatAgg operator.
func (_f *Factory) ConstructConcatAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeConcatAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCorr constructs an expression for the Corr operator.
func (_f *Factory) ConstructCorr(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCorr(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCount constructs an expression for the Count operator.
func (_f *Factory) ConstructCount(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCount(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCountRows constructs an expression for the CountRows operator.
func (_f *Factory) ConstructCountRows() opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCountRows()
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCovarPop constructs an expression for the CovarPop operator.
func (_f *Factory) ConstructCovarPop(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCovarPop(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCovarSamp constructs an expression for the CovarSamp operator.
func (_f *Factory) ConstructCovarSamp(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCovarSamp(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegressionAvgX constructs an expression for the RegressionAvgX operator.
func (_f *Factory) ConstructRegressionAvgX(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegressionAvgX(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegressionAvgY constructs an expression for the RegressionAvgY operator.
func (_f *Factory) ConstructRegressionAvgY(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegressionAvgY(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegressionIntercept constructs an expression for the RegressionIntercept operator.
func (_f *Factory) ConstructRegressionIntercept(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegressionIntercept(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegressionR2 constructs an expression for the RegressionR2 operator.
func (_f *Factory) ConstructRegressionR2(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegressionR2(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegressionSlope constructs an expression for the RegressionSlope operator.
func (_f *Factory) ConstructRegressionSlope(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegressionSlope(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegressionSXX constructs an expression for the RegressionSXX operator.
func (_f *Factory) ConstructRegressionSXX(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegressionSXX(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegressionSXY constructs an expression for the RegressionSXY operator.
func (_f *Factory) ConstructRegressionSXY(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegressionSXY(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegressionSYY constructs an expression for the RegressionSYY operator.
func (_f *Factory) ConstructRegressionSYY(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegressionSYY(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRegressionCount constructs an expression for the RegressionCount operator.
func (_f *Factory) ConstructRegressionCount(
	y opt.ScalarExpr,
	x opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRegressionCount(y, x)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructMax constructs an expression for the Max operator.
func (_f *Factory) ConstructMax(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeMax(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructMin constructs an expression for the Min operator.
func (_f *Factory) ConstructMin(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeMin(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSumInt constructs an expression for the SumInt operator.
func (_f *Factory) ConstructSumInt(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeSumInt(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSum constructs an expression for the Sum operator.
func (_f *Factory) ConstructSum(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeSum(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSqrDiff constructs an expression for the SqrDiff operator.
func (_f *Factory) ConstructSqrDiff(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeSqrDiff(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructVariance constructs an expression for the Variance operator.
func (_f *Factory) ConstructVariance(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeVariance(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructVarPop constructs an expression for the VarPop operator.
func (_f *Factory) ConstructVarPop(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeVarPop(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructStdDev constructs an expression for the StdDev operator.
func (_f *Factory) ConstructStdDev(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeStdDev(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructStdDevPop constructs an expression for the StdDevPop operator.
func (_f *Factory) ConstructStdDevPop(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeStdDevPop(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSTMakeLine constructs an expression for the STMakeLine operator.
func (_f *Factory) ConstructSTMakeLine(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeSTMakeLine(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSTExtent constructs an expression for the STExtent operator.
func (_f *Factory) ConstructSTExtent(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeSTExtent(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSTUnion constructs an expression for the STUnion operator.
func (_f *Factory) ConstructSTUnion(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeSTUnion(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructSTCollect constructs an expression for the STCollect operator.
func (_f *Factory) ConstructSTCollect(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeSTCollect(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructXorAgg constructs an expression for the XorAgg operator.
func (_f *Factory) ConstructXorAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeXorAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructJsonAgg constructs an expression for the JsonAgg operator.
func (_f *Factory) ConstructJsonAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeJsonAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructJsonbAgg constructs an expression for the JsonbAgg operator.
func (_f *Factory) ConstructJsonbAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeJsonbAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructJsonObjectAgg constructs an expression for the JsonObjectAgg operator.
func (_f *Factory) ConstructJsonObjectAgg(
	key opt.ScalarExpr,
	value opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeJsonObjectAgg(key, value)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructJsonbObjectAgg constructs an expression for the JsonbObjectAgg operator.
func (_f *Factory) ConstructJsonbObjectAgg(
	key opt.ScalarExpr,
	value opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeJsonbObjectAgg(key, value)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructStringAgg constructs an expression for the StringAgg operator.
func (_f *Factory) ConstructStringAgg(
	input opt.ScalarExpr,
	sep opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeStringAgg(input, sep)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructConstAgg constructs an expression for the ConstAgg operator.
// ConstAgg is used in the special case when the value of a column is known to be
// constant within a grouping set; it returns that value. If there are no rows
// in the grouping set, then ConstAgg returns NULL.
//
// ConstAgg is not part of SQL, but it's used internally to rewrite correlated
// subqueries into an efficient and convenient form.
func (_f *Factory) ConstructConstAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeConstAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructConstNotNullAgg constructs an expression for the ConstNotNullAgg operator.
// ConstNotNullAgg is used in the special case when the value of a column is
// known to be constant within a grouping set, except on some rows where it can
// have a NULL value; it returns the non-NULL constant value. If there are no
// rows in the grouping set, or all rows have a NULL value, then ConstNotNullAgg
// returns NULL.
//
// ConstNotNullAgg is not part of SQL, but it's used internally to rewrite
// correlated subqueries into an efficient and convenient form.
func (_f *Factory) ConstructConstNotNullAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeConstNotNullAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAnyNotNullAgg constructs an expression for the AnyNotNullAgg operator.
// AnyNotNullAgg returns any non-NULL value it receives, with no other guarantees.
// If it does not receive any values, it returns NULL.
//
// AnyNotNullAgg is not part of SQL, but it's used internally to rewrite
// correlated subqueries into an efficient and convenient form.
func (_f *Factory) ConstructAnyNotNullAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeAnyNotNullAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFirstAgg constructs an expression for the FirstAgg operator.
// FirstAgg is used only by DistinctOn; it returns the value on the first row
// according to an ordering; if the ordering is unspecified (or partially
// specified), it is an arbitrary ordering but it must be the same across all
// FirstAggs in a DistinctOn.
func (_f *Factory) ConstructFirstAgg(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeFirstAgg(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructPercentileDisc constructs an expression for the PercentileDisc operator.
// PercentileDisc returns a value such that N% of values are below it
// in a given window. Ignores nulls in the input.
func (_f *Factory) ConstructPercentileDisc(
	fraction opt.ScalarExpr,
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizePercentileDisc(fraction, input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructPercentileCont constructs an expression for the PercentileCont operator.
// PercentileCont returns a value such that N% of values are below it
// in a given window, interpolating values if needed. Ignores nulls in the
// input.
func (_f *Factory) ConstructPercentileCont(
	fraction opt.ScalarExpr,
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizePercentileCont(fraction, input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAggDistinct constructs an expression for the AggDistinct operator.
// AggDistinct is used as a modifier that wraps an aggregate function. It causes
// the respective aggregation to only process each distinct value once.
func (_f *Factory) ConstructAggDistinct(
	input opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [EliminateAggDistinct]
	{
		if input.Op() == opt.MinOp || input.Op() == opt.MaxOp || input.Op() == opt.BoolAndOp || input.Op() == opt.BoolOrOp {
			if _f.matchedRule == nil || _f.matchedRule(opt.EliminateAggDistinct) {
				_expr := input
				if _f.appliedRule != nil {
					_f.appliedRule(opt.EliminateAggDistinct, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeAggDistinct(input)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAggFilter constructs an expression for the AggFilter operator.
// AggFilter is used as a modifier that wraps an aggregate function (or an
// AggDistinct operator that wraps an aggregate function). It causes only rows
// for which the filter expression is true to be processed. AggFilter should
// always occur on top of AggDistinct if they are both present.
func (_f *Factory) ConstructAggFilter(
	input opt.ScalarExpr,
	filter opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeAggFilter(input, filter)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructWindowFromOffset constructs an expression for the WindowFromOffset operator.
// WindowFromOffset is used as a modifier that wraps the input of a window
// function. It supplies the expression to be used as the lower bound of the
// window frame, if the lower bound uses OFFSET mode.
func (_f *Factory) ConstructWindowFromOffset(
	input opt.ScalarExpr,
	offset opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeWindowFromOffset(input, offset)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructWindowToOffset constructs an expression for the WindowToOffset operator.
// WindowToOffset is used as a modifier that wraps the input of a window
// function. It supplies the expression to be used as the upper bound of the
// window frame, if the upper bound uses OFFSET mode.
func (_f *Factory) ConstructWindowToOffset(
	input opt.ScalarExpr,
	offset opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeWindowToOffset(input, offset)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructWindowsItem constructs an expression for the WindowsItem operator.
// WindowsItem is a single window function to be computed in the context of a
// Window expression.
func (_f *Factory) ConstructWindowsItem(
	function opt.ScalarExpr,
	windowsItemPrivate *memo.WindowsItemPrivate,
) memo.WindowsItem {
	item := memo.WindowsItem{Function: function, WindowsItemPrivate: *windowsItemPrivate}
	item.PopulateProps(_f.mem)
	return item
}

// ConstructRank constructs an expression for the Rank operator.
// Rank computes the position of a row relative to an ordering, with same-valued
// rows receiving the same value.
func (_f *Factory) ConstructRank() opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRank()
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructRowNumber constructs an expression for the RowNumber operator.
// RowNumber computes the position of a row relative to an ordering, with
// same-valued rows having ties broken arbitrarily.
func (_f *Factory) ConstructRowNumber() opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeRowNumber()
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructDenseRank constructs an expression for the DenseRank operator.
// DenseRank is like Rank, but without gaps. Instead of 1, 1, 3, it gives 1, 1, 2.
func (_f *Factory) ConstructDenseRank() opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeDenseRank()
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructPercentRank constructs an expression for the PercentRank operator.
// PercentRank is (rank - 1) / (total rows - 1).
func (_f *Factory) ConstructPercentRank() opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizePercentRank()
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCumeDist constructs an expression for the CumeDist operator.
// CumeDist is the relative rank of the current row:
// (number of rows preceding or peer with current row) / (total rows)
func (_f *Factory) ConstructCumeDist() opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCumeDist()
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNtile constructs an expression for the Ntile operator.
// Ntile builds a histogram with the specified number of buckets and evaluates
// to which bucket the row falls in.
func (_f *Factory) ConstructNtile(
	numBuckets opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeNtile(numBuckets)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLag constructs an expression for the Lag operator.
// Lag returns Value evaluated at the row Offset rows before this one. If no
// such row exists, returns Def.
func (_f *Factory) ConstructLag(
	value opt.ScalarExpr,
	offset opt.ScalarExpr,
	def opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeLag(value, offset, def)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLead constructs an expression for the Lead operator.
// Lead returns Value evaluated at the row Offset rows after this one. If no
// such row exists, returns Def.
func (_f *Factory) ConstructLead(
	value opt.ScalarExpr,
	offset opt.ScalarExpr,
	def opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeLead(value, offset, def)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructFirstValue constructs an expression for the FirstValue operator.
// FirstValue returns Value evaluated at the first row in the row's frame.
// TODO(justin): can this be unified with FirstAgg?
func (_f *Factory) ConstructFirstValue(
	value opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeFirstValue(value)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructLastValue constructs an expression for the LastValue operator.
// LastValue returns Value evaluated at the last row in the row's frame.
func (_f *Factory) ConstructLastValue(
	value opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeLastValue(value)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructNthValue constructs an expression for the NthValue operator.
// NthValue returns Value evaluated at the nth row in the row's frame.
// Out-of-bounds references evaluate to NULL.
func (_f *Factory) ConstructNthValue(
	value opt.ScalarExpr,
	nth opt.ScalarExpr,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeNthValue(value, nth)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructUDF constructs an expression for the UDF operator.
// UDF invokes a user-defined function. The UDFPrivate field contains details
// about the UDF including the name of the function, the statements in the
// function body, and a pointer to its type.
func (_f *Factory) ConstructUDF(
	input memo.ScalarListExpr,
	uDFPrivate *memo.UDFPrivate,
) opt.ScalarExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeUDF(input, uDFPrivate)
	expr := _f.onConstructScalar(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructKVOptionsItem constructs an expression for the KVOptionsItem operator.
// KVOptionsItem is the key and value of an option (see tree.KVOption). For keys
// that don't have values, the value is Null.
func (_f *Factory) ConstructKVOptionsItem(
	value opt.ScalarExpr,
	key string,
) memo.KVOptionsItem {
	item := memo.KVOptionsItem{Value: value, Key: key}
	return item
}

// ConstructCreateTable constructs an expression for the CreateTable operator.
// CreateTable represents a CREATE TABLE statement.
func (_f *Factory) ConstructCreateTable(
	input memo.RelExpr,
	createTablePrivate *memo.CreateTablePrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCreateTable(input, createTablePrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCreateView constructs an expression for the CreateView operator.
func (_f *Factory) ConstructCreateView(
	createViewPrivate *memo.CreateViewPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCreateView(createViewPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCreateFunction constructs an expression for the CreateFunction operator.
// CreateFunction represents a CREATE FUNCTION statement.
func (_f *Factory) ConstructCreateFunction(
	createFunctionPrivate *memo.CreateFunctionPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCreateFunction(createFunctionPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructExplain constructs an expression for the Explain operator.
// Explain returns information about the execution plan of the "input"
// expression.
func (_f *Factory) ConstructExplain(
	input memo.RelExpr,
	explainPrivate *memo.ExplainPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

	// [SimplifyExplainOrdering]
	{
		if _f.funcs.CanSimplifyExplainOrdering(input, explainPrivate) {
			if _f.matchedRule == nil || _f.matchedRule(opt.SimplifyExplainOrdering) {
				_expr := _f.ConstructExplain(
					input,
					_f.funcs.SimplifyExplainOrdering(input, explainPrivate),
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.SimplifyExplainOrdering, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

	// [PruneExplainCols]
	{
		needed := _f.funcs.NeededExplainCols(explainPrivate)
		if _f.funcs.CanPruneCols(input, needed) {
			if _f.matchedRule == nil || _f.matchedRule(opt.PruneExplainCols) {
				_expr := _f.ConstructExplain(
					_f.funcs.PruneCols(input, needed),
					explainPrivate,
				)
				if _f.appliedRule != nil {
					_f.appliedRule(opt.PruneExplainCols, nil, _expr)
				}
				_f.constructorStackDepth--
				return _expr
			}
		}
	}

SKIP_RULES:
	e := _f.mem.MemoizeExplain(input, explainPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructShowTraceForSession constructs an expression for the ShowTraceForSession operator.
// ShowTraceForSession returns the current session traces.
func (_f *Factory) ConstructShowTraceForSession(
	showTracePrivate *memo.ShowTracePrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeShowTraceForSession(showTracePrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructOpaqueRel constructs an expression for the OpaqueRel operator.
// OpaqueRel is an opaque relational operator which is planned outside of the
// optimizer. The operator contains an opaque metadata which is passed to the
// exec factory.
//
// This is used for statements that are not directly supported by the optimizer,
// and which don't use the result of other relational expressions (in other
// words, they are a "leaf" operator).
//
// OpaqueRel can produce data and can be used as a data source as part of a
// larger enclosing query.
func (_f *Factory) ConstructOpaqueRel(
	opaqueRelPrivate *memo.OpaqueRelPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeOpaqueRel(opaqueRelPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructOpaqueMutation constructs an expression for the OpaqueMutation operator.
// OpaqueMutation is a variant of OpaqueRel for operators that can mutate data as
// part of the transaction.
func (_f *Factory) ConstructOpaqueMutation(
	opaqueRelPrivate *memo.OpaqueRelPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeOpaqueMutation(opaqueRelPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructOpaqueDDL constructs an expression for the OpaqueDDL operator.
// OpaqueMutation is a variant of OpaqueRel for operators that cause a schema
// change and cannot be executed following a mutation in the same transaction.
func (_f *Factory) ConstructOpaqueDDL(
	opaqueRelPrivate *memo.OpaqueRelPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeOpaqueDDL(opaqueRelPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAlterTableSplit constructs an expression for the AlterTableSplit operator.
// AlterTableSplit represents an `ALTER TABLE/INDEX .. SPLIT AT ..` statement.
func (_f *Factory) ConstructAlterTableSplit(
	input memo.RelExpr,
	expiration opt.ScalarExpr,
	alterTableSplitPrivate *memo.AlterTableSplitPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeAlterTableSplit(input, expiration, alterTableSplitPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAlterTableUnsplit constructs an expression for the AlterTableUnsplit operator.
// AlterTableUnsplit represents an `ALTER TABLE/INDEX .. UNSPLIT AT ..`
// statement.
func (_f *Factory) ConstructAlterTableUnsplit(
	input memo.RelExpr,
	alterTableSplitPrivate *memo.AlterTableSplitPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeAlterTableUnsplit(input, alterTableSplitPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAlterTableUnsplitAll constructs an expression for the AlterTableUnsplitAll operator.
// AlterTableUnsplit represents an `ALTER TABLE/INDEX .. UNSPLIT ALL` statement.
func (_f *Factory) ConstructAlterTableUnsplitAll(
	alterTableSplitPrivate *memo.AlterTableSplitPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeAlterTableUnsplitAll(alterTableSplitPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAlterTableRelocate constructs an expression for the AlterTableRelocate operator.
// AlterTableRelocate represents an `ALTER TABLE/INDEX .. SPLIT AT ..` statement.
func (_f *Factory) ConstructAlterTableRelocate(
	input memo.RelExpr,
	alterTableRelocatePrivate *memo.AlterTableRelocatePrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeAlterTableRelocate(input, alterTableRelocatePrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructControlJobs constructs an expression for the ControlJobs operator.
// ControlJobs represents a `PAUSE/CANCEL/RESUME JOBS` statement.
func (_f *Factory) ConstructControlJobs(
	input memo.RelExpr,
	reason opt.ScalarExpr,
	controlJobsPrivate *memo.ControlJobsPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeControlJobs(input, reason, controlJobsPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructControlSchedules constructs an expression for the ControlSchedules operator.
// ControlSchedules represents a `PAUSE/CANCEL/RESUME SCHEDULES` statement.
func (_f *Factory) ConstructControlSchedules(
	input memo.RelExpr,
	controlSchedulesPrivate *memo.ControlSchedulesPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeControlSchedules(input, controlSchedulesPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCancelQueries constructs an expression for the CancelQueries operator.
// CancelQueries represents a `CANCEL QUERIES` statement.
func (_f *Factory) ConstructCancelQueries(
	input memo.RelExpr,
	cancelPrivate *memo.CancelPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCancelQueries(input, cancelPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCancelSessions constructs an expression for the CancelSessions operator.
// CancelSessions represents a `CANCEL SESSIONS` statement.
func (_f *Factory) ConstructCancelSessions(
	input memo.RelExpr,
	cancelPrivate *memo.CancelPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCancelSessions(input, cancelPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructExport constructs an expression for the Export operator.
// Export represents an `EXPORT` statement.
func (_f *Factory) ConstructExport(
	input memo.RelExpr,
	fileName opt.ScalarExpr,
	options memo.KVOptionsExpr,
	exportPrivate *memo.ExportPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeExport(input, fileName, options, exportPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructCreateStatistics constructs an expression for the CreateStatistics operator.
// CreateStatistics represents a CREATE STATISTICS or ANALYZE statement.
func (_f *Factory) ConstructCreateStatistics(
	createStatisticsPrivate *memo.CreateStatisticsPrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeCreateStatistics(createStatisticsPrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// ConstructAlterRangeRelocate constructs an expression for the AlterRangeRelocate operator.
// AlterRangeRelocate represents an `ALTER RANGE .. RELOCATE ..` statement.
func (_f *Factory) ConstructAlterRangeRelocate(
	input memo.RelExpr,
	toStoreID opt.ScalarExpr,
	fromStoreID opt.ScalarExpr,
	alterRangeRelocatePrivate *memo.AlterRangeRelocatePrivate,
) memo.RelExpr {
	_f.constructorStackDepth++
	if _f.constructorStackDepth > maxConstructorStackDepth {
		// If the constructor call stack depth exceeds the limit, call
		// onMaxConstructorStackDepthExceeded and skip all rules.
		_f.onMaxConstructorStackDepthExceeded()
		goto SKIP_RULES
	}

SKIP_RULES:
	e := _f.mem.MemoizeAlterRangeRelocate(input, toStoreID, fromStoreID, alterRangeRelocatePrivate)
	expr := _f.onConstructRelational(e)
	_f.constructorStackDepth--
	return expr
}

// Replace enables an expression subtree to be rewritten under the control of
// the caller. It passes each child of the given expression to the replace
// callback. The caller can continue traversing the expression tree within the
// callback by recursively calling Replace. It can also return a replacement
// expression; if it does, then Replace will rebuild the operator and its
// ancestors via a call to the corresponding factory Construct methods. Here
// is example usage:
//
//	var replace func(e opt.Expr) opt.Expr
//	replace = func(e opt.Expr) opt.Expr {
//	  if e.Op() == opt.VariableOp {
//	    return getReplaceVar(e)
//	  }
//	  return factory.Replace(e, replace)
//	}
//	replace(root, replace)
//
// Here, all variables in the tree are being replaced by some other expression
// in a pre-order traversal of the tree. Post-order traversal is trivially
// achieved by moving the factory.Replace call to the top of the replace
// function rather than bottom.
func (f *Factory) Replace(e opt.Expr, replace ReplaceFunc) opt.Expr {
	switch t := e.(type) {
	case *memo.NormCycleTestRelExpr:
		scalar := replace(t.Scalar).(opt.ScalarExpr)
		if scalar != t.Scalar {
			return f.ConstructNormCycleTestRel(scalar)
		}
		return t

	case *memo.MemoCycleTestRelExpr:
		input := replace(t.Input).(memo.RelExpr)
		filters, filtersChanged := f.replaceFiltersExpr(t.Filters, replace)
		if input != t.Input || filtersChanged {
			return f.ConstructMemoCycleTestRel(input, filters)
		}
		return t

	case *memo.InsertExpr:
		input := replace(t.Input).(memo.RelExpr)
		uniqueChecks, uniqueChecksChanged := f.replaceUniqueChecksExpr(t.UniqueChecks, replace)
		fKChecks, fKChecksChanged := f.replaceFKChecksExpr(t.FKChecks, replace)
		if input != t.Input || uniqueChecksChanged || fKChecksChanged {
			return f.ConstructInsert(input, uniqueChecks, fKChecks, &t.MutationPrivate)
		}
		return t

	case *memo.UpdateExpr:
		input := replace(t.Input).(memo.RelExpr)
		uniqueChecks, uniqueChecksChanged := f.replaceUniqueChecksExpr(t.UniqueChecks, replace)
		fKChecks, fKChecksChanged := f.replaceFKChecksExpr(t.FKChecks, replace)
		if input != t.Input || uniqueChecksChanged || fKChecksChanged {
			return f.ConstructUpdate(input, uniqueChecks, fKChecks, &t.MutationPrivate)
		}
		return t

	case *memo.UpsertExpr:
		input := replace(t.Input).(memo.RelExpr)
		uniqueChecks, uniqueChecksChanged := f.replaceUniqueChecksExpr(t.UniqueChecks, replace)
		fKChecks, fKChecksChanged := f.replaceFKChecksExpr(t.FKChecks, replace)
		if input != t.Input || uniqueChecksChanged || fKChecksChanged {
			return f.ConstructUpsert(input, uniqueChecks, fKChecks, &t.MutationPrivate)
		}
		return t

	case *memo.DeleteExpr:
		input := replace(t.Input).(memo.RelExpr)
		uniqueChecks, uniqueChecksChanged := f.replaceUniqueChecksExpr(t.UniqueChecks, replace)
		fKChecks, fKChecksChanged := f.replaceFKChecksExpr(t.FKChecks, replace)
		if input != t.Input || uniqueChecksChanged || fKChecksChanged {
			return f.ConstructDelete(input, uniqueChecks, fKChecks, &t.MutationPrivate)
		}
		return t

	case *memo.FKChecksExpr:
		if after, changed := f.replaceFKChecksExpr(*t, replace); changed {
			return &after
		}
		return t

	case *memo.UniqueChecksExpr:
		if after, changed := f.replaceUniqueChecksExpr(*t, replace); changed {
			return &after
		}
		return t

	case *memo.ScanExpr:
		return t

	case *memo.PlaceholderScanExpr:
		span, spanChanged := f.replaceScalarListExpr(t.Span, replace)
		if spanChanged {
			return f.ConstructPlaceholderScan(span, &t.ScanPrivate)
		}
		return t

	case *memo.SequenceSelectExpr:
		return t

	case *memo.ValuesExpr:
		rows, rowsChanged := f.replaceScalarListExpr(t.Rows, replace)
		if rowsChanged {
			return f.ConstructValues(rows, &t.ValuesPrivate)
		}
		return t

	case *memo.LiteralValuesExpr:
		rows := replace(t.Rows).(*opt.LiteralRows)
		if rows != t.Rows {
			return f.ConstructLiteralValues(rows, t.Cols)
		}
		return t

	case *memo.SelectExpr:
		input := replace(t.Input).(memo.RelExpr)
		filters, filtersChanged := f.replaceFiltersExpr(t.Filters, replace)
		if input != t.Input || filtersChanged {
			return f.ConstructSelect(input, filters)
		}
		return t

	case *memo.ProjectExpr:
		input := replace(t.Input).(memo.RelExpr)
		projections, projectionsChanged := f.replaceProjectionsExpr(t.Projections, replace)
		if input != t.Input || projectionsChanged {
			return f.ConstructProject(input, projections, t.Passthrough)
		}
		return t

	case *memo.InvertedFilterExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructInvertedFilter(input, &t.InvertedFilterPrivate)
		}
		return t

	case *memo.InnerJoinExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructInnerJoin(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.LeftJoinExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructLeftJoin(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.RightJoinExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructRightJoin(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.FullJoinExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructFullJoin(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.SemiJoinExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructSemiJoin(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.AntiJoinExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructAntiJoin(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.IndexJoinExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructIndexJoin(input, &t.IndexJoinPrivate)
		}
		return t

	case *memo.LookupJoinExpr:
		input := replace(t.Input).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if input != t.Input || onChanged {
			return f.ConstructLookupJoin(input, on, &t.LookupJoinPrivate)
		}
		return t

	case *memo.InvertedJoinExpr:
		input := replace(t.Input).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if input != t.Input || onChanged {
			return f.ConstructInvertedJoin(input, on, &t.InvertedJoinPrivate)
		}
		return t

	case *memo.MergeJoinExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructMergeJoin(left, right, on, &t.MergeJoinPrivate)
		}
		return t

	case *memo.ZigzagJoinExpr:
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if onChanged {
			return f.ConstructZigzagJoin(on, &t.ZigzagJoinPrivate)
		}
		return t

	case *memo.InnerJoinApplyExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructInnerJoinApply(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.LeftJoinApplyExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructLeftJoinApply(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.SemiJoinApplyExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructSemiJoinApply(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.AntiJoinApplyExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		on, onChanged := f.replaceFiltersExpr(t.On, replace)
		if left != t.Left || right != t.Right || onChanged {
			return f.ConstructAntiJoinApply(left, right, on, &t.JoinPrivate)
		}
		return t

	case *memo.GroupByExpr:
		input := replace(t.Input).(memo.RelExpr)
		aggregations, aggregationsChanged := f.replaceAggregationsExpr(t.Aggregations, replace)
		if input != t.Input || aggregationsChanged {
			return f.ConstructGroupBy(input, aggregations, &t.GroupingPrivate)
		}
		return t

	case *memo.ScalarGroupByExpr:
		input := replace(t.Input).(memo.RelExpr)
		aggregations, aggregationsChanged := f.replaceAggregationsExpr(t.Aggregations, replace)
		if input != t.Input || aggregationsChanged {
			return f.ConstructScalarGroupBy(input, aggregations, &t.GroupingPrivate)
		}
		return t

	case *memo.DistinctOnExpr:
		input := replace(t.Input).(memo.RelExpr)
		aggregations, aggregationsChanged := f.replaceAggregationsExpr(t.Aggregations, replace)
		if input != t.Input || aggregationsChanged {
			return f.ConstructDistinctOn(input, aggregations, &t.GroupingPrivate)
		}
		return t

	case *memo.EnsureDistinctOnExpr:
		input := replace(t.Input).(memo.RelExpr)
		aggregations, aggregationsChanged := f.replaceAggregationsExpr(t.Aggregations, replace)
		if input != t.Input || aggregationsChanged {
			return f.ConstructEnsureDistinctOn(input, aggregations, &t.GroupingPrivate)
		}
		return t

	case *memo.UpsertDistinctOnExpr:
		input := replace(t.Input).(memo.RelExpr)
		aggregations, aggregationsChanged := f.replaceAggregationsExpr(t.Aggregations, replace)
		if input != t.Input || aggregationsChanged {
			return f.ConstructUpsertDistinctOn(input, aggregations, &t.GroupingPrivate)
		}
		return t

	case *memo.EnsureUpsertDistinctOnExpr:
		input := replace(t.Input).(memo.RelExpr)
		aggregations, aggregationsChanged := f.replaceAggregationsExpr(t.Aggregations, replace)
		if input != t.Input || aggregationsChanged {
			return f.ConstructEnsureUpsertDistinctOn(input, aggregations, &t.GroupingPrivate)
		}
		return t

	case *memo.UnionExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructUnion(left, right, &t.SetPrivate)
		}
		return t

	case *memo.IntersectExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructIntersect(left, right, &t.SetPrivate)
		}
		return t

	case *memo.ExceptExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructExcept(left, right, &t.SetPrivate)
		}
		return t

	case *memo.UnionAllExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructUnionAll(left, right, &t.SetPrivate)
		}
		return t

	case *memo.IntersectAllExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructIntersectAll(left, right, &t.SetPrivate)
		}
		return t

	case *memo.ExceptAllExpr:
		left := replace(t.Left).(memo.RelExpr)
		right := replace(t.Right).(memo.RelExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructExceptAll(left, right, &t.SetPrivate)
		}
		return t

	case *memo.LocalityOptimizedSearchExpr:
		local := replace(t.Local).(memo.RelExpr)
		remote := replace(t.Remote).(memo.RelExpr)
		if local != t.Local || remote != t.Remote {
			return f.ConstructLocalityOptimizedSearch(local, remote, &t.SetPrivate)
		}
		return t

	case *memo.LimitExpr:
		input := replace(t.Input).(memo.RelExpr)
		limit := replace(t.Limit).(opt.ScalarExpr)
		if input != t.Input || limit != t.Limit {
			return f.ConstructLimit(input, limit, t.Ordering)
		}
		return t

	case *memo.OffsetExpr:
		input := replace(t.Input).(memo.RelExpr)
		offset := replace(t.Offset).(opt.ScalarExpr)
		if input != t.Input || offset != t.Offset {
			return f.ConstructOffset(input, offset, t.Ordering)
		}
		return t

	case *memo.TopKExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructTopK(input, &t.TopKPrivate)
		}
		return t

	case *memo.Max1RowExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructMax1Row(input, t.ErrorText)
		}
		return t

	case *memo.OrdinalityExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructOrdinality(input, &t.OrdinalityPrivate)
		}
		return t

	case *memo.ProjectSetExpr:
		input := replace(t.Input).(memo.RelExpr)
		zip, zipChanged := f.replaceZipExpr(t.Zip, replace)
		if input != t.Input || zipChanged {
			return f.ConstructProjectSet(input, zip)
		}
		return t

	case *memo.WindowExpr:
		input := replace(t.Input).(memo.RelExpr)
		windows, windowsChanged := f.replaceWindowsExpr(t.Windows, replace)
		if input != t.Input || windowsChanged {
			return f.ConstructWindow(input, windows, &t.WindowPrivate)
		}
		return t

	case *memo.WithExpr:
		binding := replace(t.Binding).(memo.RelExpr)
		main := replace(t.Main).(memo.RelExpr)
		if binding != t.Binding || main != t.Main {
			return f.ConstructWith(binding, main, &t.WithPrivate)
		}
		return t

	case *memo.WithScanExpr:
		return t

	case *memo.RecursiveCTEExpr:
		binding := replace(t.Binding).(memo.RelExpr)
		initial := replace(t.Initial).(memo.RelExpr)
		recursive := replace(t.Recursive).(memo.RelExpr)
		if binding != t.Binding || initial != t.Initial || recursive != t.Recursive {
			return f.ConstructRecursiveCTE(binding, initial, recursive, &t.RecursiveCTEPrivate)
		}
		return t

	case *memo.FakeRelExpr:
		return t

	case *memo.SubqueryExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructSubquery(input, &t.SubqueryPrivate)
		}
		return t

	case *memo.AnyExpr:
		input := replace(t.Input).(memo.RelExpr)
		scalar := replace(t.Scalar).(opt.ScalarExpr)
		if input != t.Input || scalar != t.Scalar {
			return f.ConstructAny(input, scalar, &t.SubqueryPrivate)
		}
		return t

	case *memo.ExistsExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructExists(input, &t.SubqueryPrivate)
		}
		return t

	case *memo.VariableExpr:
		return t

	case *memo.ConstExpr:
		return t

	case *memo.NullExpr:
		return t

	case *memo.TrueExpr:
		return t

	case *memo.FalseExpr:
		return t

	case *memo.PlaceholderExpr:
		return t

	case *memo.TupleExpr:
		elems, elemsChanged := f.replaceScalarListExpr(t.Elems, replace)
		if elemsChanged {
			return f.ConstructTuple(elems, t.Typ)
		}
		return t

	case *memo.ProjectionsExpr:
		if after, changed := f.replaceProjectionsExpr(*t, replace); changed {
			return &after
		}
		return t

	case *memo.AggregationsExpr:
		if after, changed := f.replaceAggregationsExpr(*t, replace); changed {
			return &after
		}
		return t

	case *memo.FiltersExpr:
		if after, changed := f.replaceFiltersExpr(*t, replace); changed {
			return &after
		}
		return t

	case *memo.ZipExpr:
		if after, changed := f.replaceZipExpr(*t, replace); changed {
			return &after
		}
		return t

	case *memo.AndExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructAnd(left, right)
		}
		return t

	case *memo.OrExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructOr(left, right)
		}
		return t

	case *memo.RangeExpr:
		and := replace(t.And).(opt.ScalarExpr)
		if and != t.And {
			return f.ConstructRange(and)
		}
		return t

	case *memo.NotExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructNot(input)
		}
		return t

	case *memo.IsTupleNullExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructIsTupleNull(input)
		}
		return t

	case *memo.IsTupleNotNullExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructIsTupleNotNull(input)
		}
		return t

	case *memo.EqExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructEq(left, right)
		}
		return t

	case *memo.LtExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructLt(left, right)
		}
		return t

	case *memo.GtExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructGt(left, right)
		}
		return t

	case *memo.LeExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructLe(left, right)
		}
		return t

	case *memo.GeExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructGe(left, right)
		}
		return t

	case *memo.NeExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructNe(left, right)
		}
		return t

	case *memo.InExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructIn(left, right)
		}
		return t

	case *memo.NotInExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructNotIn(left, right)
		}
		return t

	case *memo.LikeExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructLike(left, right)
		}
		return t

	case *memo.NotLikeExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructNotLike(left, right)
		}
		return t

	case *memo.ILikeExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructILike(left, right)
		}
		return t

	case *memo.NotILikeExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructNotILike(left, right)
		}
		return t

	case *memo.SimilarToExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructSimilarTo(left, right)
		}
		return t

	case *memo.NotSimilarToExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructNotSimilarTo(left, right)
		}
		return t

	case *memo.RegMatchExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructRegMatch(left, right)
		}
		return t

	case *memo.NotRegMatchExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructNotRegMatch(left, right)
		}
		return t

	case *memo.RegIMatchExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructRegIMatch(left, right)
		}
		return t

	case *memo.NotRegIMatchExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructNotRegIMatch(left, right)
		}
		return t

	case *memo.IsExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructIs(left, right)
		}
		return t

	case *memo.IsNotExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructIsNot(left, right)
		}
		return t

	case *memo.ContainsExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructContains(left, right)
		}
		return t

	case *memo.ContainedByExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructContainedBy(left, right)
		}
		return t

	case *memo.JsonExistsExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructJsonExists(left, right)
		}
		return t

	case *memo.JsonAllExistsExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructJsonAllExists(left, right)
		}
		return t

	case *memo.JsonSomeExistsExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructJsonSomeExists(left, right)
		}
		return t

	case *memo.OverlapsExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructOverlaps(left, right)
		}
		return t

	case *memo.BBoxCoversExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructBBoxCovers(left, right)
		}
		return t

	case *memo.BBoxIntersectsExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructBBoxIntersects(left, right)
		}
		return t

	case *memo.AnyScalarExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructAnyScalar(left, right, t.Cmp)
		}
		return t

	case *memo.BitandExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructBitand(left, right)
		}
		return t

	case *memo.BitorExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructBitor(left, right)
		}
		return t

	case *memo.BitxorExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructBitxor(left, right)
		}
		return t

	case *memo.PlusExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructPlus(left, right)
		}
		return t

	case *memo.MinusExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructMinus(left, right)
		}
		return t

	case *memo.MultExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructMult(left, right)
		}
		return t

	case *memo.DivExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructDiv(left, right)
		}
		return t

	case *memo.FloorDivExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructFloorDiv(left, right)
		}
		return t

	case *memo.ModExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructMod(left, right)
		}
		return t

	case *memo.PowExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructPow(left, right)
		}
		return t

	case *memo.ConcatExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructConcat(left, right)
		}
		return t

	case *memo.LShiftExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructLShift(left, right)
		}
		return t

	case *memo.RShiftExpr:
		left := replace(t.Left).(opt.ScalarExpr)
		right := replace(t.Right).(opt.ScalarExpr)
		if left != t.Left || right != t.Right {
			return f.ConstructRShift(left, right)
		}
		return t

	case *memo.FetchValExpr:
		json := replace(t.Json).(opt.ScalarExpr)
		index := replace(t.Index).(opt.ScalarExpr)
		if json != t.Json || index != t.Index {
			return f.ConstructFetchVal(json, index)
		}
		return t

	case *memo.FetchTextExpr:
		json := replace(t.Json).(opt.ScalarExpr)
		index := replace(t.Index).(opt.ScalarExpr)
		if json != t.Json || index != t.Index {
			return f.ConstructFetchText(json, index)
		}
		return t

	case *memo.FetchValPathExpr:
		json := replace(t.Json).(opt.ScalarExpr)
		path := replace(t.Path).(opt.ScalarExpr)
		if json != t.Json || path != t.Path {
			return f.ConstructFetchValPath(json, path)
		}
		return t

	case *memo.FetchTextPathExpr:
		json := replace(t.Json).(opt.ScalarExpr)
		path := replace(t.Path).(opt.ScalarExpr)
		if json != t.Json || path != t.Path {
			return f.ConstructFetchTextPath(json, path)
		}
		return t

	case *memo.UnaryMinusExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructUnaryMinus(input)
		}
		return t

	case *memo.UnaryPlusExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructUnaryPlus(input)
		}
		return t

	case *memo.UnaryComplementExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructUnaryComplement(input)
		}
		return t

	case *memo.UnarySqrtExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructUnarySqrt(input)
		}
		return t

	case *memo.UnaryCbrtExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructUnaryCbrt(input)
		}
		return t

	case *memo.CastExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructCast(input, t.Typ)
		}
		return t

	case *memo.AssignmentCastExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructAssignmentCast(input, t.Typ)
		}
		return t

	case *memo.IfErrExpr:
		cond := replace(t.Cond).(opt.ScalarExpr)
		orElse, orElseChanged := f.replaceScalarListExpr(t.OrElse, replace)
		errCode, errCodeChanged := f.replaceScalarListExpr(t.ErrCode, replace)
		if cond != t.Cond || orElseChanged || errCodeChanged {
			return f.ConstructIfErr(cond, orElse, errCode)
		}
		return t

	case *memo.CaseExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		whens, whensChanged := f.replaceScalarListExpr(t.Whens, replace)
		orElse := replace(t.OrElse).(opt.ScalarExpr)
		if input != t.Input || whensChanged || orElse != t.OrElse {
			return f.ConstructCase(input, whens, orElse)
		}
		return t

	case *memo.WhenExpr:
		condition := replace(t.Condition).(opt.ScalarExpr)
		value := replace(t.Value).(opt.ScalarExpr)
		if condition != t.Condition || value != t.Value {
			return f.ConstructWhen(condition, value)
		}
		return t

	case *memo.ArrayExpr:
		elems, elemsChanged := f.replaceScalarListExpr(t.Elems, replace)
		if elemsChanged {
			return f.ConstructArray(elems, t.Typ)
		}
		return t

	case *memo.IndirectionExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		index := replace(t.Index).(opt.ScalarExpr)
		if input != t.Input || index != t.Index {
			return f.ConstructIndirection(input, index)
		}
		return t

	case *memo.ArrayFlattenExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructArrayFlatten(input, &t.SubqueryPrivate)
		}
		return t

	case *memo.FunctionExpr:
		args, argsChanged := f.replaceScalarListExpr(t.Args, replace)
		if argsChanged {
			return f.ConstructFunction(args, &t.FunctionPrivate)
		}
		return t

	case *memo.CollateExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructCollate(input, t.Locale)
		}
		return t

	case *memo.CoalesceExpr:
		args, argsChanged := f.replaceScalarListExpr(t.Args, replace)
		if argsChanged {
			return f.ConstructCoalesce(args)
		}
		return t

	case *memo.ColumnAccessExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructColumnAccess(input, t.Idx)
		}
		return t

	case *memo.ArrayAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructArrayAgg(input)
		}
		return t

	case *memo.AvgExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructAvg(input)
		}
		return t

	case *memo.BitAndAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructBitAndAgg(input)
		}
		return t

	case *memo.BitOrAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructBitOrAgg(input)
		}
		return t

	case *memo.BoolAndExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructBoolAnd(input)
		}
		return t

	case *memo.BoolOrExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructBoolOr(input)
		}
		return t

	case *memo.ConcatAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructConcatAgg(input)
		}
		return t

	case *memo.CorrExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructCorr(y, x)
		}
		return t

	case *memo.CountExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructCount(input)
		}
		return t

	case *memo.CountRowsExpr:
		return t

	case *memo.CovarPopExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructCovarPop(y, x)
		}
		return t

	case *memo.CovarSampExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructCovarSamp(y, x)
		}
		return t

	case *memo.RegressionAvgXExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructRegressionAvgX(y, x)
		}
		return t

	case *memo.RegressionAvgYExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructRegressionAvgY(y, x)
		}
		return t

	case *memo.RegressionInterceptExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructRegressionIntercept(y, x)
		}
		return t

	case *memo.RegressionR2Expr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructRegressionR2(y, x)
		}
		return t

	case *memo.RegressionSlopeExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructRegressionSlope(y, x)
		}
		return t

	case *memo.RegressionSXXExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructRegressionSXX(y, x)
		}
		return t

	case *memo.RegressionSXYExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructRegressionSXY(y, x)
		}
		return t

	case *memo.RegressionSYYExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructRegressionSYY(y, x)
		}
		return t

	case *memo.RegressionCountExpr:
		y := replace(t.Y).(opt.ScalarExpr)
		x := replace(t.X).(opt.ScalarExpr)
		if y != t.Y || x != t.X {
			return f.ConstructRegressionCount(y, x)
		}
		return t

	case *memo.MaxExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructMax(input)
		}
		return t

	case *memo.MinExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructMin(input)
		}
		return t

	case *memo.SumIntExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructSumInt(input)
		}
		return t

	case *memo.SumExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructSum(input)
		}
		return t

	case *memo.SqrDiffExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructSqrDiff(input)
		}
		return t

	case *memo.VarianceExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructVariance(input)
		}
		return t

	case *memo.VarPopExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructVarPop(input)
		}
		return t

	case *memo.StdDevExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructStdDev(input)
		}
		return t

	case *memo.StdDevPopExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructStdDevPop(input)
		}
		return t

	case *memo.STMakeLineExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructSTMakeLine(input)
		}
		return t

	case *memo.STExtentExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructSTExtent(input)
		}
		return t

	case *memo.STUnionExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructSTUnion(input)
		}
		return t

	case *memo.STCollectExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructSTCollect(input)
		}
		return t

	case *memo.XorAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructXorAgg(input)
		}
		return t

	case *memo.JsonAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructJsonAgg(input)
		}
		return t

	case *memo.JsonbAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructJsonbAgg(input)
		}
		return t

	case *memo.JsonObjectAggExpr:
		key := replace(t.Key).(opt.ScalarExpr)
		value := replace(t.Value).(opt.ScalarExpr)
		if key != t.Key || value != t.Value {
			return f.ConstructJsonObjectAgg(key, value)
		}
		return t

	case *memo.JsonbObjectAggExpr:
		key := replace(t.Key).(opt.ScalarExpr)
		value := replace(t.Value).(opt.ScalarExpr)
		if key != t.Key || value != t.Value {
			return f.ConstructJsonbObjectAgg(key, value)
		}
		return t

	case *memo.StringAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		sep := replace(t.Sep).(opt.ScalarExpr)
		if input != t.Input || sep != t.Sep {
			return f.ConstructStringAgg(input, sep)
		}
		return t

	case *memo.ConstAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructConstAgg(input)
		}
		return t

	case *memo.ConstNotNullAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructConstNotNullAgg(input)
		}
		return t

	case *memo.AnyNotNullAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructAnyNotNullAgg(input)
		}
		return t

	case *memo.FirstAggExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructFirstAgg(input)
		}
		return t

	case *memo.PercentileDiscExpr:
		fraction := replace(t.Fraction).(opt.ScalarExpr)
		input := replace(t.Input).(opt.ScalarExpr)
		if fraction != t.Fraction || input != t.Input {
			return f.ConstructPercentileDisc(fraction, input)
		}
		return t

	case *memo.PercentileContExpr:
		fraction := replace(t.Fraction).(opt.ScalarExpr)
		input := replace(t.Input).(opt.ScalarExpr)
		if fraction != t.Fraction || input != t.Input {
			return f.ConstructPercentileCont(fraction, input)
		}
		return t

	case *memo.AggDistinctExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		if input != t.Input {
			return f.ConstructAggDistinct(input)
		}
		return t

	case *memo.AggFilterExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		filter := replace(t.Filter).(opt.ScalarExpr)
		if input != t.Input || filter != t.Filter {
			return f.ConstructAggFilter(input, filter)
		}
		return t

	case *memo.WindowFromOffsetExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		offset := replace(t.Offset).(opt.ScalarExpr)
		if input != t.Input || offset != t.Offset {
			return f.ConstructWindowFromOffset(input, offset)
		}
		return t

	case *memo.WindowToOffsetExpr:
		input := replace(t.Input).(opt.ScalarExpr)
		offset := replace(t.Offset).(opt.ScalarExpr)
		if input != t.Input || offset != t.Offset {
			return f.ConstructWindowToOffset(input, offset)
		}
		return t

	case *memo.WindowsExpr:
		if after, changed := f.replaceWindowsExpr(*t, replace); changed {
			return &after
		}
		return t

	case *memo.RankExpr:
		return t

	case *memo.RowNumberExpr:
		return t

	case *memo.DenseRankExpr:
		return t

	case *memo.PercentRankExpr:
		return t

	case *memo.CumeDistExpr:
		return t

	case *memo.NtileExpr:
		numBuckets := replace(t.NumBuckets).(opt.ScalarExpr)
		if numBuckets != t.NumBuckets {
			return f.ConstructNtile(numBuckets)
		}
		return t

	case *memo.LagExpr:
		value := replace(t.Value).(opt.ScalarExpr)
		offset := replace(t.Offset).(opt.ScalarExpr)
		def := replace(t.Def).(opt.ScalarExpr)
		if value != t.Value || offset != t.Offset || def != t.Def {
			return f.ConstructLag(value, offset, def)
		}
		return t

	case *memo.LeadExpr:
		value := replace(t.Value).(opt.ScalarExpr)
		offset := replace(t.Offset).(opt.ScalarExpr)
		def := replace(t.Def).(opt.ScalarExpr)
		if value != t.Value || offset != t.Offset || def != t.Def {
			return f.ConstructLead(value, offset, def)
		}
		return t

	case *memo.FirstValueExpr:
		value := replace(t.Value).(opt.ScalarExpr)
		if value != t.Value {
			return f.ConstructFirstValue(value)
		}
		return t

	case *memo.LastValueExpr:
		value := replace(t.Value).(opt.ScalarExpr)
		if value != t.Value {
			return f.ConstructLastValue(value)
		}
		return t

	case *memo.NthValueExpr:
		value := replace(t.Value).(opt.ScalarExpr)
		nth := replace(t.Nth).(opt.ScalarExpr)
		if value != t.Value || nth != t.Nth {
			return f.ConstructNthValue(value, nth)
		}
		return t

	case *memo.UDFExpr:
		input, inputChanged := f.replaceScalarListExpr(t.Input, replace)
		if inputChanged {
			return f.ConstructUDF(input, &t.UDFPrivate)
		}
		return t

	case *memo.KVOptionsExpr:
		if after, changed := f.replaceKVOptionsExpr(*t, replace); changed {
			return &after
		}
		return t

	case *memo.ScalarListExpr:
		if after, changed := f.replaceScalarListExpr(*t, replace); changed {
			return &after
		}
		return t

	case *memo.CreateTableExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructCreateTable(input, &t.CreateTablePrivate)
		}
		return t

	case *memo.CreateViewExpr:
		return t

	case *memo.CreateFunctionExpr:
		return t

	case *memo.ExplainExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructExplain(input, &t.ExplainPrivate)
		}
		return t

	case *memo.ShowTraceForSessionExpr:
		return t

	case *memo.OpaqueRelExpr:
		return t

	case *memo.OpaqueMutationExpr:
		return t

	case *memo.OpaqueDDLExpr:
		return t

	case *memo.AlterTableSplitExpr:
		input := replace(t.Input).(memo.RelExpr)
		expiration := replace(t.Expiration).(opt.ScalarExpr)
		if input != t.Input || expiration != t.Expiration {
			return f.ConstructAlterTableSplit(input, expiration, &t.AlterTableSplitPrivate)
		}
		return t

	case *memo.AlterTableUnsplitExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructAlterTableUnsplit(input, &t.AlterTableSplitPrivate)
		}
		return t

	case *memo.AlterTableUnsplitAllExpr:
		return t

	case *memo.AlterTableRelocateExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructAlterTableRelocate(input, &t.AlterTableRelocatePrivate)
		}
		return t

	case *memo.ControlJobsExpr:
		input := replace(t.Input).(memo.RelExpr)
		reason := replace(t.Reason).(opt.ScalarExpr)
		if input != t.Input || reason != t.Reason {
			return f.ConstructControlJobs(input, reason, &t.ControlJobsPrivate)
		}
		return t

	case *memo.ControlSchedulesExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructControlSchedules(input, &t.ControlSchedulesPrivate)
		}
		return t

	case *memo.CancelQueriesExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructCancelQueries(input, &t.CancelPrivate)
		}
		return t

	case *memo.CancelSessionsExpr:
		input := replace(t.Input).(memo.RelExpr)
		if input != t.Input {
			return f.ConstructCancelSessions(input, &t.CancelPrivate)
		}
		return t

	case *memo.ExportExpr:
		input := replace(t.Input).(memo.RelExpr)
		fileName := replace(t.FileName).(opt.ScalarExpr)
		options, optionsChanged := f.replaceKVOptionsExpr(t.Options, replace)
		if input != t.Input || fileName != t.FileName || optionsChanged {
			return f.ConstructExport(input, fileName, options, &t.ExportPrivate)
		}
		return t

	case *memo.CreateStatisticsExpr:
		return t

	case *memo.AlterRangeRelocateExpr:
		input := replace(t.Input).(memo.RelExpr)
		toStoreID := replace(t.ToStoreID).(opt.ScalarExpr)
		fromStoreID := replace(t.FromStoreID).(opt.ScalarExpr)
		if input != t.Input || toStoreID != t.ToStoreID || fromStoreID != t.FromStoreID {
			return f.ConstructAlterRangeRelocate(input, toStoreID, fromStoreID, &t.AlterRangeRelocatePrivate)
		}
		return t

	}
	panic(errors.AssertionFailedf("unhandled op %s", errors.Safe(e.Op())))
}

func (f *Factory) replaceFKChecksExpr(list memo.FKChecksExpr, replace ReplaceFunc) (_ memo.FKChecksExpr, changed bool) {
	var newList []memo.FKChecksItem
	for i := range list {
		before := list[i].Check
		after := replace(before).(memo.RelExpr)
		if before != after {
			if newList == nil {
				newList = make([]memo.FKChecksItem, len(list))
				copy(newList, list[:i])
			}
			newList[i] = f.ConstructFKChecksItem(after, &list[i].FKChecksItemPrivate)
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

func (f *Factory) replaceUniqueChecksExpr(list memo.UniqueChecksExpr, replace ReplaceFunc) (_ memo.UniqueChecksExpr, changed bool) {
	var newList []memo.UniqueChecksItem
	for i := range list {
		before := list[i].Check
		after := replace(before).(memo.RelExpr)
		if before != after {
			if newList == nil {
				newList = make([]memo.UniqueChecksItem, len(list))
				copy(newList, list[:i])
			}
			newList[i] = f.ConstructUniqueChecksItem(after, &list[i].UniqueChecksItemPrivate)
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

func (f *Factory) replaceProjectionsExpr(list memo.ProjectionsExpr, replace ReplaceFunc) (_ memo.ProjectionsExpr, changed bool) {
	var newList []memo.ProjectionsItem
	for i := range list {
		before := list[i].Element
		after := replace(before).(opt.ScalarExpr)
		if before != after {
			if newList == nil {
				newList = make([]memo.ProjectionsItem, len(list))
				copy(newList, list[:i])
			}
			newList[i] = f.ConstructProjectionsItem(after, list[i].Col)
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

func (f *Factory) replaceAggregationsExpr(list memo.AggregationsExpr, replace ReplaceFunc) (_ memo.AggregationsExpr, changed bool) {
	var newList []memo.AggregationsItem
	for i := range list {
		before := list[i].Agg
		after := replace(before).(opt.ScalarExpr)
		if before != after {
			if newList == nil {
				newList = make([]memo.AggregationsItem, len(list))
				copy(newList, list[:i])
			}
			newList[i] = f.ConstructAggregationsItem(after, list[i].Col)
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

func (f *Factory) replaceFiltersExpr(list memo.FiltersExpr, replace ReplaceFunc) (_ memo.FiltersExpr, changed bool) {
	var newList []memo.FiltersItem
	for i := range list {
		before := list[i].Condition
		after := replace(before).(opt.ScalarExpr)
		if before != after {
			if newList == nil {
				newList = make([]memo.FiltersItem, len(list))
				copy(newList, list[:i])
			}
			newList[i] = f.ConstructFiltersItem(after)
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

func (f *Factory) replaceZipExpr(list memo.ZipExpr, replace ReplaceFunc) (_ memo.ZipExpr, changed bool) {
	var newList []memo.ZipItem
	for i := range list {
		before := list[i].Fn
		after := replace(before).(opt.ScalarExpr)
		if before != after {
			if newList == nil {
				newList = make([]memo.ZipItem, len(list))
				copy(newList, list[:i])
			}
			newList[i] = f.ConstructZipItem(after, list[i].Cols)
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

func (f *Factory) replaceWindowsExpr(list memo.WindowsExpr, replace ReplaceFunc) (_ memo.WindowsExpr, changed bool) {
	var newList []memo.WindowsItem
	for i := range list {
		before := list[i].Function
		after := replace(before).(opt.ScalarExpr)
		if before != after {
			if newList == nil {
				newList = make([]memo.WindowsItem, len(list))
				copy(newList, list[:i])
			}
			newList[i] = f.ConstructWindowsItem(after, &list[i].WindowsItemPrivate)
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

func (f *Factory) replaceKVOptionsExpr(list memo.KVOptionsExpr, replace ReplaceFunc) (_ memo.KVOptionsExpr, changed bool) {
	var newList []memo.KVOptionsItem
	for i := range list {
		before := list[i].Value
		after := replace(before).(opt.ScalarExpr)
		if before != after {
			if newList == nil {
				newList = make([]memo.KVOptionsItem, len(list))
				copy(newList, list[:i])
			}
			newList[i] = f.ConstructKVOptionsItem(after, list[i].Key)
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

func (f *Factory) replaceScalarListExpr(list memo.ScalarListExpr, replace ReplaceFunc) (_ memo.ScalarListExpr, changed bool) {
	var newList []opt.ScalarExpr
	for i := range list {
		before := list[i]
		after := replace(before).(opt.ScalarExpr)
		if before != after {
			if newList == nil {
				newList = make([]opt.ScalarExpr, len(list))
				copy(newList, list[:i])
			}
			newList[i] = after
		} else if newList != nil {
			newList[i] = list[i]
		}
	}
	if newList == nil {
		return list, false
	}
	return newList, true
}

// CopyAndReplaceDefault performs the default traversal and cloning behavior
// for the CopyAndReplace method. It constructs a copy of the given source
// operator using children copied (and potentially remapped) by the given replace
// function. See comments for CopyAndReplace for more details.
func (f *Factory) CopyAndReplaceDefault(src opt.Expr, replace ReplaceFunc) (dst opt.Expr) {
	switch t := src.(type) {
	case *memo.NormCycleTestRelExpr:
		return f.ConstructNormCycleTestRel(
			f.invokeReplace(t.Scalar, replace).(opt.ScalarExpr),
		)

	case *memo.MemoCycleTestRelExpr:
		return f.ConstructMemoCycleTestRel(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.Filters, replace),
		)

	case *memo.InsertExpr:
		input := f.invokeReplace(t.Input, replace).(memo.RelExpr)
		if id := t.WithBindingID(); id != 0 {
			f.Metadata().AddWithBinding(id, input)
		}
		return f.ConstructInsert(
			input,
			f.copyAndReplaceDefaultUniqueChecksExpr(t.UniqueChecks, replace),
			f.copyAndReplaceDefaultFKChecksExpr(t.FKChecks, replace),
			&t.MutationPrivate,
		)

	case *memo.UpdateExpr:
		input := f.invokeReplace(t.Input, replace).(memo.RelExpr)
		if id := t.WithBindingID(); id != 0 {
			f.Metadata().AddWithBinding(id, input)
		}
		return f.ConstructUpdate(
			input,
			f.copyAndReplaceDefaultUniqueChecksExpr(t.UniqueChecks, replace),
			f.copyAndReplaceDefaultFKChecksExpr(t.FKChecks, replace),
			&t.MutationPrivate,
		)

	case *memo.UpsertExpr:
		input := f.invokeReplace(t.Input, replace).(memo.RelExpr)
		if id := t.WithBindingID(); id != 0 {
			f.Metadata().AddWithBinding(id, input)
		}
		return f.ConstructUpsert(
			input,
			f.copyAndReplaceDefaultUniqueChecksExpr(t.UniqueChecks, replace),
			f.copyAndReplaceDefaultFKChecksExpr(t.FKChecks, replace),
			&t.MutationPrivate,
		)

	case *memo.DeleteExpr:
		input := f.invokeReplace(t.Input, replace).(memo.RelExpr)
		if id := t.WithBindingID(); id != 0 {
			f.Metadata().AddWithBinding(id, input)
		}
		return f.ConstructDelete(
			input,
			f.copyAndReplaceDefaultUniqueChecksExpr(t.UniqueChecks, replace),
			f.copyAndReplaceDefaultFKChecksExpr(t.FKChecks, replace),
			&t.MutationPrivate,
		)

	case *memo.ScanExpr:
		return f.mem.MemoizeScan(&t.ScanPrivate)

	case *memo.PlaceholderScanExpr:
		return f.ConstructPlaceholderScan(
			f.copyAndReplaceDefaultScalarListExpr(t.Span, replace),
			&t.ScanPrivate,
		)

	case *memo.SequenceSelectExpr:
		return f.mem.MemoizeSequenceSelect(&t.SequenceSelectPrivate)

	case *memo.ValuesExpr:
		return f.ConstructValues(
			f.copyAndReplaceDefaultScalarListExpr(t.Rows, replace),
			&t.ValuesPrivate,
		)

	case *memo.LiteralValuesExpr:
		return f.ConstructLiteralValues(
			f.invokeReplace(t.Rows, replace).(*opt.LiteralRows),
			t.Cols,
		)

	case *memo.SelectExpr:
		return f.ConstructSelect(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.Filters, replace),
		)

	case *memo.ProjectExpr:
		return f.ConstructProject(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultProjectionsExpr(t.Projections, replace),
			t.Passthrough,
		)

	case *memo.InvertedFilterExpr:
		return f.ConstructInvertedFilter(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.InvertedFilterPrivate,
		)

	case *memo.InnerJoinExpr:
		return f.ConstructInnerJoin(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.LeftJoinExpr:
		return f.ConstructLeftJoin(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.RightJoinExpr:
		return f.ConstructRightJoin(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.FullJoinExpr:
		return f.ConstructFullJoin(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.SemiJoinExpr:
		return f.ConstructSemiJoin(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.AntiJoinExpr:
		return f.ConstructAntiJoin(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.IndexJoinExpr:
		return f.ConstructIndexJoin(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.IndexJoinPrivate,
		)

	case *memo.LookupJoinExpr:
		return f.ConstructLookupJoin(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.LookupJoinPrivate,
		)

	case *memo.InvertedJoinExpr:
		return f.ConstructInvertedJoin(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.InvertedJoinPrivate,
		)

	case *memo.MergeJoinExpr:
		return f.ConstructMergeJoin(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.MergeJoinPrivate,
		)

	case *memo.ZigzagJoinExpr:
		return f.ConstructZigzagJoin(
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.ZigzagJoinPrivate,
		)

	case *memo.InnerJoinApplyExpr:
		return f.ConstructInnerJoinApply(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.LeftJoinApplyExpr:
		return f.ConstructLeftJoinApply(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.SemiJoinApplyExpr:
		return f.ConstructSemiJoinApply(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.AntiJoinApplyExpr:
		return f.ConstructAntiJoinApply(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultFiltersExpr(t.On, replace),
			&t.JoinPrivate,
		)

	case *memo.GroupByExpr:
		return f.ConstructGroupBy(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultAggregationsExpr(t.Aggregations, replace),
			&t.GroupingPrivate,
		)

	case *memo.ScalarGroupByExpr:
		return f.ConstructScalarGroupBy(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultAggregationsExpr(t.Aggregations, replace),
			&t.GroupingPrivate,
		)

	case *memo.DistinctOnExpr:
		return f.ConstructDistinctOn(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultAggregationsExpr(t.Aggregations, replace),
			&t.GroupingPrivate,
		)

	case *memo.EnsureDistinctOnExpr:
		return f.ConstructEnsureDistinctOn(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultAggregationsExpr(t.Aggregations, replace),
			&t.GroupingPrivate,
		)

	case *memo.UpsertDistinctOnExpr:
		return f.ConstructUpsertDistinctOn(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultAggregationsExpr(t.Aggregations, replace),
			&t.GroupingPrivate,
		)

	case *memo.EnsureUpsertDistinctOnExpr:
		return f.ConstructEnsureUpsertDistinctOn(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultAggregationsExpr(t.Aggregations, replace),
			&t.GroupingPrivate,
		)

	case *memo.UnionExpr:
		return f.ConstructUnion(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			&t.SetPrivate,
		)

	case *memo.IntersectExpr:
		return f.ConstructIntersect(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			&t.SetPrivate,
		)

	case *memo.ExceptExpr:
		return f.ConstructExcept(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			&t.SetPrivate,
		)

	case *memo.UnionAllExpr:
		return f.ConstructUnionAll(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			&t.SetPrivate,
		)

	case *memo.IntersectAllExpr:
		return f.ConstructIntersectAll(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			&t.SetPrivate,
		)

	case *memo.ExceptAllExpr:
		return f.ConstructExceptAll(
			f.invokeReplace(t.Left, replace).(memo.RelExpr),
			f.invokeReplace(t.Right, replace).(memo.RelExpr),
			&t.SetPrivate,
		)

	case *memo.LocalityOptimizedSearchExpr:
		return f.ConstructLocalityOptimizedSearch(
			f.invokeReplace(t.Local, replace).(memo.RelExpr),
			f.invokeReplace(t.Remote, replace).(memo.RelExpr),
			&t.SetPrivate,
		)

	case *memo.LimitExpr:
		return f.ConstructLimit(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.invokeReplace(t.Limit, replace).(opt.ScalarExpr),
			t.Ordering,
		)

	case *memo.OffsetExpr:
		return f.ConstructOffset(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.invokeReplace(t.Offset, replace).(opt.ScalarExpr),
			t.Ordering,
		)

	case *memo.TopKExpr:
		return f.ConstructTopK(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.TopKPrivate,
		)

	case *memo.Max1RowExpr:
		return f.ConstructMax1Row(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			t.ErrorText,
		)

	case *memo.OrdinalityExpr:
		return f.ConstructOrdinality(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.OrdinalityPrivate,
		)

	case *memo.ProjectSetExpr:
		return f.ConstructProjectSet(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultZipExpr(t.Zip, replace),
		)

	case *memo.WindowExpr:
		return f.ConstructWindow(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.copyAndReplaceDefaultWindowsExpr(t.Windows, replace),
			&t.WindowPrivate,
		)

	case *memo.WithExpr:
		binding := f.invokeReplace(t.Binding, replace).(memo.RelExpr)
		if id := t.WithBindingID(); id != 0 {
			f.Metadata().AddWithBinding(id, binding)
		}
		return f.ConstructWith(
			binding,
			f.invokeReplace(t.Main, replace).(memo.RelExpr),
			&t.WithPrivate,
		)

	case *memo.WithScanExpr:
		return f.mem.MemoizeWithScan(&t.WithScanPrivate)

	case *memo.RecursiveCTEExpr:
		binding := f.invokeReplace(t.Binding, replace).(memo.RelExpr)
		if id := t.WithBindingID(); id != 0 {
			f.Metadata().AddWithBinding(id, binding)
		}
		return f.ConstructRecursiveCTE(
			binding,
			f.invokeReplace(t.Initial, replace).(memo.RelExpr),
			f.invokeReplace(t.Recursive, replace).(memo.RelExpr),
			&t.RecursiveCTEPrivate,
		)

	case *memo.FakeRelExpr:
		return f.mem.MemoizeFakeRel(&t.FakeRelPrivate)

	case *memo.SubqueryExpr:
		return f.ConstructSubquery(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.SubqueryPrivate,
		)

	case *memo.AnyExpr:
		return f.ConstructAny(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.invokeReplace(t.Scalar, replace).(opt.ScalarExpr),
			&t.SubqueryPrivate,
		)

	case *memo.ExistsExpr:
		return f.ConstructExists(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.SubqueryPrivate,
		)

	case *memo.VariableExpr:
		return t

	case *memo.ConstExpr:
		return t

	case *memo.NullExpr:
		return t

	case *memo.TrueExpr:
		return t

	case *memo.FalseExpr:
		return t

	case *memo.PlaceholderExpr:
		return t

	case *memo.TupleExpr:
		return f.ConstructTuple(
			f.copyAndReplaceDefaultScalarListExpr(t.Elems, replace),
			t.Typ,
		)

	case *memo.AndExpr:
		return f.ConstructAnd(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.OrExpr:
		return f.ConstructOr(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.RangeExpr:
		return f.ConstructRange(
			f.invokeReplace(t.And, replace).(opt.ScalarExpr),
		)

	case *memo.NotExpr:
		return f.ConstructNot(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.IsTupleNullExpr:
		return f.ConstructIsTupleNull(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.IsTupleNotNullExpr:
		return f.ConstructIsTupleNotNull(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.EqExpr:
		return f.ConstructEq(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.LtExpr:
		return f.ConstructLt(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.GtExpr:
		return f.ConstructGt(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.LeExpr:
		return f.ConstructLe(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.GeExpr:
		return f.ConstructGe(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.NeExpr:
		return f.ConstructNe(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.InExpr:
		return f.ConstructIn(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.NotInExpr:
		return f.ConstructNotIn(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.LikeExpr:
		return f.ConstructLike(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.NotLikeExpr:
		return f.ConstructNotLike(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.ILikeExpr:
		return f.ConstructILike(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.NotILikeExpr:
		return f.ConstructNotILike(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.SimilarToExpr:
		return f.ConstructSimilarTo(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.NotSimilarToExpr:
		return f.ConstructNotSimilarTo(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.RegMatchExpr:
		return f.ConstructRegMatch(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.NotRegMatchExpr:
		return f.ConstructNotRegMatch(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.RegIMatchExpr:
		return f.ConstructRegIMatch(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.NotRegIMatchExpr:
		return f.ConstructNotRegIMatch(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.IsExpr:
		return f.ConstructIs(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.IsNotExpr:
		return f.ConstructIsNot(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.ContainsExpr:
		return f.ConstructContains(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.ContainedByExpr:
		return f.ConstructContainedBy(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.JsonExistsExpr:
		return f.ConstructJsonExists(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.JsonAllExistsExpr:
		return f.ConstructJsonAllExists(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.JsonSomeExistsExpr:
		return f.ConstructJsonSomeExists(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.OverlapsExpr:
		return f.ConstructOverlaps(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.BBoxCoversExpr:
		return f.ConstructBBoxCovers(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.BBoxIntersectsExpr:
		return f.ConstructBBoxIntersects(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.AnyScalarExpr:
		return f.ConstructAnyScalar(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
			t.Cmp,
		)

	case *memo.BitandExpr:
		return f.ConstructBitand(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.BitorExpr:
		return f.ConstructBitor(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.BitxorExpr:
		return f.ConstructBitxor(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.PlusExpr:
		return f.ConstructPlus(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.MinusExpr:
		return f.ConstructMinus(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.MultExpr:
		return f.ConstructMult(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.DivExpr:
		return f.ConstructDiv(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.FloorDivExpr:
		return f.ConstructFloorDiv(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.ModExpr:
		return f.ConstructMod(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.PowExpr:
		return f.ConstructPow(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.ConcatExpr:
		return f.ConstructConcat(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.LShiftExpr:
		return f.ConstructLShift(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.RShiftExpr:
		return f.ConstructRShift(
			f.invokeReplace(t.Left, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Right, replace).(opt.ScalarExpr),
		)

	case *memo.FetchValExpr:
		return f.ConstructFetchVal(
			f.invokeReplace(t.Json, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Index, replace).(opt.ScalarExpr),
		)

	case *memo.FetchTextExpr:
		return f.ConstructFetchText(
			f.invokeReplace(t.Json, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Index, replace).(opt.ScalarExpr),
		)

	case *memo.FetchValPathExpr:
		return f.ConstructFetchValPath(
			f.invokeReplace(t.Json, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Path, replace).(opt.ScalarExpr),
		)

	case *memo.FetchTextPathExpr:
		return f.ConstructFetchTextPath(
			f.invokeReplace(t.Json, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Path, replace).(opt.ScalarExpr),
		)

	case *memo.UnaryMinusExpr:
		return f.ConstructUnaryMinus(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.UnaryPlusExpr:
		return f.ConstructUnaryPlus(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.UnaryComplementExpr:
		return f.ConstructUnaryComplement(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.UnarySqrtExpr:
		return f.ConstructUnarySqrt(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.UnaryCbrtExpr:
		return f.ConstructUnaryCbrt(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.CastExpr:
		return f.ConstructCast(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			t.Typ,
		)

	case *memo.AssignmentCastExpr:
		return f.ConstructAssignmentCast(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			t.Typ,
		)

	case *memo.IfErrExpr:
		return f.ConstructIfErr(
			f.invokeReplace(t.Cond, replace).(opt.ScalarExpr),
			f.copyAndReplaceDefaultScalarListExpr(t.OrElse, replace),
			f.copyAndReplaceDefaultScalarListExpr(t.ErrCode, replace),
		)

	case *memo.CaseExpr:
		return f.ConstructCase(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			f.copyAndReplaceDefaultScalarListExpr(t.Whens, replace),
			f.invokeReplace(t.OrElse, replace).(opt.ScalarExpr),
		)

	case *memo.WhenExpr:
		return f.ConstructWhen(
			f.invokeReplace(t.Condition, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Value, replace).(opt.ScalarExpr),
		)

	case *memo.ArrayExpr:
		return f.ConstructArray(
			f.copyAndReplaceDefaultScalarListExpr(t.Elems, replace),
			t.Typ,
		)

	case *memo.IndirectionExpr:
		return f.ConstructIndirection(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Index, replace).(opt.ScalarExpr),
		)

	case *memo.ArrayFlattenExpr:
		return f.ConstructArrayFlatten(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.SubqueryPrivate,
		)

	case *memo.FunctionExpr:
		return f.ConstructFunction(
			f.copyAndReplaceDefaultScalarListExpr(t.Args, replace),
			&t.FunctionPrivate,
		)

	case *memo.CollateExpr:
		return f.ConstructCollate(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			t.Locale,
		)

	case *memo.CoalesceExpr:
		return f.ConstructCoalesce(
			f.copyAndReplaceDefaultScalarListExpr(t.Args, replace),
		)

	case *memo.ColumnAccessExpr:
		return f.ConstructColumnAccess(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			t.Idx,
		)

	case *memo.ArrayAggExpr:
		return f.ConstructArrayAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.AvgExpr:
		return f.ConstructAvg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.BitAndAggExpr:
		return f.ConstructBitAndAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.BitOrAggExpr:
		return f.ConstructBitOrAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.BoolAndExpr:
		return f.ConstructBoolAnd(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.BoolOrExpr:
		return f.ConstructBoolOr(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.ConcatAggExpr:
		return f.ConstructConcatAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.CorrExpr:
		return f.ConstructCorr(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.CountExpr:
		return f.ConstructCount(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.CountRowsExpr:
		return t

	case *memo.CovarPopExpr:
		return f.ConstructCovarPop(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.CovarSampExpr:
		return f.ConstructCovarSamp(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.RegressionAvgXExpr:
		return f.ConstructRegressionAvgX(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.RegressionAvgYExpr:
		return f.ConstructRegressionAvgY(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.RegressionInterceptExpr:
		return f.ConstructRegressionIntercept(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.RegressionR2Expr:
		return f.ConstructRegressionR2(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.RegressionSlopeExpr:
		return f.ConstructRegressionSlope(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.RegressionSXXExpr:
		return f.ConstructRegressionSXX(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.RegressionSXYExpr:
		return f.ConstructRegressionSXY(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.RegressionSYYExpr:
		return f.ConstructRegressionSYY(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.RegressionCountExpr:
		return f.ConstructRegressionCount(
			f.invokeReplace(t.Y, replace).(opt.ScalarExpr),
			f.invokeReplace(t.X, replace).(opt.ScalarExpr),
		)

	case *memo.MaxExpr:
		return f.ConstructMax(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.MinExpr:
		return f.ConstructMin(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.SumIntExpr:
		return f.ConstructSumInt(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.SumExpr:
		return f.ConstructSum(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.SqrDiffExpr:
		return f.ConstructSqrDiff(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.VarianceExpr:
		return f.ConstructVariance(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.VarPopExpr:
		return f.ConstructVarPop(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.StdDevExpr:
		return f.ConstructStdDev(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.StdDevPopExpr:
		return f.ConstructStdDevPop(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.STMakeLineExpr:
		return f.ConstructSTMakeLine(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.STExtentExpr:
		return f.ConstructSTExtent(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.STUnionExpr:
		return f.ConstructSTUnion(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.STCollectExpr:
		return f.ConstructSTCollect(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.XorAggExpr:
		return f.ConstructXorAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.JsonAggExpr:
		return f.ConstructJsonAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.JsonbAggExpr:
		return f.ConstructJsonbAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.JsonObjectAggExpr:
		return f.ConstructJsonObjectAgg(
			f.invokeReplace(t.Key, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Value, replace).(opt.ScalarExpr),
		)

	case *memo.JsonbObjectAggExpr:
		return f.ConstructJsonbObjectAgg(
			f.invokeReplace(t.Key, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Value, replace).(opt.ScalarExpr),
		)

	case *memo.StringAggExpr:
		return f.ConstructStringAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Sep, replace).(opt.ScalarExpr),
		)

	case *memo.ConstAggExpr:
		return f.ConstructConstAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.ConstNotNullAggExpr:
		return f.ConstructConstNotNullAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.AnyNotNullAggExpr:
		return f.ConstructAnyNotNullAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.FirstAggExpr:
		return f.ConstructFirstAgg(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.PercentileDiscExpr:
		return f.ConstructPercentileDisc(
			f.invokeReplace(t.Fraction, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.PercentileContExpr:
		return f.ConstructPercentileCont(
			f.invokeReplace(t.Fraction, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.AggDistinctExpr:
		return f.ConstructAggDistinct(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
		)

	case *memo.AggFilterExpr:
		return f.ConstructAggFilter(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Filter, replace).(opt.ScalarExpr),
		)

	case *memo.WindowFromOffsetExpr:
		return f.ConstructWindowFromOffset(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Offset, replace).(opt.ScalarExpr),
		)

	case *memo.WindowToOffsetExpr:
		return f.ConstructWindowToOffset(
			f.invokeReplace(t.Input, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Offset, replace).(opt.ScalarExpr),
		)

	case *memo.RankExpr:
		return t

	case *memo.RowNumberExpr:
		return t

	case *memo.DenseRankExpr:
		return t

	case *memo.PercentRankExpr:
		return t

	case *memo.CumeDistExpr:
		return t

	case *memo.NtileExpr:
		return f.ConstructNtile(
			f.invokeReplace(t.NumBuckets, replace).(opt.ScalarExpr),
		)

	case *memo.LagExpr:
		return f.ConstructLag(
			f.invokeReplace(t.Value, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Offset, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Def, replace).(opt.ScalarExpr),
		)

	case *memo.LeadExpr:
		return f.ConstructLead(
			f.invokeReplace(t.Value, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Offset, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Def, replace).(opt.ScalarExpr),
		)

	case *memo.FirstValueExpr:
		return f.ConstructFirstValue(
			f.invokeReplace(t.Value, replace).(opt.ScalarExpr),
		)

	case *memo.LastValueExpr:
		return f.ConstructLastValue(
			f.invokeReplace(t.Value, replace).(opt.ScalarExpr),
		)

	case *memo.NthValueExpr:
		return f.ConstructNthValue(
			f.invokeReplace(t.Value, replace).(opt.ScalarExpr),
			f.invokeReplace(t.Nth, replace).(opt.ScalarExpr),
		)

	case *memo.UDFExpr:
		return f.ConstructUDF(
			f.copyAndReplaceDefaultScalarListExpr(t.Input, replace),
			&t.UDFPrivate,
		)

	case *memo.CreateTableExpr:
		return f.ConstructCreateTable(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.CreateTablePrivate,
		)

	case *memo.CreateViewExpr:
		return f.mem.MemoizeCreateView(&t.CreateViewPrivate)

	case *memo.CreateFunctionExpr:
		return f.mem.MemoizeCreateFunction(&t.CreateFunctionPrivate)

	case *memo.ExplainExpr:
		return f.ConstructExplain(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.ExplainPrivate,
		)

	case *memo.ShowTraceForSessionExpr:
		return f.mem.MemoizeShowTraceForSession(&t.ShowTracePrivate)

	case *memo.OpaqueRelExpr:
		return f.mem.MemoizeOpaqueRel(&t.OpaqueRelPrivate)

	case *memo.OpaqueMutationExpr:
		return f.mem.MemoizeOpaqueMutation(&t.OpaqueRelPrivate)

	case *memo.OpaqueDDLExpr:
		return f.mem.MemoizeOpaqueDDL(&t.OpaqueRelPrivate)

	case *memo.AlterTableSplitExpr:
		return f.ConstructAlterTableSplit(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.invokeReplace(t.Expiration, replace).(opt.ScalarExpr),
			&t.AlterTableSplitPrivate,
		)

	case *memo.AlterTableUnsplitExpr:
		return f.ConstructAlterTableUnsplit(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.AlterTableSplitPrivate,
		)

	case *memo.AlterTableUnsplitAllExpr:
		return f.mem.MemoizeAlterTableUnsplitAll(&t.AlterTableSplitPrivate)

	case *memo.AlterTableRelocateExpr:
		return f.ConstructAlterTableRelocate(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.AlterTableRelocatePrivate,
		)

	case *memo.ControlJobsExpr:
		return f.ConstructControlJobs(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.invokeReplace(t.Reason, replace).(opt.ScalarExpr),
			&t.ControlJobsPrivate,
		)

	case *memo.ControlSchedulesExpr:
		return f.ConstructControlSchedules(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.ControlSchedulesPrivate,
		)

	case *memo.CancelQueriesExpr:
		return f.ConstructCancelQueries(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.CancelPrivate,
		)

	case *memo.CancelSessionsExpr:
		return f.ConstructCancelSessions(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			&t.CancelPrivate,
		)

	case *memo.ExportExpr:
		return f.ConstructExport(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.invokeReplace(t.FileName, replace).(opt.ScalarExpr),
			f.copyAndReplaceDefaultKVOptionsExpr(t.Options, replace),
			&t.ExportPrivate,
		)

	case *memo.CreateStatisticsExpr:
		return f.mem.MemoizeCreateStatistics(&t.CreateStatisticsPrivate)

	case *memo.AlterRangeRelocateExpr:
		return f.ConstructAlterRangeRelocate(
			f.invokeReplace(t.Input, replace).(memo.RelExpr),
			f.invokeReplace(t.ToStoreID, replace).(opt.ScalarExpr),
			f.invokeReplace(t.FromStoreID, replace).(opt.ScalarExpr),
			&t.AlterRangeRelocatePrivate,
		)

	case *memo.FKChecksExpr:
		newVal := f.copyAndReplaceDefaultFKChecksExpr(*t, replace)
		return &newVal

	case *memo.UniqueChecksExpr:
		newVal := f.copyAndReplaceDefaultUniqueChecksExpr(*t, replace)
		return &newVal

	case *memo.ProjectionsExpr:
		newVal := f.copyAndReplaceDefaultProjectionsExpr(*t, replace)
		return &newVal

	case *memo.AggregationsExpr:
		newVal := f.copyAndReplaceDefaultAggregationsExpr(*t, replace)
		return &newVal

	case *memo.FiltersExpr:
		newVal := f.copyAndReplaceDefaultFiltersExpr(*t, replace)
		return &newVal

	case *memo.ZipExpr:
		newVal := f.copyAndReplaceDefaultZipExpr(*t, replace)
		return &newVal

	case *memo.WindowsExpr:
		newVal := f.copyAndReplaceDefaultWindowsExpr(*t, replace)
		return &newVal

	case *memo.KVOptionsExpr:
		newVal := f.copyAndReplaceDefaultKVOptionsExpr(*t, replace)
		return &newVal

	case *memo.ScalarListExpr:
		newVal := f.copyAndReplaceDefaultScalarListExpr(*t, replace)
		return &newVal

	default:
		panic(errors.AssertionFailedf("unhandled op %s", errors.Safe(src.Op())))
	}
}

func (f *Factory) copyAndReplaceDefaultFKChecksExpr(src memo.FKChecksExpr, replace ReplaceFunc) (dst memo.FKChecksExpr) {
	dst = make(memo.FKChecksExpr, len(src))
	for i := range src {
		dst[i].Check = f.invokeReplace(src[i].Check, replace).(memo.RelExpr)
		dst[i].OriginTable = src[i].OriginTable
		dst[i].ReferencedTable = src[i].ReferencedTable
		dst[i].FKOutbound = src[i].FKOutbound
		dst[i].FKOrdinal = src[i].FKOrdinal
		dst[i].KeyCols = src[i].KeyCols
		dst[i].OpName = src[i].OpName
		f.mem.CheckExpr(&dst[i])
	}
	return dst
}

func (f *Factory) copyAndReplaceDefaultUniqueChecksExpr(src memo.UniqueChecksExpr, replace ReplaceFunc) (dst memo.UniqueChecksExpr) {
	dst = make(memo.UniqueChecksExpr, len(src))
	for i := range src {
		dst[i].Check = f.invokeReplace(src[i].Check, replace).(memo.RelExpr)
		dst[i].Table = src[i].Table
		dst[i].CheckOrdinal = src[i].CheckOrdinal
		dst[i].KeyCols = src[i].KeyCols
		dst[i].OpName = src[i].OpName
		f.mem.CheckExpr(&dst[i])
	}
	return dst
}

func (f *Factory) copyAndReplaceDefaultProjectionsExpr(src memo.ProjectionsExpr, replace ReplaceFunc) (dst memo.ProjectionsExpr) {
	dst = make(memo.ProjectionsExpr, len(src))
	for i := range src {
		dst[i].Element = f.invokeReplace(src[i].Element, replace).(opt.ScalarExpr)
		dst[i].Col = src[i].Col
		dst[i].PopulateProps(f.mem)
		f.mem.CheckExpr(&dst[i])
	}
	return dst
}

func (f *Factory) copyAndReplaceDefaultAggregationsExpr(src memo.AggregationsExpr, replace ReplaceFunc) (dst memo.AggregationsExpr) {
	dst = make(memo.AggregationsExpr, len(src))
	for i := range src {
		dst[i].Agg = f.invokeReplace(src[i].Agg, replace).(opt.ScalarExpr)
		dst[i].Col = src[i].Col
		dst[i].PopulateProps(f.mem)
		f.mem.CheckExpr(&dst[i])
	}
	return dst
}

func (f *Factory) copyAndReplaceDefaultFiltersExpr(src memo.FiltersExpr, replace ReplaceFunc) (dst memo.FiltersExpr) {
	dst = make(memo.FiltersExpr, len(src))
	for i := range src {
		dst[i].Condition = f.invokeReplace(src[i].Condition, replace).(opt.ScalarExpr)
		dst[i].PopulateProps(f.mem)
		f.mem.CheckExpr(&dst[i])
	}
	return dst
}

func (f *Factory) copyAndReplaceDefaultZipExpr(src memo.ZipExpr, replace ReplaceFunc) (dst memo.ZipExpr) {
	dst = make(memo.ZipExpr, len(src))
	for i := range src {
		dst[i].Fn = f.invokeReplace(src[i].Fn, replace).(opt.ScalarExpr)
		dst[i].Cols = src[i].Cols
		dst[i].PopulateProps(f.mem)
		f.mem.CheckExpr(&dst[i])
	}
	return dst
}

func (f *Factory) copyAndReplaceDefaultWindowsExpr(src memo.WindowsExpr, replace ReplaceFunc) (dst memo.WindowsExpr) {
	dst = make(memo.WindowsExpr, len(src))
	for i := range src {
		dst[i].Function = f.invokeReplace(src[i].Function, replace).(opt.ScalarExpr)
		dst[i].Frame = src[i].Frame
		dst[i].Col = src[i].Col
		dst[i].PopulateProps(f.mem)
		f.mem.CheckExpr(&dst[i])
	}
	return dst
}

func (f *Factory) copyAndReplaceDefaultKVOptionsExpr(src memo.KVOptionsExpr, replace ReplaceFunc) (dst memo.KVOptionsExpr) {
	dst = make(memo.KVOptionsExpr, len(src))
	for i := range src {
		dst[i].Value = f.invokeReplace(src[i].Value, replace).(opt.ScalarExpr)
		dst[i].Key = src[i].Key
		f.mem.CheckExpr(&dst[i])
	}
	return dst
}

func (f *Factory) copyAndReplaceDefaultScalarListExpr(src memo.ScalarListExpr, replace ReplaceFunc) (dst memo.ScalarListExpr) {
	dst = make(memo.ScalarListExpr, len(src))
	for i := range src {
		dst[i] = f.invokeReplace(src[i], replace).(opt.ScalarExpr)
	}
	return dst
}

// invokeReplace wraps the user-provided replace function. See comments for
// CopyAndReplace for more details.
func (f *Factory) invokeReplace(src opt.Expr, replace ReplaceFunc) (dst opt.Expr) {
	if rel, ok := src.(memo.RelExpr); ok {
		src = rel.FirstExpr()
	}
	return replace(src)
}

func (f *Factory) DynamicConstruct(op opt.Operator, args ...interface{}) opt.Expr {
	switch op {
	case opt.NormCycleTestRelOp:
		return f.ConstructNormCycleTestRel(
			args[0].(opt.ScalarExpr),
		)
	case opt.MemoCycleTestRelOp:
		return f.ConstructMemoCycleTestRel(
			args[0].(memo.RelExpr),
			*args[1].(*memo.FiltersExpr),
		)
	case opt.InsertOp:
		return f.ConstructInsert(
			args[0].(memo.RelExpr),
			*args[1].(*memo.UniqueChecksExpr),
			*args[2].(*memo.FKChecksExpr),
			args[3].(*memo.MutationPrivate),
		)
	case opt.UpdateOp:
		return f.ConstructUpdate(
			args[0].(memo.RelExpr),
			*args[1].(*memo.UniqueChecksExpr),
			*args[2].(*memo.FKChecksExpr),
			args[3].(*memo.MutationPrivate),
		)
	case opt.UpsertOp:
		return f.ConstructUpsert(
			args[0].(memo.RelExpr),
			*args[1].(*memo.UniqueChecksExpr),
			*args[2].(*memo.FKChecksExpr),
			args[3].(*memo.MutationPrivate),
		)
	case opt.DeleteOp:
		return f.ConstructDelete(
			args[0].(memo.RelExpr),
			*args[1].(*memo.UniqueChecksExpr),
			*args[2].(*memo.FKChecksExpr),
			args[3].(*memo.MutationPrivate),
		)
	case opt.ScanOp:
		return f.ConstructScan(
			args[0].(*memo.ScanPrivate),
		)
	case opt.PlaceholderScanOp:
		return f.ConstructPlaceholderScan(
			*args[0].(*memo.ScalarListExpr),
			args[1].(*memo.ScanPrivate),
		)
	case opt.SequenceSelectOp:
		return f.ConstructSequenceSelect(
			args[0].(*memo.SequenceSelectPrivate),
		)
	case opt.ValuesOp:
		return f.ConstructValues(
			*args[0].(*memo.ScalarListExpr),
			args[1].(*memo.ValuesPrivate),
		)
	case opt.LiteralValuesOp:
		return f.ConstructLiteralValues(
			args[0].(*opt.LiteralRows),
			*args[1].(*opt.ColList),
		)
	case opt.SelectOp:
		return f.ConstructSelect(
			args[0].(memo.RelExpr),
			*args[1].(*memo.FiltersExpr),
		)
	case opt.ProjectOp:
		return f.ConstructProject(
			args[0].(memo.RelExpr),
			*args[1].(*memo.ProjectionsExpr),
			*args[2].(*opt.ColSet),
		)
	case opt.InvertedFilterOp:
		return f.ConstructInvertedFilter(
			args[0].(memo.RelExpr),
			args[1].(*memo.InvertedFilterPrivate),
		)
	case opt.InnerJoinOp:
		return f.ConstructInnerJoin(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.LeftJoinOp:
		return f.ConstructLeftJoin(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.RightJoinOp:
		return f.ConstructRightJoin(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.FullJoinOp:
		return f.ConstructFullJoin(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.SemiJoinOp:
		return f.ConstructSemiJoin(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.AntiJoinOp:
		return f.ConstructAntiJoin(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.IndexJoinOp:
		return f.ConstructIndexJoin(
			args[0].(memo.RelExpr),
			args[1].(*memo.IndexJoinPrivate),
		)
	case opt.LookupJoinOp:
		return f.ConstructLookupJoin(
			args[0].(memo.RelExpr),
			*args[1].(*memo.FiltersExpr),
			args[2].(*memo.LookupJoinPrivate),
		)
	case opt.InvertedJoinOp:
		return f.ConstructInvertedJoin(
			args[0].(memo.RelExpr),
			*args[1].(*memo.FiltersExpr),
			args[2].(*memo.InvertedJoinPrivate),
		)
	case opt.MergeJoinOp:
		return f.ConstructMergeJoin(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.MergeJoinPrivate),
		)
	case opt.ZigzagJoinOp:
		return f.ConstructZigzagJoin(
			*args[0].(*memo.FiltersExpr),
			args[1].(*memo.ZigzagJoinPrivate),
		)
	case opt.InnerJoinApplyOp:
		return f.ConstructInnerJoinApply(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.LeftJoinApplyOp:
		return f.ConstructLeftJoinApply(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.SemiJoinApplyOp:
		return f.ConstructSemiJoinApply(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.AntiJoinApplyOp:
		return f.ConstructAntiJoinApply(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			*args[2].(*memo.FiltersExpr),
			args[3].(*memo.JoinPrivate),
		)
	case opt.GroupByOp:
		return f.ConstructGroupBy(
			args[0].(memo.RelExpr),
			*args[1].(*memo.AggregationsExpr),
			args[2].(*memo.GroupingPrivate),
		)
	case opt.ScalarGroupByOp:
		return f.ConstructScalarGroupBy(
			args[0].(memo.RelExpr),
			*args[1].(*memo.AggregationsExpr),
			args[2].(*memo.GroupingPrivate),
		)
	case opt.DistinctOnOp:
		return f.ConstructDistinctOn(
			args[0].(memo.RelExpr),
			*args[1].(*memo.AggregationsExpr),
			args[2].(*memo.GroupingPrivate),
		)
	case opt.EnsureDistinctOnOp:
		return f.ConstructEnsureDistinctOn(
			args[0].(memo.RelExpr),
			*args[1].(*memo.AggregationsExpr),
			args[2].(*memo.GroupingPrivate),
		)
	case opt.UpsertDistinctOnOp:
		return f.ConstructUpsertDistinctOn(
			args[0].(memo.RelExpr),
			*args[1].(*memo.AggregationsExpr),
			args[2].(*memo.GroupingPrivate),
		)
	case opt.EnsureUpsertDistinctOnOp:
		return f.ConstructEnsureUpsertDistinctOn(
			args[0].(memo.RelExpr),
			*args[1].(*memo.AggregationsExpr),
			args[2].(*memo.GroupingPrivate),
		)
	case opt.UnionOp:
		return f.ConstructUnion(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			args[2].(*memo.SetPrivate),
		)
	case opt.IntersectOp:
		return f.ConstructIntersect(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			args[2].(*memo.SetPrivate),
		)
	case opt.ExceptOp:
		return f.ConstructExcept(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			args[2].(*memo.SetPrivate),
		)
	case opt.UnionAllOp:
		return f.ConstructUnionAll(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			args[2].(*memo.SetPrivate),
		)
	case opt.IntersectAllOp:
		return f.ConstructIntersectAll(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			args[2].(*memo.SetPrivate),
		)
	case opt.ExceptAllOp:
		return f.ConstructExceptAll(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			args[2].(*memo.SetPrivate),
		)
	case opt.LocalityOptimizedSearchOp:
		return f.ConstructLocalityOptimizedSearch(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			args[2].(*memo.SetPrivate),
		)
	case opt.LimitOp:
		return f.ConstructLimit(
			args[0].(memo.RelExpr),
			args[1].(opt.ScalarExpr),
			*args[2].(*props.OrderingChoice),
		)
	case opt.OffsetOp:
		return f.ConstructOffset(
			args[0].(memo.RelExpr),
			args[1].(opt.ScalarExpr),
			*args[2].(*props.OrderingChoice),
		)
	case opt.TopKOp:
		return f.ConstructTopK(
			args[0].(memo.RelExpr),
			args[1].(*memo.TopKPrivate),
		)
	case opt.Max1RowOp:
		return f.ConstructMax1Row(
			args[0].(memo.RelExpr),
			*args[1].(*string),
		)
	case opt.OrdinalityOp:
		return f.ConstructOrdinality(
			args[0].(memo.RelExpr),
			args[1].(*memo.OrdinalityPrivate),
		)
	case opt.ProjectSetOp:
		return f.ConstructProjectSet(
			args[0].(memo.RelExpr),
			*args[1].(*memo.ZipExpr),
		)
	case opt.WindowOp:
		return f.ConstructWindow(
			args[0].(memo.RelExpr),
			*args[1].(*memo.WindowsExpr),
			args[2].(*memo.WindowPrivate),
		)
	case opt.WithOp:
		return f.ConstructWith(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			args[2].(*memo.WithPrivate),
		)
	case opt.WithScanOp:
		return f.ConstructWithScan(
			args[0].(*memo.WithScanPrivate),
		)
	case opt.RecursiveCTEOp:
		return f.ConstructRecursiveCTE(
			args[0].(memo.RelExpr),
			args[1].(memo.RelExpr),
			args[2].(memo.RelExpr),
			args[3].(*memo.RecursiveCTEPrivate),
		)
	case opt.FakeRelOp:
		return f.ConstructFakeRel(
			args[0].(*memo.FakeRelPrivate),
		)
	case opt.SubqueryOp:
		return f.ConstructSubquery(
			args[0].(memo.RelExpr),
			args[1].(*memo.SubqueryPrivate),
		)
	case opt.AnyOp:
		return f.ConstructAny(
			args[0].(memo.RelExpr),
			args[1].(opt.ScalarExpr),
			args[2].(*memo.SubqueryPrivate),
		)
	case opt.ExistsOp:
		return f.ConstructExists(
			args[0].(memo.RelExpr),
			args[1].(*memo.SubqueryPrivate),
		)
	case opt.VariableOp:
		return f.ConstructVariable(
			*args[0].(*opt.ColumnID),
		)
	case opt.ConstOp:
		return f.ConstructConst(
			args[0].(tree.Datum),
			args[1].(*types.T),
		)
	case opt.NullOp:
		return f.ConstructNull(
			args[0].(*types.T),
		)
	case opt.TrueOp:
		return f.ConstructTrue()
	case opt.FalseOp:
		return f.ConstructFalse()
	case opt.PlaceholderOp:
		return f.ConstructPlaceholder(
			args[0].(tree.TypedExpr),
		)
	case opt.TupleOp:
		return f.ConstructTuple(
			*args[0].(*memo.ScalarListExpr),
			args[1].(*types.T),
		)
	case opt.AndOp:
		return f.ConstructAnd(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.OrOp:
		return f.ConstructOr(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RangeOp:
		return f.ConstructRange(
			args[0].(opt.ScalarExpr),
		)
	case opt.NotOp:
		return f.ConstructNot(
			args[0].(opt.ScalarExpr),
		)
	case opt.IsTupleNullOp:
		return f.ConstructIsTupleNull(
			args[0].(opt.ScalarExpr),
		)
	case opt.IsTupleNotNullOp:
		return f.ConstructIsTupleNotNull(
			args[0].(opt.ScalarExpr),
		)
	case opt.EqOp:
		return f.ConstructEq(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.LtOp:
		return f.ConstructLt(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.GtOp:
		return f.ConstructGt(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.LeOp:
		return f.ConstructLe(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.GeOp:
		return f.ConstructGe(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.NeOp:
		return f.ConstructNe(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.InOp:
		return f.ConstructIn(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.NotInOp:
		return f.ConstructNotIn(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.LikeOp:
		return f.ConstructLike(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.NotLikeOp:
		return f.ConstructNotLike(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.ILikeOp:
		return f.ConstructILike(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.NotILikeOp:
		return f.ConstructNotILike(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.SimilarToOp:
		return f.ConstructSimilarTo(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.NotSimilarToOp:
		return f.ConstructNotSimilarTo(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegMatchOp:
		return f.ConstructRegMatch(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.NotRegMatchOp:
		return f.ConstructNotRegMatch(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegIMatchOp:
		return f.ConstructRegIMatch(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.NotRegIMatchOp:
		return f.ConstructNotRegIMatch(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.IsOp:
		return f.ConstructIs(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.IsNotOp:
		return f.ConstructIsNot(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.ContainsOp:
		return f.ConstructContains(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.ContainedByOp:
		return f.ConstructContainedBy(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.JsonExistsOp:
		return f.ConstructJsonExists(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.JsonAllExistsOp:
		return f.ConstructJsonAllExists(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.JsonSomeExistsOp:
		return f.ConstructJsonSomeExists(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.OverlapsOp:
		return f.ConstructOverlaps(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.BBoxCoversOp:
		return f.ConstructBBoxCovers(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.BBoxIntersectsOp:
		return f.ConstructBBoxIntersects(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.AnyScalarOp:
		return f.ConstructAnyScalar(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
			*args[2].(*opt.Operator),
		)
	case opt.BitandOp:
		return f.ConstructBitand(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.BitorOp:
		return f.ConstructBitor(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.BitxorOp:
		return f.ConstructBitxor(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.PlusOp:
		return f.ConstructPlus(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.MinusOp:
		return f.ConstructMinus(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.MultOp:
		return f.ConstructMult(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.DivOp:
		return f.ConstructDiv(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.FloorDivOp:
		return f.ConstructFloorDiv(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.ModOp:
		return f.ConstructMod(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.PowOp:
		return f.ConstructPow(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.ConcatOp:
		return f.ConstructConcat(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.LShiftOp:
		return f.ConstructLShift(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RShiftOp:
		return f.ConstructRShift(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.FetchValOp:
		return f.ConstructFetchVal(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.FetchTextOp:
		return f.ConstructFetchText(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.FetchValPathOp:
		return f.ConstructFetchValPath(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.FetchTextPathOp:
		return f.ConstructFetchTextPath(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.UnaryMinusOp:
		return f.ConstructUnaryMinus(
			args[0].(opt.ScalarExpr),
		)
	case opt.UnaryPlusOp:
		return f.ConstructUnaryPlus(
			args[0].(opt.ScalarExpr),
		)
	case opt.UnaryComplementOp:
		return f.ConstructUnaryComplement(
			args[0].(opt.ScalarExpr),
		)
	case opt.UnarySqrtOp:
		return f.ConstructUnarySqrt(
			args[0].(opt.ScalarExpr),
		)
	case opt.UnaryCbrtOp:
		return f.ConstructUnaryCbrt(
			args[0].(opt.ScalarExpr),
		)
	case opt.CastOp:
		return f.ConstructCast(
			args[0].(opt.ScalarExpr),
			args[1].(*types.T),
		)
	case opt.AssignmentCastOp:
		return f.ConstructAssignmentCast(
			args[0].(opt.ScalarExpr),
			args[1].(*types.T),
		)
	case opt.IfErrOp:
		return f.ConstructIfErr(
			args[0].(opt.ScalarExpr),
			*args[1].(*memo.ScalarListExpr),
			*args[2].(*memo.ScalarListExpr),
		)
	case opt.CaseOp:
		return f.ConstructCase(
			args[0].(opt.ScalarExpr),
			*args[1].(*memo.ScalarListExpr),
			args[2].(opt.ScalarExpr),
		)
	case opt.WhenOp:
		return f.ConstructWhen(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.ArrayOp:
		return f.ConstructArray(
			*args[0].(*memo.ScalarListExpr),
			args[1].(*types.T),
		)
	case opt.IndirectionOp:
		return f.ConstructIndirection(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.ArrayFlattenOp:
		return f.ConstructArrayFlatten(
			args[0].(memo.RelExpr),
			args[1].(*memo.SubqueryPrivate),
		)
	case opt.FunctionOp:
		return f.ConstructFunction(
			*args[0].(*memo.ScalarListExpr),
			args[1].(*memo.FunctionPrivate),
		)
	case opt.CollateOp:
		return f.ConstructCollate(
			args[0].(opt.ScalarExpr),
			*args[1].(*string),
		)
	case opt.CoalesceOp:
		return f.ConstructCoalesce(
			*args[0].(*memo.ScalarListExpr),
		)
	case opt.ColumnAccessOp:
		return f.ConstructColumnAccess(
			args[0].(opt.ScalarExpr),
			*args[1].(*memo.TupleOrdinal),
		)
	case opt.ArrayAggOp:
		return f.ConstructArrayAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.AvgOp:
		return f.ConstructAvg(
			args[0].(opt.ScalarExpr),
		)
	case opt.BitAndAggOp:
		return f.ConstructBitAndAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.BitOrAggOp:
		return f.ConstructBitOrAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.BoolAndOp:
		return f.ConstructBoolAnd(
			args[0].(opt.ScalarExpr),
		)
	case opt.BoolOrOp:
		return f.ConstructBoolOr(
			args[0].(opt.ScalarExpr),
		)
	case opt.ConcatAggOp:
		return f.ConstructConcatAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.CorrOp:
		return f.ConstructCorr(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.CountOp:
		return f.ConstructCount(
			args[0].(opt.ScalarExpr),
		)
	case opt.CountRowsOp:
		return f.ConstructCountRows()
	case opt.CovarPopOp:
		return f.ConstructCovarPop(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.CovarSampOp:
		return f.ConstructCovarSamp(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegressionAvgXOp:
		return f.ConstructRegressionAvgX(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegressionAvgYOp:
		return f.ConstructRegressionAvgY(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegressionInterceptOp:
		return f.ConstructRegressionIntercept(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegressionR2Op:
		return f.ConstructRegressionR2(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegressionSlopeOp:
		return f.ConstructRegressionSlope(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegressionSXXOp:
		return f.ConstructRegressionSXX(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegressionSXYOp:
		return f.ConstructRegressionSXY(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegressionSYYOp:
		return f.ConstructRegressionSYY(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RegressionCountOp:
		return f.ConstructRegressionCount(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.MaxOp:
		return f.ConstructMax(
			args[0].(opt.ScalarExpr),
		)
	case opt.MinOp:
		return f.ConstructMin(
			args[0].(opt.ScalarExpr),
		)
	case opt.SumIntOp:
		return f.ConstructSumInt(
			args[0].(opt.ScalarExpr),
		)
	case opt.SumOp:
		return f.ConstructSum(
			args[0].(opt.ScalarExpr),
		)
	case opt.SqrDiffOp:
		return f.ConstructSqrDiff(
			args[0].(opt.ScalarExpr),
		)
	case opt.VarianceOp:
		return f.ConstructVariance(
			args[0].(opt.ScalarExpr),
		)
	case opt.VarPopOp:
		return f.ConstructVarPop(
			args[0].(opt.ScalarExpr),
		)
	case opt.StdDevOp:
		return f.ConstructStdDev(
			args[0].(opt.ScalarExpr),
		)
	case opt.StdDevPopOp:
		return f.ConstructStdDevPop(
			args[0].(opt.ScalarExpr),
		)
	case opt.STMakeLineOp:
		return f.ConstructSTMakeLine(
			args[0].(opt.ScalarExpr),
		)
	case opt.STExtentOp:
		return f.ConstructSTExtent(
			args[0].(opt.ScalarExpr),
		)
	case opt.STUnionOp:
		return f.ConstructSTUnion(
			args[0].(opt.ScalarExpr),
		)
	case opt.STCollectOp:
		return f.ConstructSTCollect(
			args[0].(opt.ScalarExpr),
		)
	case opt.XorAggOp:
		return f.ConstructXorAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.JsonAggOp:
		return f.ConstructJsonAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.JsonbAggOp:
		return f.ConstructJsonbAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.JsonObjectAggOp:
		return f.ConstructJsonObjectAgg(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.JsonbObjectAggOp:
		return f.ConstructJsonbObjectAgg(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.StringAggOp:
		return f.ConstructStringAgg(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.ConstAggOp:
		return f.ConstructConstAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.ConstNotNullAggOp:
		return f.ConstructConstNotNullAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.AnyNotNullAggOp:
		return f.ConstructAnyNotNullAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.FirstAggOp:
		return f.ConstructFirstAgg(
			args[0].(opt.ScalarExpr),
		)
	case opt.PercentileDiscOp:
		return f.ConstructPercentileDisc(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.PercentileContOp:
		return f.ConstructPercentileCont(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.AggDistinctOp:
		return f.ConstructAggDistinct(
			args[0].(opt.ScalarExpr),
		)
	case opt.AggFilterOp:
		return f.ConstructAggFilter(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.WindowFromOffsetOp:
		return f.ConstructWindowFromOffset(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.WindowToOffsetOp:
		return f.ConstructWindowToOffset(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.RankOp:
		return f.ConstructRank()
	case opt.RowNumberOp:
		return f.ConstructRowNumber()
	case opt.DenseRankOp:
		return f.ConstructDenseRank()
	case opt.PercentRankOp:
		return f.ConstructPercentRank()
	case opt.CumeDistOp:
		return f.ConstructCumeDist()
	case opt.NtileOp:
		return f.ConstructNtile(
			args[0].(opt.ScalarExpr),
		)
	case opt.LagOp:
		return f.ConstructLag(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
			args[2].(opt.ScalarExpr),
		)
	case opt.LeadOp:
		return f.ConstructLead(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
			args[2].(opt.ScalarExpr),
		)
	case opt.FirstValueOp:
		return f.ConstructFirstValue(
			args[0].(opt.ScalarExpr),
		)
	case opt.LastValueOp:
		return f.ConstructLastValue(
			args[0].(opt.ScalarExpr),
		)
	case opt.NthValueOp:
		return f.ConstructNthValue(
			args[0].(opt.ScalarExpr),
			args[1].(opt.ScalarExpr),
		)
	case opt.UDFOp:
		return f.ConstructUDF(
			*args[0].(*memo.ScalarListExpr),
			args[1].(*memo.UDFPrivate),
		)
	case opt.CreateTableOp:
		return f.ConstructCreateTable(
			args[0].(memo.RelExpr),
			args[1].(*memo.CreateTablePrivate),
		)
	case opt.CreateViewOp:
		return f.ConstructCreateView(
			args[0].(*memo.CreateViewPrivate),
		)
	case opt.CreateFunctionOp:
		return f.ConstructCreateFunction(
			args[0].(*memo.CreateFunctionPrivate),
		)
	case opt.ExplainOp:
		return f.ConstructExplain(
			args[0].(memo.RelExpr),
			args[1].(*memo.ExplainPrivate),
		)
	case opt.ShowTraceForSessionOp:
		return f.ConstructShowTraceForSession(
			args[0].(*memo.ShowTracePrivate),
		)
	case opt.OpaqueRelOp:
		return f.ConstructOpaqueRel(
			args[0].(*memo.OpaqueRelPrivate),
		)
	case opt.OpaqueMutationOp:
		return f.ConstructOpaqueMutation(
			args[0].(*memo.OpaqueRelPrivate),
		)
	case opt.OpaqueDDLOp:
		return f.ConstructOpaqueDDL(
			args[0].(*memo.OpaqueRelPrivate),
		)
	case opt.AlterTableSplitOp:
		return f.ConstructAlterTableSplit(
			args[0].(memo.RelExpr),
			args[1].(opt.ScalarExpr),
			args[2].(*memo.AlterTableSplitPrivate),
		)
	case opt.AlterTableUnsplitOp:
		return f.ConstructAlterTableUnsplit(
			args[0].(memo.RelExpr),
			args[1].(*memo.AlterTableSplitPrivate),
		)
	case opt.AlterTableUnsplitAllOp:
		return f.ConstructAlterTableUnsplitAll(
			args[0].(*memo.AlterTableSplitPrivate),
		)
	case opt.AlterTableRelocateOp:
		return f.ConstructAlterTableRelocate(
			args[0].(memo.RelExpr),
			args[1].(*memo.AlterTableRelocatePrivate),
		)
	case opt.ControlJobsOp:
		return f.ConstructControlJobs(
			args[0].(memo.RelExpr),
			args[1].(opt.ScalarExpr),
			args[2].(*memo.ControlJobsPrivate),
		)
	case opt.ControlSchedulesOp:
		return f.ConstructControlSchedules(
			args[0].(memo.RelExpr),
			args[1].(*memo.ControlSchedulesPrivate),
		)
	case opt.CancelQueriesOp:
		return f.ConstructCancelQueries(
			args[0].(memo.RelExpr),
			args[1].(*memo.CancelPrivate),
		)
	case opt.CancelSessionsOp:
		return f.ConstructCancelSessions(
			args[0].(memo.RelExpr),
			args[1].(*memo.CancelPrivate),
		)
	case opt.ExportOp:
		return f.ConstructExport(
			args[0].(memo.RelExpr),
			args[1].(opt.ScalarExpr),
			*args[2].(*memo.KVOptionsExpr),
			args[3].(*memo.ExportPrivate),
		)
	case opt.CreateStatisticsOp:
		return f.ConstructCreateStatistics(
			args[0].(*memo.CreateStatisticsPrivate),
		)
	case opt.AlterRangeRelocateOp:
		return f.ConstructAlterRangeRelocate(
			args[0].(memo.RelExpr),
			args[1].(opt.ScalarExpr),
			args[2].(opt.ScalarExpr),
			args[3].(*memo.AlterRangeRelocatePrivate),
		)
	}
	panic(errors.AssertionFailedf("cannot dynamically construct operator %s", errors.Safe(op)))
}
