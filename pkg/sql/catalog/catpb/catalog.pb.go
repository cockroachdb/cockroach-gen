// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/catalog/catpb/catalog.proto

package catpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ForeignKeyAction describes the action which should be taken when a foreign
// key constraint reference is acted upon.
type ForeignKeyAction int32

const (
	ForeignKeyAction_NO_ACTION   ForeignKeyAction = 0
	ForeignKeyAction_RESTRICT    ForeignKeyAction = 1
	ForeignKeyAction_SET_NULL    ForeignKeyAction = 2
	ForeignKeyAction_SET_DEFAULT ForeignKeyAction = 3
	ForeignKeyAction_CASCADE     ForeignKeyAction = 4
)

var ForeignKeyAction_name = map[int32]string{
	0: "NO_ACTION",
	1: "RESTRICT",
	2: "SET_NULL",
	3: "SET_DEFAULT",
	4: "CASCADE",
}

var ForeignKeyAction_value = map[string]int32{
	"NO_ACTION":   0,
	"RESTRICT":    1,
	"SET_NULL":    2,
	"SET_DEFAULT": 3,
	"CASCADE":     4,
}

func (x ForeignKeyAction) Enum() *ForeignKeyAction {
	p := new(ForeignKeyAction)
	*p = x
	return p
}

func (x ForeignKeyAction) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ForeignKeyAction_name, int32(x))
}

func (x *ForeignKeyAction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ForeignKeyAction_value, data, "ForeignKeyAction")
	if err != nil {
		return err
	}
	*x = ForeignKeyAction(value)
	return nil
}

func (ForeignKeyAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0}
}

// SystemColumnKind is an enum representing the different kind of system
// columns that can be synthesized by the execution engine.
type SystemColumnKind int32

const (
	// Default value, unused.
	SystemColumnKind_NONE SystemColumnKind = 0
	// A system column containing the value of the MVCC timestamp associated
	// with the kv's corresponding to the row.
	SystemColumnKind_MVCCTIMESTAMP SystemColumnKind = 1
	// A system column containing the OID of the table that the row came from.
	SystemColumnKind_TABLEOID SystemColumnKind = 2
)

var SystemColumnKind_name = map[int32]string{
	0: "NONE",
	1: "MVCCTIMESTAMP",
	2: "TABLEOID",
}

var SystemColumnKind_value = map[string]int32{
	"NONE":          0,
	"MVCCTIMESTAMP": 1,
	"TABLEOID":      2,
}

func (x SystemColumnKind) Enum() *SystemColumnKind {
	p := new(SystemColumnKind)
	*p = x
	return p
}

func (x SystemColumnKind) String() string {
	return proto.EnumName(SystemColumnKind_name, int32(x))
}

func (x *SystemColumnKind) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SystemColumnKind_value, data, "SystemColumnKind")
	if err != nil {
		return err
	}
	*x = SystemColumnKind(value)
	return nil
}

func (SystemColumnKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{1}
}

// GeneratedAsIdentityType is an enum representing how the creation of
// a column is associated with the GENERATED {ALWAYS | BY DEFAULT} AS IDENTITY
// syntax.
type GeneratedAsIdentityType int32

const (
	// A column created without `GENERATED ... AS IDENTITY` syntax.
	GeneratedAsIdentityType_NOT_IDENTITY_COLUMN GeneratedAsIdentityType = 0
	// A column created with `GENERATED ALWAYS AS IDENTITY` syntax.
	// Such a column does not allow override without `OVERRIDING SYSTEM VALUE`
	// syntax.
	GeneratedAsIdentityType_GENERATED_ALWAYS GeneratedAsIdentityType = 1
	// A column created with `GENERATED BY DEFAULT AS IDENTITY` syntax.
	// Such a column can be overridden without `OVERRIDING SYSTEM VALUE` syntax.
	GeneratedAsIdentityType_GENERATED_BY_DEFAULT GeneratedAsIdentityType = 2
)

var GeneratedAsIdentityType_name = map[int32]string{
	0: "NOT_IDENTITY_COLUMN",
	1: "GENERATED_ALWAYS",
	2: "GENERATED_BY_DEFAULT",
}

var GeneratedAsIdentityType_value = map[string]int32{
	"NOT_IDENTITY_COLUMN":  0,
	"GENERATED_ALWAYS":     1,
	"GENERATED_BY_DEFAULT": 2,
}

func (x GeneratedAsIdentityType) Enum() *GeneratedAsIdentityType {
	p := new(GeneratedAsIdentityType)
	*p = x
	return p
}

func (x GeneratedAsIdentityType) String() string {
	return proto.EnumName(GeneratedAsIdentityType_name, int32(x))
}

func (x *GeneratedAsIdentityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GeneratedAsIdentityType_value, data, "GeneratedAsIdentityType")
	if err != nil {
		return err
	}
	*x = GeneratedAsIdentityType(value)
	return nil
}

func (GeneratedAsIdentityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{2}
}

// LocalityConfig is used to figure the locality of a table.
type LocalityConfig struct {
	// Types that are valid to be assigned to Locality:
	//	*LocalityConfig_Global_
	//	*LocalityConfig_RegionalByTable_
	//	*LocalityConfig_RegionalByRow_
	Locality isLocalityConfig_Locality `protobuf_oneof:"locality"`
}

func (m *LocalityConfig) Reset()         { *m = LocalityConfig{} }
func (m *LocalityConfig) String() string { return proto.CompactTextString(m) }
func (*LocalityConfig) ProtoMessage()    {}
func (*LocalityConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0}
}
func (m *LocalityConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalityConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalityConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalityConfig.Merge(m, src)
}
func (m *LocalityConfig) XXX_Size() int {
	return m.Size()
}
func (m *LocalityConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalityConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LocalityConfig proto.InternalMessageInfo

type isLocalityConfig_Locality interface {
	isLocalityConfig_Locality()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalityConfig_Global_ struct {
	Global *LocalityConfig_Global `protobuf:"bytes,1,opt,name=global,oneof" json:"global,omitempty"`
}
type LocalityConfig_RegionalByTable_ struct {
	RegionalByTable *LocalityConfig_RegionalByTable `protobuf:"bytes,2,opt,name=regional_by_table,json=regionalByTable,oneof" json:"regional_by_table,omitempty"`
}
type LocalityConfig_RegionalByRow_ struct {
	RegionalByRow *LocalityConfig_RegionalByRow `protobuf:"bytes,3,opt,name=regional_by_row,json=regionalByRow,oneof" json:"regional_by_row,omitempty"`
}

func (*LocalityConfig_Global_) isLocalityConfig_Locality()          {}
func (*LocalityConfig_RegionalByTable_) isLocalityConfig_Locality() {}
func (*LocalityConfig_RegionalByRow_) isLocalityConfig_Locality()   {}

func (m *LocalityConfig) GetLocality() isLocalityConfig_Locality {
	if m != nil {
		return m.Locality
	}
	return nil
}

func (m *LocalityConfig) GetGlobal() *LocalityConfig_Global {
	if x, ok := m.GetLocality().(*LocalityConfig_Global_); ok {
		return x.Global
	}
	return nil
}

func (m *LocalityConfig) GetRegionalByTable() *LocalityConfig_RegionalByTable {
	if x, ok := m.GetLocality().(*LocalityConfig_RegionalByTable_); ok {
		return x.RegionalByTable
	}
	return nil
}

func (m *LocalityConfig) GetRegionalByRow() *LocalityConfig_RegionalByRow {
	if x, ok := m.GetLocality().(*LocalityConfig_RegionalByRow_); ok {
		return x.RegionalByRow
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LocalityConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LocalityConfig_Global_)(nil),
		(*LocalityConfig_RegionalByTable_)(nil),
		(*LocalityConfig_RegionalByRow_)(nil),
	}
}

// REGIONAL BY TABLE tables have an "implicit" bidirectional dependency with
// the multi-region enum. The dependency is described "implicit" because
// even though no column on the table uses the multi-region type descriptor
// to store the homing region, a value from the type descriptor is stored in
// the locality config below (when the table is homed in the non-primary
// region).
// This changes how type dependencies are constructed for table descriptors.
// After the introduction of REGIONAL BY TABLE tables, a column on the table
// descriptor using a type is no longer a necessary (note it is still a
// sufficient) condition to establish a type dependency. As is the case with
// adding and dropping columns, this type dependency must be negotiated. As
// such, switching locality patterns or adding new locality configs must be
// done so that back references to the multi-region type descriptor are
// kept sane.
type LocalityConfig_RegionalByTable struct {
	// Region is set if the table has an affinity with a non-primary region.
	Region *RegionName `protobuf:"bytes,1,opt,name=region,casttype=RegionName" json:"region,omitempty"`
}

func (m *LocalityConfig_RegionalByTable) Reset()         { *m = LocalityConfig_RegionalByTable{} }
func (m *LocalityConfig_RegionalByTable) String() string { return proto.CompactTextString(m) }
func (*LocalityConfig_RegionalByTable) ProtoMessage()    {}
func (*LocalityConfig_RegionalByTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0, 0}
}
func (m *LocalityConfig_RegionalByTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalityConfig_RegionalByTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalityConfig_RegionalByTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalityConfig_RegionalByTable.Merge(m, src)
}
func (m *LocalityConfig_RegionalByTable) XXX_Size() int {
	return m.Size()
}
func (m *LocalityConfig_RegionalByTable) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalityConfig_RegionalByTable.DiscardUnknown(m)
}

var xxx_messageInfo_LocalityConfig_RegionalByTable proto.InternalMessageInfo

type LocalityConfig_RegionalByRow struct {
	// As is set if the table has a REGIONAL BY ROW AS ... set to a specific column.
	As *string `protobuf:"bytes,1,opt,name=as" json:"as,omitempty"`
}

func (m *LocalityConfig_RegionalByRow) Reset()         { *m = LocalityConfig_RegionalByRow{} }
func (m *LocalityConfig_RegionalByRow) String() string { return proto.CompactTextString(m) }
func (*LocalityConfig_RegionalByRow) ProtoMessage()    {}
func (*LocalityConfig_RegionalByRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0, 1}
}
func (m *LocalityConfig_RegionalByRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalityConfig_RegionalByRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalityConfig_RegionalByRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalityConfig_RegionalByRow.Merge(m, src)
}
func (m *LocalityConfig_RegionalByRow) XXX_Size() int {
	return m.Size()
}
func (m *LocalityConfig_RegionalByRow) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalityConfig_RegionalByRow.DiscardUnknown(m)
}

var xxx_messageInfo_LocalityConfig_RegionalByRow proto.InternalMessageInfo

type LocalityConfig_Global struct {
}

func (m *LocalityConfig_Global) Reset()         { *m = LocalityConfig_Global{} }
func (m *LocalityConfig_Global) String() string { return proto.CompactTextString(m) }
func (*LocalityConfig_Global) ProtoMessage()    {}
func (*LocalityConfig_Global) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0, 2}
}
func (m *LocalityConfig_Global) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalityConfig_Global) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalityConfig_Global) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalityConfig_Global.Merge(m, src)
}
func (m *LocalityConfig_Global) XXX_Size() int {
	return m.Size()
}
func (m *LocalityConfig_Global) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalityConfig_Global.DiscardUnknown(m)
}

var xxx_messageInfo_LocalityConfig_Global proto.InternalMessageInfo

// ShardedDescriptor represents an index (either primary or secondary) that is hash
// sharded into a user-specified number of buckets.
//
// As as example, sample field values for the following table:
//
// CREATE TABLE abc (
//   a INT PRIMARY KEY USING HASH WITH BUCKET_COUNT=10,  // column id: 1
//   b BYTES
// );
//
// Sharded descriptor:
//   name:          "a_shard"
//   shard_buckets: 10
//   column_names:  ["a"]
type ShardedDescriptor struct {
	// IsSharded indicates whether the index in question is a sharded one.
	IsSharded bool `protobuf:"varint,1,opt,name=is_sharded,json=isSharded" json:"is_sharded"`
	// Name is the name of the shard column.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name"`
	// ShardBuckets indicates the number of shards this index is divided into.
	ShardBuckets int32 `protobuf:"varint,3,opt,name=shard_buckets,json=shardBuckets" json:"shard_buckets"`
	// ColumnNames lists the names of the columns used to compute the shard column's
	// values.
	ColumnNames []string `protobuf:"bytes,4,rep,name=column_names,json=columnNames" json:"column_names,omitempty"`
}

func (m *ShardedDescriptor) Reset()         { *m = ShardedDescriptor{} }
func (m *ShardedDescriptor) String() string { return proto.CompactTextString(m) }
func (*ShardedDescriptor) ProtoMessage()    {}
func (*ShardedDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{1}
}
func (m *ShardedDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardedDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ShardedDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardedDescriptor.Merge(m, src)
}
func (m *ShardedDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ShardedDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardedDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ShardedDescriptor proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.catalog.catpb.ForeignKeyAction", ForeignKeyAction_name, ForeignKeyAction_value)
	proto.RegisterEnum("cockroach.sql.catalog.catpb.SystemColumnKind", SystemColumnKind_name, SystemColumnKind_value)
	proto.RegisterEnum("cockroach.sql.catalog.catpb.GeneratedAsIdentityType", GeneratedAsIdentityType_name, GeneratedAsIdentityType_value)
	proto.RegisterType((*LocalityConfig)(nil), "cockroach.sql.catalog.catpb.LocalityConfig")
	proto.RegisterType((*LocalityConfig_RegionalByTable)(nil), "cockroach.sql.catalog.catpb.LocalityConfig.RegionalByTable")
	proto.RegisterType((*LocalityConfig_RegionalByRow)(nil), "cockroach.sql.catalog.catpb.LocalityConfig.RegionalByRow")
	proto.RegisterType((*LocalityConfig_Global)(nil), "cockroach.sql.catalog.catpb.LocalityConfig.Global")
	proto.RegisterType((*ShardedDescriptor)(nil), "cockroach.sql.catalog.catpb.ShardedDescriptor")
}

func init() { proto.RegisterFile("sql/catalog/catpb/catalog.proto", fileDescriptor_98c5e4146b266e21) }

var fileDescriptor_98c5e4146b266e21 = []byte{
	// 636 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x52, 0xcd, 0x6e, 0xd3, 0x4a,
	0x14, 0xb6, 0x93, 0xb4, 0x37, 0x39, 0xf9, 0x73, 0xe7, 0x46, 0x6a, 0x94, 0x2b, 0x39, 0xbd, 0x45,
	0x40, 0xd5, 0x45, 0x2a, 0x75, 0x57, 0x10, 0x42, 0xb6, 0xe3, 0xb6, 0x56, 0x1d, 0x07, 0xd9, 0x53,
	0x50, 0xd9, 0x58, 0x13, 0x67, 0x70, 0xad, 0x3a, 0x9e, 0xd4, 0x76, 0x55, 0xf9, 0x2d, 0x78, 0x04,
	0x16, 0x2c, 0x78, 0x02, 0xc4, 0x23, 0x74, 0xd9, 0x65, 0x57, 0x15, 0xa4, 0x1b, 0x9e, 0x81, 0x15,
	0xf2, 0x4f, 0xa1, 0x65, 0x81, 0x04, 0x1b, 0xdb, 0xe7, 0x3b, 0xdf, 0xcf, 0xf1, 0x99, 0x81, 0x7e,
	0x74, 0xea, 0x6f, 0x39, 0x24, 0x26, 0x3e, 0x73, 0xd3, 0xf7, 0x7c, 0x72, 0x5b, 0x0d, 0xe6, 0x21,
	0x8b, 0x19, 0xfa, 0xcf, 0x61, 0xce, 0x49, 0xc8, 0x88, 0x73, 0x3c, 0x88, 0x4e, 0xfd, 0xc1, 0x6d,
	0x33, 0xa3, 0xf6, 0x3a, 0x2e, 0x73, 0x59, 0xc6, 0xdb, 0x4a, 0xbf, 0x72, 0xc9, 0xfa, 0xa7, 0x32,
	0xb4, 0x74, 0xe6, 0x10, 0xdf, 0x8b, 0x13, 0x85, 0x05, 0x6f, 0x3c, 0x17, 0xe9, 0xb0, 0xec, 0xfa,
	0x6c, 0x42, 0xfc, 0x2e, 0xbf, 0xc6, 0x6f, 0xd4, 0xb7, 0xb7, 0x07, 0xbf, 0xb1, 0x1d, 0xdc, 0x17,
	0x0f, 0xf6, 0x32, 0xe5, 0x3e, 0x67, 0x16, 0x1e, 0xc8, 0x83, 0x95, 0x90, 0xba, 0x1e, 0x0b, 0x88,
	0x6f, 0x4f, 0x12, 0x3b, 0x26, 0x13, 0x9f, 0x76, 0x4b, 0x99, 0xf1, 0xd3, 0x3f, 0x31, 0x36, 0x0b,
	0x13, 0x39, 0xc1, 0xa9, 0xc5, 0x3e, 0x67, 0xb6, 0xc3, 0xfb, 0x10, 0x72, 0xa0, 0x7d, 0x37, 0x2a,
	0x64, 0xe7, 0xdd, 0x72, 0x16, 0xb4, 0xf3, 0x77, 0x41, 0x26, 0x3b, 0xdf, 0xe7, 0xcc, 0x66, 0x78,
	0x17, 0xe8, 0x3d, 0x87, 0xf6, 0x2f, 0xa3, 0xa0, 0x47, 0xb0, 0x9c, 0x73, 0xb2, 0x85, 0xd5, 0xe4,
	0xd6, 0xb7, 0xeb, 0x3e, 0xe4, 0x24, 0x83, 0xcc, 0xa8, 0x59, 0x74, 0x9f, 0x54, 0xbe, 0xbe, 0xeb,
	0xf3, 0xbd, 0x87, 0xd0, 0xbc, 0x17, 0x81, 0x5a, 0x50, 0x22, 0x51, 0x2e, 0x35, 0x4b, 0x24, 0x2a,
	0x68, 0x2d, 0x58, 0xce, 0x77, 0x99, 0xd7, 0xf9, 0x53, 0x06, 0xa8, 0xfa, 0xc5, 0xb8, 0xeb, 0x1f,
	0x79, 0x58, 0xb1, 0x8e, 0x49, 0x38, 0xa5, 0xd3, 0x21, 0x8d, 0x9c, 0xd0, 0x9b, 0xc7, 0x2c, 0x44,
	0x0f, 0x00, 0xbc, 0xc8, 0x8e, 0x72, 0x3c, 0x73, 0xad, 0xca, 0x95, 0x8b, 0xeb, 0x3e, 0x67, 0xd6,
	0xbc, 0xa8, 0xa0, 0xa3, 0x2e, 0x54, 0x02, 0x32, 0xcb, 0xcf, 0xa1, 0x56, 0xb4, 0x33, 0x04, 0xed,
	0x40, 0x33, 0xd3, 0xda, 0x93, 0x33, 0xe7, 0x84, 0xc6, 0x51, 0xb6, 0xc1, 0x25, 0xb9, 0x93, 0x52,
	0x16, 0xd7, 0xfd, 0x46, 0xe6, 0x20, 0xe7, 0x3d, 0xb3, 0x11, 0xdd, 0xa9, 0xd0, 0xff, 0xd0, 0x70,
	0x98, 0x7f, 0x36, 0x0b, 0xec, 0xd4, 0x29, 0xea, 0x56, 0xd6, 0xca, 0x1b, 0x35, 0xb3, 0x9e, 0x63,
	0xe9, 0x22, 0x8a, 0x5f, 0xdb, 0x24, 0x20, 0xec, 0xb2, 0x90, 0x7a, 0x6e, 0x70, 0x40, 0x13, 0xc9,
	0x89, 0x3d, 0x16, 0xa0, 0x26, 0xd4, 0x8c, 0xb1, 0x2d, 0x29, 0x58, 0x1b, 0x1b, 0x02, 0x87, 0x1a,
	0x50, 0x35, 0x55, 0x0b, 0x9b, 0x9a, 0x82, 0x05, 0x3e, 0xad, 0x2c, 0x15, 0xdb, 0xc6, 0xa1, 0xae,
	0x0b, 0x25, 0xd4, 0x86, 0x7a, 0x5a, 0x0d, 0xd5, 0x5d, 0xe9, 0x50, 0xc7, 0x42, 0x19, 0xd5, 0xe1,
	0x1f, 0x45, 0xb2, 0x14, 0x69, 0xa8, 0x0a, 0x95, 0x5e, 0xe5, 0xc3, 0x7b, 0x91, 0xdb, 0x7c, 0x06,
	0x82, 0x95, 0x44, 0x31, 0x9d, 0x29, 0x59, 0xfa, 0x81, 0x17, 0x4c, 0x51, 0x15, 0x2a, 0xc6, 0xd8,
	0x50, 0x05, 0x0e, 0xad, 0x40, 0x73, 0xf4, 0x52, 0x51, 0xb0, 0x36, 0x52, 0x2d, 0x2c, 0x8d, 0x5e,
	0xe4, 0x11, 0x58, 0x92, 0x75, 0x75, 0xac, 0x0d, 0x85, 0xd2, 0xe6, 0x04, 0x56, 0xf7, 0x68, 0x40,
	0x43, 0x12, 0xd3, 0xa9, 0x14, 0x69, 0x53, 0x1a, 0xc4, 0x5e, 0x9c, 0xe0, 0x64, 0x4e, 0xd1, 0x2a,
	0xfc, 0x6b, 0x8c, 0xb1, 0xad, 0x0d, 0x55, 0x03, 0x6b, 0xf8, 0xc8, 0x56, 0xc6, 0xfa, 0xe1, 0x28,
	0x1d, 0xb9, 0x03, 0xc2, 0x9e, 0x6a, 0xa8, 0xa6, 0x84, 0xd5, 0xa1, 0x2d, 0xe9, 0xaf, 0xa4, 0x23,
	0x4b, 0xe0, 0x51, 0x17, 0x3a, 0x3f, 0x51, 0xf9, 0xe8, 0xc7, 0xd4, 0x25, 0xf9, 0xf1, 0xc5, 0x17,
	0x91, 0xbb, 0x58, 0x88, 0xfc, 0xe5, 0x42, 0xe4, 0xaf, 0x16, 0x22, 0xff, 0x79, 0x21, 0xf2, 0x6f,
	0x6f, 0x44, 0xee, 0xf2, 0x46, 0xe4, 0xae, 0x6e, 0x44, 0xee, 0xf5, 0x52, 0x76, 0x3f, 0xbf, 0x07,
	0x00, 0x00, 0xff, 0xff, 0x1a, 0x5d, 0x22, 0x20, 0xf7, 0x03, 0x00, 0x00,
}

func (this *LocalityConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig)
	if !ok {
		that2, ok := that.(LocalityConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Locality == nil {
		if this.Locality != nil {
			return false
		}
	} else if this.Locality == nil {
		return false
	} else if !this.Locality.Equal(that1.Locality) {
		return false
	}
	return true
}
func (this *LocalityConfig_Global_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_Global_)
	if !ok {
		that2, ok := that.(LocalityConfig_Global_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Global.Equal(that1.Global) {
		return false
	}
	return true
}
func (this *LocalityConfig_RegionalByTable_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_RegionalByTable_)
	if !ok {
		that2, ok := that.(LocalityConfig_RegionalByTable_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RegionalByTable.Equal(that1.RegionalByTable) {
		return false
	}
	return true
}
func (this *LocalityConfig_RegionalByRow_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_RegionalByRow_)
	if !ok {
		that2, ok := that.(LocalityConfig_RegionalByRow_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RegionalByRow.Equal(that1.RegionalByRow) {
		return false
	}
	return true
}
func (this *LocalityConfig_RegionalByTable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_RegionalByTable)
	if !ok {
		that2, ok := that.(LocalityConfig_RegionalByTable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region != nil && that1.Region != nil {
		if *this.Region != *that1.Region {
			return false
		}
	} else if this.Region != nil {
		return false
	} else if that1.Region != nil {
		return false
	}
	return true
}
func (this *LocalityConfig_RegionalByRow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_RegionalByRow)
	if !ok {
		that2, ok := that.(LocalityConfig_RegionalByRow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.As != nil && that1.As != nil {
		if *this.As != *that1.As {
			return false
		}
	} else if this.As != nil {
		return false
	} else if that1.As != nil {
		return false
	}
	return true
}
func (this *LocalityConfig_Global) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_Global)
	if !ok {
		that2, ok := that.(LocalityConfig_Global)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ShardedDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShardedDescriptor)
	if !ok {
		that2, ok := that.(ShardedDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsSharded != that1.IsSharded {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ShardBuckets != that1.ShardBuckets {
		return false
	}
	if len(this.ColumnNames) != len(that1.ColumnNames) {
		return false
	}
	for i := range this.ColumnNames {
		if this.ColumnNames[i] != that1.ColumnNames[i] {
			return false
		}
	}
	return true
}
func (m *LocalityConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalityConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Locality != nil {
		{
			size := m.Locality.Size()
			i -= size
			if _, err := m.Locality.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalityConfig_Global_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_Global_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Global != nil {
		{
			size, err := m.Global.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCatalog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LocalityConfig_RegionalByTable_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_RegionalByTable_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegionalByTable != nil {
		{
			size, err := m.RegionalByTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCatalog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LocalityConfig_RegionalByRow_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_RegionalByRow_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegionalByRow != nil {
		{
			size, err := m.RegionalByRow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCatalog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LocalityConfig_RegionalByTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalityConfig_RegionalByTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_RegionalByTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Region != nil {
		i -= len(*m.Region)
		copy(dAtA[i:], *m.Region)
		i = encodeVarintCatalog(dAtA, i, uint64(len(*m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalityConfig_RegionalByRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalityConfig_RegionalByRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_RegionalByRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.As != nil {
		i -= len(*m.As)
		copy(dAtA[i:], *m.As)
		i = encodeVarintCatalog(dAtA, i, uint64(len(*m.As)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalityConfig_Global) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalityConfig_Global) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_Global) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ShardedDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardedDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardedDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnNames) > 0 {
		for iNdEx := len(m.ColumnNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColumnNames[iNdEx])
			copy(dAtA[i:], m.ColumnNames[iNdEx])
			i = encodeVarintCatalog(dAtA, i, uint64(len(m.ColumnNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	i = encodeVarintCatalog(dAtA, i, uint64(m.ShardBuckets))
	i--
	dAtA[i] = 0x18
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i--
	if m.IsSharded {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintCatalog(dAtA []byte, offset int, v uint64) int {
	offset -= sovCatalog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LocalityConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Locality != nil {
		n += m.Locality.Size()
	}
	return n
}

func (m *LocalityConfig_Global_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}
func (m *LocalityConfig_RegionalByTable_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionalByTable != nil {
		l = m.RegionalByTable.Size()
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}
func (m *LocalityConfig_RegionalByRow_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionalByRow != nil {
		l = m.RegionalByRow.Size()
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}
func (m *LocalityConfig_RegionalByTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Region != nil {
		l = len(*m.Region)
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}

func (m *LocalityConfig_RegionalByRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.As != nil {
		l = len(*m.As)
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}

func (m *LocalityConfig_Global) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ShardedDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	l = len(m.Name)
	n += 1 + l + sovCatalog(uint64(l))
	n += 1 + sovCatalog(uint64(m.ShardBuckets))
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovCatalog(uint64(l))
		}
	}
	return n
}

func sovCatalog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCatalog(x uint64) (n int) {
	return sovCatalog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LocalityConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalityConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalityConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalityConfig_Global{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Locality = &LocalityConfig_Global_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionalByTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalityConfig_RegionalByTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Locality = &LocalityConfig_RegionalByTable_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionalByRow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalityConfig_RegionalByRow{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Locality = &LocalityConfig_RegionalByRow_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalityConfig_RegionalByTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionalByTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionalByTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := RegionName(dAtA[iNdEx:postIndex])
			m.Region = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalityConfig_RegionalByRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionalByRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionalByRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.As = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalityConfig_Global) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Global: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Global: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardedDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardedDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardedDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSharded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSharded = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardBuckets", wireType)
			}
			m.ShardBuckets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardBuckets |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCatalog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCatalog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCatalog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCatalog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCatalog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCatalog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCatalog = fmt.Errorf("proto: unexpected end of group")
)
