// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/catalog/fetchpb/index_fetch.proto

package fetchpb

import (
	fmt "fmt"
	geoindex "github.com/cockroachdb/cockroach/pkg/geo/geoindex"
	catenumpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catenumpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_catenumpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catenumpb"
	github_com_cockroachdb_cockroach_pkg_sql_sem_catid "github.com/cockroachdb/cockroach/pkg/sql/sem/catid"
	types "github.com/cockroachdb/cockroach/pkg/sql/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IndexFetchSpec contains the subset of information (from TableDescriptor and
// IndexDescriptor) that is necessary to decode KVs into SQL keys and values.
type IndexFetchSpec struct {
	// Version is used to allow providing backward compatibility if this spec
	// changes. The intention is that one day this proto will be passed to KV scan
	// requests, in which case the DistSQL versioning will not suffice.
	Version          uint32                                                     `protobuf:"varint,1,opt,name=version" json:"version"`
	TableID          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,2,opt,name=table_id,json=tableId,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id"`
	TableName        string                                                     `protobuf:"bytes,3,opt,name=table_name,json=tableName" json:"table_name"`
	IndexID          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,4,opt,name=index_id,json=indexId,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id"`
	IndexName        string                                                     `protobuf:"bytes,5,opt,name=index_name,json=indexName" json:"index_name"`
	IsSecondaryIndex bool                                                       `protobuf:"varint,6,opt,name=is_secondary_index,json=isSecondaryIndex" json:"is_secondary_index"`
	IsUniqueIndex    bool                                                       `protobuf:"varint,7,opt,name=is_unique_index,json=isUniqueIndex" json:"is_unique_index"`
	// GeoConfig is used if we are fetching an inverted geospatial index.
	GeoConfig geoindex.Config `protobuf:"bytes,16,opt,name=geo_config,json=geoConfig" json:"geo_config"`
	// EncodingType represents what sort of k/v encoding is used to store the
	// table data.
	EncodingType github_com_cockroachdb_cockroach_pkg_sql_catalog_catenumpb.IndexDescriptorEncodingType `protobuf:"varint,8,opt,name=encoding_type,json=encodingType,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catenumpb.IndexDescriptorEncodingType" json:"encoding_type"`
	// NumKeySuffixColumns is the number of suffix columns (corresponding to a
	// suffix of KeyAndSuffixColumns).
	//
	// If the index is not unique, the suffix columns are always part of the key.
	//
	// If the index is unique, the suffix columns are encoded (using key encoding)
	// into the KV value. If one of the indexed columns is NULL, the key will
	// also contain the suffix column values.
	NumKeySuffixColumns uint32 `protobuf:"varint,9,opt,name=num_key_suffix_columns,json=numKeySuffixColumns" json:"num_key_suffix_columns"`
	// MaxKeysPerRow is the maximum number of keys per row in this index. It is
	// used for various optimizations.
	MaxKeysPerRow uint32 `protobuf:"varint,10,opt,name=max_keys_per_row,json=maxKeysPerRow" json:"max_keys_per_row"`
	// KeyPrefixLength is the length of the key prefix that encodes the table and
	// index ID.
	KeyPrefixLength uint32                                                      `protobuf:"varint,11,opt,name=key_prefix_length,json=keyPrefixLength" json:"key_prefix_length"`
	MaxFamilyID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID `protobuf:"varint,12,opt,name=max_family_id,json=maxFamilyId,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.FamilyID" json:"max_family_id"`
	// FamilyDefaultColumns contains the default column IDs for families with a
	// default column. This is used to decode values that use the single column
	// optimization (where the column ID is omitted).
	FamilyDefaultColumns []IndexFetchSpec_FamilyDefaultColumn `protobuf:"bytes,13,rep,name=family_default_columns,json=familyDefaultColumns" json:"family_default_columns"`
	// KeyAndSuffixColumns contains all the key and suffix columns, in order.
	KeyAndSuffixColumns []IndexFetchSpec_KeyColumn `protobuf:"bytes,14,rep,name=key_and_suffix_columns,json=keyAndSuffixColumns" json:"key_and_suffix_columns"`
	// FetchedColumns contains all the columns we are producing values for. The
	// fetched columns can overlap with the key columns.
	//
	// Any other column IDs present in the fetched KVs will be ignored.
	FetchedColumns []IndexFetchSpec_Column `protobuf:"bytes,15,rep,name=fetched_columns,json=fetchedColumns" json:"fetched_columns"`
}

func (m *IndexFetchSpec) Reset()         { *m = IndexFetchSpec{} }
func (m *IndexFetchSpec) String() string { return proto.CompactTextString(m) }
func (*IndexFetchSpec) ProtoMessage()    {}
func (*IndexFetchSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d6104253acc708e, []int{0}
}
func (m *IndexFetchSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexFetchSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexFetchSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexFetchSpec.Merge(m, src)
}
func (m *IndexFetchSpec) XXX_Size() int {
	return m.Size()
}
func (m *IndexFetchSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexFetchSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IndexFetchSpec proto.InternalMessageInfo

type IndexFetchSpec_Column struct {
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,1,opt,name=column_id,json=columnId,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id"`
	// Name of the column, as it is expected to appear in debug and error
	// messages.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name"`
	// Type of the column. If this is the key column of an inverted index, this
	// is the type of the data element (currently always EncodedKey) and not
	// the table column type (e.g. JSON).
	Type *types.T `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	// IsNonNullable indicates that it would be a corruption error if we ever
	// encounter a NULL value for this column (i.e. the column is non-nullable
	// and not a mutation column).
	IsNonNullable bool `protobuf:"varint,4,opt,name=is_non_nullable,json=isNonNullable" json:"is_non_nullable"`
}

func (m *IndexFetchSpec_Column) Reset()         { *m = IndexFetchSpec_Column{} }
func (m *IndexFetchSpec_Column) String() string { return proto.CompactTextString(m) }
func (*IndexFetchSpec_Column) ProtoMessage()    {}
func (*IndexFetchSpec_Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d6104253acc708e, []int{0, 0}
}
func (m *IndexFetchSpec_Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexFetchSpec_Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexFetchSpec_Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexFetchSpec_Column.Merge(m, src)
}
func (m *IndexFetchSpec_Column) XXX_Size() int {
	return m.Size()
}
func (m *IndexFetchSpec_Column) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexFetchSpec_Column.DiscardUnknown(m)
}

var xxx_messageInfo_IndexFetchSpec_Column proto.InternalMessageInfo

// KeyColumn describes a column that is encoded using the key encoding.
type IndexFetchSpec_KeyColumn struct {
	IndexFetchSpec_Column `protobuf:"bytes,1,opt,name=column,embedded=column" json:"column"`
	Direction             catenumpb.IndexColumn_Direction `protobuf:"varint,2,opt,name=direction,enum=cockroach.sql.catalog.catpb.IndexColumn_Direction" json:"direction"`
	// IsComposite is true if this column can have a composite encoding (i.e. it
	// can appear in the value in addition to the key).
	IsComposite bool `protobuf:"varint,3,opt,name=is_composite,json=isComposite" json:"is_composite"`
	// IsInverted is true if this column is the inverted key of an inverted index.
	// In this case, the type of this column is the type of the data element
	// (currently always EncodedKey).
	IsInverted bool `protobuf:"varint,4,opt,name=is_inverted,json=isInverted" json:"is_inverted"`
}

func (m *IndexFetchSpec_KeyColumn) Reset()         { *m = IndexFetchSpec_KeyColumn{} }
func (m *IndexFetchSpec_KeyColumn) String() string { return proto.CompactTextString(m) }
func (*IndexFetchSpec_KeyColumn) ProtoMessage()    {}
func (*IndexFetchSpec_KeyColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d6104253acc708e, []int{0, 1}
}
func (m *IndexFetchSpec_KeyColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexFetchSpec_KeyColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexFetchSpec_KeyColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexFetchSpec_KeyColumn.Merge(m, src)
}
func (m *IndexFetchSpec_KeyColumn) XXX_Size() int {
	return m.Size()
}
func (m *IndexFetchSpec_KeyColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexFetchSpec_KeyColumn.DiscardUnknown(m)
}

var xxx_messageInfo_IndexFetchSpec_KeyColumn proto.InternalMessageInfo

// FamilyDefaultColumn specifies the default column ID for a given family ID.
type IndexFetchSpec_FamilyDefaultColumn struct {
	FamilyID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID `protobuf:"varint,1,opt,name=family_id,json=familyId,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.FamilyID" json:"family_id"`
	// DefaultColumnID is the implicit column ID when a single value is encoded
	// for the family. See ColumnFamilyDescriptor.DefaultColumnID.
	DefaultColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=default_column_id,json=defaultColumnId,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"default_column_id"`
}

func (m *IndexFetchSpec_FamilyDefaultColumn) Reset()         { *m = IndexFetchSpec_FamilyDefaultColumn{} }
func (m *IndexFetchSpec_FamilyDefaultColumn) String() string { return proto.CompactTextString(m) }
func (*IndexFetchSpec_FamilyDefaultColumn) ProtoMessage()    {}
func (*IndexFetchSpec_FamilyDefaultColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d6104253acc708e, []int{0, 2}
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexFetchSpec_FamilyDefaultColumn.Merge(m, src)
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_Size() int {
	return m.Size()
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexFetchSpec_FamilyDefaultColumn.DiscardUnknown(m)
}

var xxx_messageInfo_IndexFetchSpec_FamilyDefaultColumn proto.InternalMessageInfo

func init() {
	proto.RegisterType((*IndexFetchSpec)(nil), "cockroach.sql.sqlbase.IndexFetchSpec")
	proto.RegisterType((*IndexFetchSpec_Column)(nil), "cockroach.sql.sqlbase.IndexFetchSpec.Column")
	proto.RegisterType((*IndexFetchSpec_KeyColumn)(nil), "cockroach.sql.sqlbase.IndexFetchSpec.KeyColumn")
	proto.RegisterType((*IndexFetchSpec_FamilyDefaultColumn)(nil), "cockroach.sql.sqlbase.IndexFetchSpec.FamilyDefaultColumn")
}

func init() {
	proto.RegisterFile("sql/catalog/fetchpb/index_fetch.proto", fileDescriptor_2d6104253acc708e)
}

var fileDescriptor_2d6104253acc708e = []byte{
	// 941 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x53, 0xdb, 0xc6,
	0x17, 0x47, 0xc0, 0x17, 0xdb, 0x6b, 0xc0, 0x64, 0x49, 0x18, 0x7d, 0x7d, 0x10, 0xb4, 0x9d, 0x4c,
	0xdd, 0x99, 0x54, 0xea, 0xf8, 0x46, 0x7b, 0x6a, 0x70, 0x33, 0xe3, 0x21, 0xa1, 0x19, 0x41, 0x39,
	0xb4, 0x33, 0xd5, 0xc8, 0xd2, 0xb3, 0xbc, 0xb5, 0xb4, 0x2b, 0xb4, 0x12, 0xb1, 0xae, 0xcd, 0xa5,
	0xc7, 0xfe, 0x59, 0x1c, 0x39, 0xe6, 0xe4, 0x69, 0xcd, 0xbd, 0x7f, 0x40, 0x4e, 0x9d, 0xfd, 0x21,
	0x63, 0x93, 0x1c, 0x28, 0xed, 0x01, 0x90, 0xde, 0x7b, 0xfb, 0xf9, 0x7c, 0xf6, 0xfd, 0x12, 0xe8,
	0x29, 0xbf, 0x88, 0x9d, 0xc0, 0xcf, 0xfd, 0x98, 0x45, 0xce, 0x10, 0xf2, 0x60, 0x94, 0x0e, 0x1c,
	0x42, 0x43, 0x98, 0x78, 0xf2, 0xcd, 0x4e, 0x33, 0x96, 0x33, 0xfc, 0x24, 0x60, 0xc1, 0x38, 0x63,
	0x7e, 0x30, 0xb2, 0xf9, 0x45, 0x2c, 0x7e, 0x06, 0x3e, 0x87, 0xf6, 0xe3, 0x88, 0x45, 0x4c, 0x46,
	0x38, 0xe2, 0x49, 0x05, 0xb7, 0x9f, 0x08, 0xcc, 0xbc, 0x4c, 0x81, 0xab, 0xdf, 0xda, 0xfc, 0xc9,
	0x22, 0x55, 0xe0, 0xe7, 0x40, 0x8b, 0xa4, 0x22, 0xd3, 0x21, 0xff, 0x8f, 0x80, 0x39, 0x11, 0x30,
	0x69, 0x73, 0x02, 0x46, 0x87, 0x24, 0x52, 0xae, 0x4f, 0xaf, 0x5b, 0x68, 0xbb, 0x2f, 0xcc, 0x2f,
	0x84, 0xac, 0xd3, 0x14, 0x02, 0x6c, 0xa1, 0xda, 0x25, 0x64, 0x9c, 0x30, 0x6a, 0x1a, 0x07, 0x46,
	0x67, 0xeb, 0xf9, 0xfa, 0xd5, 0x74, 0x7f, 0xc5, 0xad, 0x8c, 0x38, 0x42, 0xf5, 0xdc, 0x1f, 0xc4,
	0xe0, 0x91, 0xd0, 0x5c, 0x95, 0x01, 0x2f, 0x45, 0xc0, 0x6c, 0xba, 0x5f, 0x3b, 0x13, 0xf6, 0x7e,
	0xef, 0xfd, 0x74, 0xff, 0x30, 0x22, 0xf9, 0xa8, 0x18, 0xd8, 0x01, 0x4b, 0x9c, 0xf9, 0x25, 0xc3,
	0xc1, 0xed, 0xb3, 0x93, 0x8e, 0x23, 0x47, 0x48, 0xe7, 0x90, 0x08, 0xd9, 0x24, 0xb4, 0x7b, 0xc0,
	0x83, 0x7e, 0xcf, 0xad, 0x49, 0xf4, 0x7e, 0x88, 0x3f, 0x43, 0x48, 0x11, 0x51, 0x3f, 0x01, 0x73,
	0xed, 0xc0, 0xe8, 0x34, 0xb4, 0x96, 0x86, 0xb4, 0x9f, 0xf8, 0x09, 0xe0, 0x11, 0xaa, 0xab, 0xbc,
	0x92, 0xd0, 0x5c, 0x97, 0x6a, 0x5e, 0x55, 0x6a, 0xe4, 0xbd, 0xa4, 0x9a, 0xaf, 0x1f, 0xa0, 0x46,
	0x9f, 0x76, 0x6b, 0x12, 0x5e, 0xc9, 0x51, 0x4c, 0x52, 0xce, 0xff, 0x16, 0xe5, 0x48, 0xbb, 0x94,
	0xd3, 0x45, 0x98, 0x70, 0x8f, 0x43, 0xc0, 0x68, 0xe8, 0x67, 0xa5, 0x27, 0x3d, 0xe6, 0xc6, 0x81,
	0xd1, 0xa9, 0xeb, 0xe0, 0x1d, 0xc2, 0x4f, 0x2b, 0xb7, 0xe4, 0xc0, 0xcf, 0x50, 0x8b, 0x70, 0xaf,
	0xa0, 0xe4, 0xa2, 0x00, 0x7d, 0xa0, 0xb6, 0x70, 0x60, 0x8b, 0xf0, 0x1f, 0xa4, 0x4f, 0x45, 0x1f,
	0x21, 0x14, 0x01, 0xf3, 0x54, 0x15, 0xcd, 0x9d, 0x03, 0xa3, 0xd3, 0xec, 0x5a, 0xf6, 0x6d, 0x23,
	0x45, 0xc0, 0xec, 0xaa, 0xd6, 0xf6, 0x91, 0x8c, 0xaa, 0x64, 0x46, 0xc0, 0x94, 0x01, 0xbf, 0x35,
	0xd0, 0x16, 0xd0, 0x80, 0x85, 0x84, 0x46, 0x9e, 0xe8, 0x26, 0xb3, 0x2e, 0x73, 0xf7, 0xb3, 0x08,
	0x7c, 0x3f, 0xdd, 0x3f, 0xbf, 0x77, 0xc2, 0x3e, 0xe8, 0x3c, 0x95, 0x38, 0x51, 0xcb, 0x8c, 0xa4,
	0x39, 0xcb, 0xbe, 0xd3, 0x34, 0x67, 0x65, 0x0a, 0xee, 0x26, 0x2c, 0xbc, 0xe1, 0x43, 0xb4, 0x47,
	0x8b, 0xc4, 0x1b, 0x43, 0xe9, 0xf1, 0x62, 0x38, 0x24, 0x13, 0x2f, 0x60, 0x71, 0x91, 0x50, 0x6e,
	0x36, 0x16, 0x1a, 0x6f, 0x97, 0x16, 0xc9, 0x31, 0x94, 0xa7, 0x32, 0xe2, 0x48, 0x05, 0xe0, 0x2f,
	0xd1, 0x4e, 0xe2, 0x4f, 0xc4, 0x51, 0xee, 0xa5, 0x90, 0x79, 0x19, 0x7b, 0x63, 0xa2, 0x85, 0x43,
	0x5b, 0x89, 0x3f, 0x39, 0x86, 0x92, 0xbf, 0x86, 0xcc, 0x65, 0x6f, 0xf0, 0x57, 0xe8, 0x91, 0x60,
	0x49, 0x33, 0x10, 0x2c, 0x31, 0xd0, 0x28, 0x1f, 0x99, 0xcd, 0x85, 0xf8, 0xd6, 0x18, 0xca, 0xd7,
	0xd2, 0xfb, 0x52, 0x3a, 0xf1, 0x25, 0x12, 0x10, 0xde, 0xd0, 0x4f, 0x48, 0x5c, 0x8a, 0xe6, 0xda,
	0x94, 0xd1, 0xae, 0x6e, 0xae, 0xe6, 0x2b, 0x7f, 0xf2, 0x42, 0xfa, 0x64, 0x83, 0x7d, 0xf3, 0x80,
	0x06, 0xab, 0x8e, 0xbb, 0xcd, 0x64, 0x8e, 0x15, 0xe2, 0x02, 0xed, 0x69, 0xce, 0x10, 0x86, 0x7e,
	0x11, 0xe7, 0xf3, 0x9c, 0x6c, 0x1d, 0xac, 0x75, 0x9a, 0xdd, 0x43, 0xfb, 0xa3, 0x3b, 0xc3, 0x5e,
	0x1e, 0x62, 0x0d, 0xde, 0x53, 0x10, 0x2a, 0x69, 0xfa, 0xa6, 0x8f, 0x87, 0x1f, 0xba, 0x38, 0xfe,
	0x05, 0xed, 0x89, 0x04, 0xf9, 0x34, 0xbc, 0x5b, 0x8a, 0x6d, 0x49, 0xeb, 0xdc, 0x8f, 0xf6, 0x18,
	0xca, 0x25, 0xb2, 0xdd, 0x31, 0x94, 0xdf, 0xd2, 0x70, 0xb9, 0x76, 0x3f, 0xa1, 0x96, 0x5c, 0x82,
	0x10, 0xce, 0x49, 0x5a, 0x92, 0xe4, 0xd9, 0xfd, 0x48, 0x96, 0x18, 0xb6, 0x35, 0x94, 0x06, 0x6f,
	0xff, 0x65, 0xa0, 0x0d, 0xf5, 0x8c, 0x63, 0xd4, 0x50, 0xf8, 0xa2, 0x7c, 0x6a, 0x95, 0x7d, 0xaf,
	0xcb, 0x57, 0x57, 0x21, 0x0f, 0xae, 0x5d, 0x75, 0xdc, 0xad, 0x2b, 0x86, 0x7e, 0x88, 0x4d, 0xb4,
	0x2e, 0x17, 0xc3, 0xea, 0xc2, 0x62, 0x90, 0x16, 0x6c, 0xa3, 0x75, 0x39, 0x62, 0x6b, 0x72, 0x56,
	0xdb, 0x77, 0x2f, 0x09, 0x89, 0xad, 0xf6, 0xf9, 0x99, 0x2b, 0xe3, 0xf4, 0x3e, 0xa0, 0x8c, 0x7a,
	0xb4, 0x88, 0x63, 0xb1, 0xe9, 0xe4, 0x66, 0x5b, 0xd8, 0x07, 0x27, 0x8c, 0x9e, 0x68, 0x57, 0xfb,
	0xed, 0x2a, 0x6a, 0xcc, 0xd3, 0x8e, 0x4f, 0xd0, 0x86, 0x52, 0x24, 0x2f, 0xfc, 0x4f, 0x53, 0x5a,
	0x17, 0x04, 0xd7, 0xd3, 0x7d, 0xc3, 0xd5, 0x28, 0xf8, 0x1c, 0x35, 0x42, 0x92, 0x41, 0x90, 0x8b,
	0xcf, 0x81, 0xb8, 0xda, 0x76, 0xb7, 0x7b, 0x07, 0x52, 0x6f, 0x00, 0xf1, 0xb7, 0x9a, 0x7e, 0x05,
	0x67, 0xf7, 0xaa, 0x93, 0xd5, 0x02, 0x9a, 0x43, 0xe1, 0xcf, 0xd1, 0x26, 0xe1, 0x5e, 0xc0, 0x92,
	0x94, 0x71, 0x92, 0xab, 0xdc, 0x54, 0x17, 0x6c, 0x12, 0x7e, 0x54, 0x39, 0xf0, 0x53, 0xd4, 0x24,
	0xdc, 0x23, 0xf4, 0x12, 0xb2, 0x1c, 0xc2, 0xa5, 0x44, 0x20, 0xc2, 0xfb, 0xda, 0xde, 0xfe, 0x6d,
	0x15, 0xed, 0x7e, 0xa4, 0xe7, 0x45, 0x0f, 0xdc, 0x8e, 0xf0, 0x9d, 0x1e, 0xf8, 0xaf, 0xe6, 0xb7,
	0x3e, 0xac, 0x86, 0xf7, 0x57, 0x03, 0x3d, 0x5a, 0x1e, 0xdb, 0xdb, 0x8f, 0xe4, 0xb9, 0xa6, 0x6d,
	0x2d, 0x09, 0xfc, 0xf7, 0x1d, 0xd8, 0x0a, 0x97, 0xf0, 0xc2, 0xe7, 0x5f, 0x5c, 0xfd, 0x69, 0xad,
	0x5c, 0xcd, 0x2c, 0xe3, 0x7a, 0x66, 0x19, 0xef, 0x66, 0x96, 0xf1, 0xc7, 0xcc, 0x32, 0x7e, 0xbf,
	0xb1, 0x56, 0xae, 0x6f, 0xac, 0x95, 0x77, 0x37, 0xd6, 0xca, 0x8f, 0x35, 0xfd, 0x1f, 0xc9, 0xdf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x72, 0x1b, 0x61, 0x66, 0xa7, 0x08, 0x00, 0x00,
}

func (m *IndexFetchSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexFetchSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexFetchSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.GeoConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexFetch(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	if len(m.FetchedColumns) > 0 {
		for iNdEx := len(m.FetchedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FetchedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIndexFetch(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.KeyAndSuffixColumns) > 0 {
		for iNdEx := len(m.KeyAndSuffixColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KeyAndSuffixColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIndexFetch(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.FamilyDefaultColumns) > 0 {
		for iNdEx := len(m.FamilyDefaultColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FamilyDefaultColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIndexFetch(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.MaxFamilyID))
	i--
	dAtA[i] = 0x60
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.KeyPrefixLength))
	i--
	dAtA[i] = 0x58
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.MaxKeysPerRow))
	i--
	dAtA[i] = 0x50
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.NumKeySuffixColumns))
	i--
	dAtA[i] = 0x48
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.EncodingType))
	i--
	dAtA[i] = 0x40
	i--
	if m.IsUniqueIndex {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	i--
	if m.IsSecondaryIndex {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i -= len(m.IndexName)
	copy(dAtA[i:], m.IndexName)
	i = encodeVarintIndexFetch(dAtA, i, uint64(len(m.IndexName)))
	i--
	dAtA[i] = 0x2a
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.IndexID))
	i--
	dAtA[i] = 0x20
	i -= len(m.TableName)
	copy(dAtA[i:], m.TableName)
	i = encodeVarintIndexFetch(dAtA, i, uint64(len(m.TableName)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.TableID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *IndexFetchSpec_Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexFetchSpec_Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexFetchSpec_Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.IsNonNullable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexFetch(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintIndexFetch(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.ColumnID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *IndexFetchSpec_KeyColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexFetchSpec_KeyColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexFetchSpec_KeyColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.IsInverted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	i--
	if m.IsComposite {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.Direction))
	i--
	dAtA[i] = 0x10
	{
		size, err := m.IndexFetchSpec_Column.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexFetch(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexFetchSpec_FamilyDefaultColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexFetchSpec_FamilyDefaultColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexFetchSpec_FamilyDefaultColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.DefaultColumnID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.FamilyID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintIndexFetch(dAtA []byte, offset int, v uint64) int {
	offset -= sovIndexFetch(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IndexFetchSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovIndexFetch(uint64(m.Version))
	n += 1 + sovIndexFetch(uint64(m.TableID))
	l = len(m.TableName)
	n += 1 + l + sovIndexFetch(uint64(l))
	n += 1 + sovIndexFetch(uint64(m.IndexID))
	l = len(m.IndexName)
	n += 1 + l + sovIndexFetch(uint64(l))
	n += 2
	n += 2
	n += 1 + sovIndexFetch(uint64(m.EncodingType))
	n += 1 + sovIndexFetch(uint64(m.NumKeySuffixColumns))
	n += 1 + sovIndexFetch(uint64(m.MaxKeysPerRow))
	n += 1 + sovIndexFetch(uint64(m.KeyPrefixLength))
	n += 1 + sovIndexFetch(uint64(m.MaxFamilyID))
	if len(m.FamilyDefaultColumns) > 0 {
		for _, e := range m.FamilyDefaultColumns {
			l = e.Size()
			n += 1 + l + sovIndexFetch(uint64(l))
		}
	}
	if len(m.KeyAndSuffixColumns) > 0 {
		for _, e := range m.KeyAndSuffixColumns {
			l = e.Size()
			n += 1 + l + sovIndexFetch(uint64(l))
		}
	}
	if len(m.FetchedColumns) > 0 {
		for _, e := range m.FetchedColumns {
			l = e.Size()
			n += 1 + l + sovIndexFetch(uint64(l))
		}
	}
	l = m.GeoConfig.Size()
	n += 2 + l + sovIndexFetch(uint64(l))
	return n
}

func (m *IndexFetchSpec_Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovIndexFetch(uint64(m.ColumnID))
	l = len(m.Name)
	n += 1 + l + sovIndexFetch(uint64(l))
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovIndexFetch(uint64(l))
	}
	n += 2
	return n
}

func (m *IndexFetchSpec_KeyColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IndexFetchSpec_Column.Size()
	n += 1 + l + sovIndexFetch(uint64(l))
	n += 1 + sovIndexFetch(uint64(m.Direction))
	n += 2
	n += 2
	return n
}

func (m *IndexFetchSpec_FamilyDefaultColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovIndexFetch(uint64(m.FamilyID))
	n += 1 + sovIndexFetch(uint64(m.DefaultColumnID))
	return n
}

func sovIndexFetch(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIndexFetch(x uint64) (n int) {
	return sovIndexFetch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IndexFetchSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexFetchSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexFetchSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSecondaryIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSecondaryIndex = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUniqueIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUniqueIndex = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingType", wireType)
			}
			m.EncodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncodingType |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catenumpb.IndexDescriptorEncodingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumKeySuffixColumns", wireType)
			}
			m.NumKeySuffixColumns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumKeySuffixColumns |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxKeysPerRow", wireType)
			}
			m.MaxKeysPerRow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxKeysPerRow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPrefixLength", wireType)
			}
			m.KeyPrefixLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyPrefixLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFamilyID", wireType)
			}
			m.MaxFamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFamilyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyDefaultColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamilyDefaultColumns = append(m.FamilyDefaultColumns, IndexFetchSpec_FamilyDefaultColumn{})
			if err := m.FamilyDefaultColumns[len(m.FamilyDefaultColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAndSuffixColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAndSuffixColumns = append(m.KeyAndSuffixColumns, IndexFetchSpec_KeyColumn{})
			if err := m.KeyAndSuffixColumns[len(m.KeyAndSuffixColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FetchedColumns = append(m.FetchedColumns, IndexFetchSpec_Column{})
			if err := m.FetchedColumns[len(m.FetchedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GeoConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexFetch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexFetchSpec_Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &types.T{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNonNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNonNullable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIndexFetch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexFetchSpec_KeyColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexFetchSpec_Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IndexFetchSpec_Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= catenumpb.IndexColumn_Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsComposite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsComposite = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInverted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIndexFetch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexFetchSpec_FamilyDefaultColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FamilyDefaultColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FamilyDefaultColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyID", wireType)
			}
			m.FamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FamilyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultColumnID", wireType)
			}
			m.DefaultColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndexFetch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIndexFetch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIndexFetch
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIndexFetch
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIndexFetch
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIndexFetch        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIndexFetch          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIndexFetch = fmt.Errorf("proto: unexpected end of group")
)
