// Code generated by execgen; DO NOT EDIT.
// Copyright 2020 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"context"
	"fmt"
	"math"
	"reflect"
	"unsafe"

	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execerror"
	// HACK: crlfmt removes the "*/}}" comment if it's the last line in the
	// import block. This was picked because it sorts after
	// "pkg/sql/colexec/execgen" and has no deps.
	_ "github.com/cockroachdb/cockroach/pkg/util/bufalloc"
)

// rehash takes an element of a key (tuple representing a row of equality
// column values) at a given column and computes a new hash by applying a
// transformation to the existing hash.
func rehash(
	ctx context.Context,
	buckets []uint64,
	t coltypes.T,
	col coldata.Vec,
	nKeys uint64,
	sel []uint16,
	cancelChecker CancelChecker,
) {
	switch t {
	case coltypes.Bool:
		keys, nulls := col.Bool(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Bytes:
		keys, nulls := col.Bytes(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys.Get(int(nKeys - 1))
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys.Get(int(nKeys - 1))
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Decimal:
		keys, nulls := col.Decimal(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					b := []byte(v.String())
					sh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(b)))

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					b := []byte(v.String())
					sh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(b)))

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					b := []byte(v.String())
					sh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(b)))

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					b := []byte(v.String())
					sh := (*reflect.SliceHeader)(unsafe.Pointer(&b))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(b)))

					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Int16:
		keys, nulls := col.Int16(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Int32:
		keys, nulls := col.Int32(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Int64:
		keys, nulls := col.Int64(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					// In order for integers with different widths but of the same value to
					// to hash to the same value, we upcast all of them to int64.
					asInt64 := int64(v)
					p = memhash64(noescape(unsafe.Pointer(&asInt64)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Float64:
		keys, nulls := col.Float64(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					f := v
					if math.IsNaN(float64(f)) {
						f = 0
					}
					p = f64hash(noescape(unsafe.Pointer(&f)), p)

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					f := v
					if math.IsNaN(float64(f)) {
						f = 0
					}
					p = f64hash(noescape(unsafe.Pointer(&f)), p)

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					f := v
					if math.IsNaN(float64(f)) {
						f = 0
					}
					p = f64hash(noescape(unsafe.Pointer(&f)), p)

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					f := v
					if math.IsNaN(float64(f)) {
						f = 0
					}
					p = f64hash(noescape(unsafe.Pointer(&f)), p)

					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Timestamp:
		keys, nulls := col.Timestamp(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					s := v.UnixNano()
					p = memhash64(noescape(unsafe.Pointer(&s)), p)

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					s := v.UnixNano()
					p = memhash64(noescape(unsafe.Pointer(&s)), p)

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					s := v.UnixNano()
					p = memhash64(noescape(unsafe.Pointer(&s)), p)

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					s := v.UnixNano()
					p = memhash64(noescape(unsafe.Pointer(&s)), p)

					buckets[i] = uint64(p)
				}
			}
		}

	case coltypes.Interval:
		keys, nulls := col.Interval(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					months, days, nanos := v.Months, v.Days, v.Nanos()
					p = memhash64(noescape(unsafe.Pointer(&months)), p)
					p = memhash64(noescape(unsafe.Pointer(&days)), p)
					p = memhash64(noescape(unsafe.Pointer(&nanos)), p)

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					if nulls.NullAt(uint16(selIdx)) {
						continue
					}
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					months, days, nanos := v.Months, v.Days, v.Nanos()
					p = memhash64(noescape(unsafe.Pointer(&months)), p)
					p = memhash64(noescape(unsafe.Pointer(&days)), p)
					p = memhash64(noescape(unsafe.Pointer(&nanos)), p)

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = sel[nKeys-1]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					months, days, nanos := v.Months, v.Days, v.Nanos()
					p = memhash64(noescape(unsafe.Pointer(&months)), p)
					p = memhash64(noescape(unsafe.Pointer(&days)), p)
					p = memhash64(noescape(unsafe.Pointer(&nanos)), p)

					buckets[i] = uint64(p)
				}
			} else {
				// Early bounds checks.
				_ = buckets[nKeys-1]
				_ = keys[int(nKeys-1)]
				for i := uint64(0); i < nKeys; i++ {
					cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					months, days, nanos := v.Months, v.Days, v.Nanos()
					p = memhash64(noescape(unsafe.Pointer(&months)), p)
					p = memhash64(noescape(unsafe.Pointer(&days)), p)
					p = memhash64(noescape(unsafe.Pointer(&nanos)), p)

					buckets[i] = uint64(p)
				}
			}
		}

	default:
		execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", t))
	}
}
