// Code generated by execgen; DO NOT EDIT.
// Copyright 2020 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"fmt"
	"math"

	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

// checkCol determines if the current key column in the groupID buckets matches
// the specified equality column key. If there is a match, then the key is added
// to differs. If the bucket has reached the end, the key is rejected. If the
// hashTable disallows null equality, then if any element in the key is null,
// there is no match.
func (ht *hashTable) checkCol(
	probeVec, buildVec coldata.Vec,
	probeType, buildType coltypes.T,
	keyColIdx int,
	nToCheck uint64,
	probeSel []int,
	buildSel []int,
) {

	// In order to inline the templated code of overloads, we need to have a
	// `decimalScratch` local variable of type `decimalOverloadScratch`.
	decimalScratch := ht.decimalScratch
	switch probeType {
	case coltypes.Bool:
		switch buildType {
		case coltypes.Bool:
			probeKeys := probeVec.Bool()
			buildKeys := buildVec.Bool()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if !probeVal && buildVal {
													cmpResult = -1
												} else if probeVal && !buildVal {
													cmpResult = 1
												} else {
													cmpResult = 0
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Bytes:
		switch buildType {
		case coltypes.Bytes:
			probeKeys := probeVec.Bytes()
			buildKeys := buildVec.Bytes()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys.Get(probeIdx)
											buildVal := buildKeys.Get(buildIdx)
											var unique bool

											{
												var cmpResult int
												cmpResult = bytes.Compare(probeVal, buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(probeIdx)
										buildVal := buildKeys.Get(buildIdx)
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Decimal:
		switch buildType {
		case coltypes.Decimal:
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Decimal()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Int16()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Int32()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Int64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(buildVal), 0)
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Float64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Int16:
		switch buildType {
		case coltypes.Decimal:
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Decimal()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Int16()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Int32()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Int64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Float64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Int32:
		switch buildType {
		case coltypes.Decimal:
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Decimal()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Int16()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Int32()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Int64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Float64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Int64:
		switch buildType {
		case coltypes.Decimal:
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Decimal()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													tmpDec.SetFinite(int64(probeVal), 0)
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Int16()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Int32()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Int64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := int64(probeVal), int64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else {
														cmpResult = 0
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Float64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if false {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Float64:
		switch buildType {
		case coltypes.Decimal:
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Decimal()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													tmpDec := &decimalScratch.tmpDec1
													if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
														execerror.NonVectorizedPanic(err)
													}
													cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Int16()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Int32()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Int64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if false {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Float64()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												{
													a, b := float64(probeVal), float64(buildVal)
													if a < b {
														cmpResult = -1
													} else if a > b {
														cmpResult = 1
													} else if a == b {
														cmpResult = 0
													} else if math.IsNaN(a) {
														if math.IsNaN(b) {
															cmpResult = 0
														} else {
															cmpResult = -1
														}
													} else {
														cmpResult = 1
													}
												}

												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Timestamp:
		switch buildType {
		case coltypes.Timestamp:
			probeKeys := probeVec.Timestamp()
			buildKeys := buildVec.Timestamp()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int

												if probeVal.Before(buildVal) {
													cmpResult = -1
												} else if buildVal.Before(probeVal) {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Interval:
		switch buildType {
		case coltypes.Interval:
			probeKeys := probeVec.Interval()
			buildKeys := buildVec.Interval()

			if probeSel != nil {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := probeSel[toCheck]
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := probeSel[toCheck]

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			} else {
				if buildSel != nil {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := buildSel[keyID-1]

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := buildSel[keyID-1]

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				} else {
					if probeVec.MaybeHasNulls() {
						if buildVec.MaybeHasNulls() {
							if ht.allowNullEquality {
								// The allowNullEquality flag only matters if both vectors have nulls.
								// This lets us avoid writing all 2^3 conditional branches.
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull && buildIsNull {
											// Both values are NULLs, and since we're allowing null equality, we
											// proceed to the next value to check.
											continue
										} else if probeIsNull {
											// Only probing value is NULL, so it is different from the build value
											// (which is non-NULL). We mark it as "different" and proceed to the
											// next value to check. This behavior is special in case of allowing
											// null equality because we don't want to reset the groupID of the
											// current probing tuple.
											ht.probeScratch.differs[toCheck] = true
											continue
										}
										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							} else {
								probeIsNull := false
								buildIsNull := false
								// Early bounds check.
								_ = ht.probeScratch.toCheck[nToCheck-1]
								for i := uint64(0); i < nToCheck; i++ {
									// keyID of 0 is reserved to represent the end of the next chain.

									toCheck := ht.probeScratch.toCheck[i]
									keyID := ht.probeScratch.groupID[toCheck]
									if keyID != 0 {
										// the build table key (calculated using keys[keyID - 1] = key) is
										// compared to the corresponding probe table to determine if a match is
										// found.

										probeIdx := int(toCheck)
										probeIsNull = probeVec.Nulls().NullAt(probeIdx)

										buildIdx := int(keyID - 1)

										buildIsNull = buildVec.Nulls().NullAt(buildIdx)

										if probeIsNull {
											ht.probeScratch.groupID[toCheck] = 0
										} else if buildIsNull {
											ht.probeScratch.differs[toCheck] = true
										} else {
											probeVal := probeKeys[probeIdx]
											buildVal := buildKeys[buildIdx]
											var unique bool

											{
												var cmpResult int
												cmpResult = probeVal.Compare(buildVal)
												unique = cmpResult != 0
											}

											ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
										}
									}

								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)
									probeIsNull = probeVec.Nulls().NullAt(probeIdx)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					} else {
						if buildVec.MaybeHasNulls() {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									buildIsNull = buildVec.Nulls().NullAt(buildIdx)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.probeScratch.toCheck[nToCheck-1]
							for i := uint64(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.probeScratch.toCheck[i]
								keyID := ht.probeScratch.groupID[toCheck]
								if keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									probeIdx := int(toCheck)

									buildIdx := int(keyID - 1)

									if probeIsNull {
										ht.probeScratch.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.probeScratch.differs[toCheck] = true
									} else {
										probeVal := probeKeys[probeIdx]
										buildVal := buildKeys[buildIdx]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
									}
								}

							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	default:
		execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", probeType))
	}
}

func (ht *hashTable) checkColForDistinctTuples(
	probeVec, buildVec coldata.Vec, probeType coltypes.T, nToCheck uint64, probeSel []int,
) {
	switch probeType {
	case coltypes.Bool:
		probeKeys := probeVec.Bool()
		buildKeys := buildVec.Bool()

		if probeSel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if !probeVal && buildVal {
										cmpResult = -1
									} else if probeVal && !buildVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if !probeVal && buildVal {
										cmpResult = -1
									} else if probeVal && !buildVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if !probeVal && buildVal {
										cmpResult = -1
									} else if probeVal && !buildVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if !probeVal && buildVal {
										cmpResult = -1
									} else if probeVal && !buildVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if !probeVal && buildVal {
										cmpResult = -1
									} else if probeVal && !buildVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if !probeVal && buildVal {
										cmpResult = -1
									} else if probeVal && !buildVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if !probeVal && buildVal {
										cmpResult = -1
									} else if probeVal && !buildVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if !probeVal && buildVal {
										cmpResult = -1
									} else if probeVal && !buildVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		}
	case coltypes.Bytes:
		probeKeys := probeVec.Bytes()
		buildKeys := buildVec.Bytes()

		if probeSel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys.Get(probeIdx)
								buildVal := buildKeys.Get(buildIdx)
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(probeVal, buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys.Get(probeIdx)
								buildVal := buildKeys.Get(buildIdx)
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(probeVal, buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys.Get(probeIdx)
								buildVal := buildKeys.Get(buildIdx)
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(probeVal, buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys.Get(probeIdx)
								buildVal := buildKeys.Get(buildIdx)
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(probeVal, buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys.Get(probeIdx)
								buildVal := buildKeys.Get(buildIdx)
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(probeVal, buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys.Get(probeIdx)
								buildVal := buildKeys.Get(buildIdx)
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(probeVal, buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys.Get(probeIdx)
								buildVal := buildKeys.Get(buildIdx)
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(probeVal, buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys.Get(probeIdx)
								buildVal := buildKeys.Get(buildIdx)
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(probeVal, buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		}
	case coltypes.Decimal:
		probeKeys := probeVec.Decimal()
		buildKeys := buildVec.Decimal()

		if probeSel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		}
	case coltypes.Int16:
		probeKeys := probeVec.Int16()
		buildKeys := buildVec.Int16()

		if probeSel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		}
	case coltypes.Int32:
		probeKeys := probeVec.Int32()
		buildKeys := buildVec.Int32()

		if probeSel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		}
	case coltypes.Int64:
		probeKeys := probeVec.Int64()
		buildKeys := buildVec.Int64()

		if probeSel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(probeVal), int64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		}
	case coltypes.Float64:
		probeKeys := probeVec.Float64()
		buildKeys := buildVec.Float64()

		if probeSel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(probeVal), float64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(probeVal), float64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(probeVal), float64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(probeVal), float64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(probeVal), float64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(probeVal), float64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(probeVal), float64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(probeVal), float64(buildVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		}
	case coltypes.Timestamp:
		probeKeys := probeVec.Timestamp()
		buildKeys := buildVec.Timestamp()

		if probeSel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if probeVal.Before(buildVal) {
										cmpResult = -1
									} else if buildVal.Before(probeVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if probeVal.Before(buildVal) {
										cmpResult = -1
									} else if buildVal.Before(probeVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if probeVal.Before(buildVal) {
										cmpResult = -1
									} else if buildVal.Before(probeVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if probeVal.Before(buildVal) {
										cmpResult = -1
									} else if buildVal.Before(probeVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if probeVal.Before(buildVal) {
										cmpResult = -1
									} else if buildVal.Before(probeVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if probeVal.Before(buildVal) {
										cmpResult = -1
									} else if buildVal.Before(probeVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if probeVal.Before(buildVal) {
										cmpResult = -1
									} else if buildVal.Before(probeVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int

									if probeVal.Before(buildVal) {
										cmpResult = -1
									} else if buildVal.Before(probeVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		}
	case coltypes.Interval:
		probeKeys := probeVec.Interval()
		buildKeys := buildVec.Interval()

		if probeSel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = probeVal.Compare(buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = probeVal.Compare(buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = probeVal.Compare(buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := probeSel[toCheck]

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = probeVal.Compare(buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = probeVal.Compare(buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)
							probeIsNull = probeVec.Nulls().NullAt(probeIdx)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = probeVal.Compare(buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							buildIsNull = buildVec.Nulls().NullAt(buildIdx)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = probeVal.Compare(buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.probeScratch.toCheck[nToCheck-1]
					for i := uint64(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.probeScratch.toCheck[i]
						keyID := ht.probeScratch.groupID[toCheck]
						if keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							probeIdx := int(toCheck)

							buildIdx := int(keyID - 1)

							if probeIsNull && buildIsNull {
								// Both values are NULLs, and since we're allowing null equality, we
								// proceed to the next value to check.
								continue
							} else if probeIsNull {
								// Only probing value is NULL, so it is different from the build value
								// (which is non-NULL). We mark it as "different" and proceed to the
								// next value to check. This behavior is special in case of allowing
								// null equality because we don't want to reset the groupID of the
								// current probing tuple.
								ht.probeScratch.differs[toCheck] = true
								continue
							}
							if probeIsNull {
								ht.probeScratch.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.probeScratch.differs[toCheck] = true
							} else {
								probeVal := probeKeys[probeIdx]
								buildVal := buildKeys[buildIdx]
								var unique bool

								{
									var cmpResult int
									cmpResult = probeVal.Compare(buildVal)
									unique = cmpResult != 0
								}

								ht.probeScratch.differs[toCheck] = ht.probeScratch.differs[toCheck] || unique
							}
						}

						if keyID == 0 {
							ht.probeScratch.distinct[toCheck] = true
						}

					}
				}
			}

		}
	default:
		execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", probeType))
	}
}

// checkBuildForDistinct finds all tuples in probeVecs that are not present in
// buffered tuples stored in ht.vals. It stores the probeVecs's distinct tuples'
// keyIDs in headID buffer.
// NOTE: It assumes that probeVecs does not contain any duplicates itself.
// NOTE: It assumes that probSel has already being populated and it is not
//       nil.
func (ht *hashTable) checkBuildForDistinct(
	probeVecs []coldata.Vec, nToCheck uint64, probeSel []int,
) uint64 {
	if probeSel == nil {
		execerror.VectorizedInternalPanic("invalid selection vector")
	}
	copy(ht.probeScratch.distinct, zeroBoolColumn)

	ht.checkColsForDistinctTuples(probeVecs, nToCheck, probeSel)

	nDiffers := uint64(0)
	for i := uint64(0); i < nToCheck; i++ {
		if ht.probeScratch.distinct[ht.probeScratch.toCheck[i]] {
			ht.probeScratch.distinct[ht.probeScratch.toCheck[i]] = false
			// Calculated using the convention: keyID = keys.indexOf(key) + 1.
			ht.probeScratch.headID[ht.probeScratch.toCheck[i]] = ht.probeScratch.toCheck[i] + 1
		} else if ht.probeScratch.differs[ht.probeScratch.toCheck[i]] {
			// Continue probing in this next chain for the probe key.
			ht.probeScratch.differs[ht.probeScratch.toCheck[i]] = false
			ht.probeScratch.toCheck[nDiffers] = ht.probeScratch.toCheck[i]
			nDiffers++
		}
	}

	return nDiffers
}

// check performs an equality check between the current key in the groupID bucket
// and the probe key at that index. If there is a match, the hashTable's same
// array is updated to lazily populate the linked list of identical build
// table keys. The visited flag for corresponding build table key is also set. A
// key is removed from toCheck if it has already been visited in a previous
// probe, or the bucket has reached the end (key not found in build table). The
// new length of toCheck is returned by this function.
func (ht *hashTable) check(
	probeVecs []coldata.Vec,
	probeKeyTypes []coltypes.T,
	buildKeyCols []uint32,
	nToCheck uint64,
	probeSel []int,
) uint64 {
	ht.checkCols(probeVecs, ht.vals.ColVecs(), probeKeyTypes, buildKeyCols, nToCheck, probeSel, nil /* buildSel */)

	nDiffers := uint64(0)
	for i := uint64(0); i < nToCheck; i++ {
		if !ht.probeScratch.differs[ht.probeScratch.toCheck[i]] {
			// If the current key matches with the probe key, we want to update headID
			// with the current key if it has not been set yet.
			keyID := ht.probeScratch.groupID[ht.probeScratch.toCheck[i]]
			if ht.probeScratch.headID[ht.probeScratch.toCheck[i]] == 0 {
				ht.probeScratch.headID[ht.probeScratch.toCheck[i]] = keyID
			}

			firstID := ht.probeScratch.headID[ht.probeScratch.toCheck[i]]

			if !ht.visited[keyID] {
				// We can then add this keyID into the same array at the end of the
				// corresponding linked list and mark this ID as visited. Since there
				// can be multiple keys that match this probe key, we want to mark
				// differs at this position to be true. This way, the prober will
				// continue probing for this key until it reaches the end of the next
				// chain.
				ht.probeScratch.differs[ht.probeScratch.toCheck[i]] = true
				ht.visited[keyID] = true

				if firstID != keyID {
					ht.same[keyID] = ht.same[firstID]
					ht.same[firstID] = keyID
				}
			}

		}

		if ht.probeScratch.differs[ht.probeScratch.toCheck[i]] {
			// Continue probing in this next chain for the probe key.
			ht.probeScratch.differs[ht.probeScratch.toCheck[i]] = false
			ht.probeScratch.toCheck[nDiffers] = ht.probeScratch.toCheck[i]
			nDiffers++
		}
	}

	return nDiffers
}

// checkProbeForDistinct performs a column by column check for duplicated tuples
// in the probe table.
func (ht *hashTable) checkProbeForDistinct(vecs []coldata.Vec, nToCheck uint64, sel []int) uint64 {
	for i := range ht.keyCols {
		ht.checkCol(vecs[i], vecs[i], ht.keyTypes[i], ht.keyTypes[i], i, nToCheck, sel, sel)
	}

	nDiffers := uint64(0)
	for i := uint64(0); i < nToCheck; i++ {
		if !ht.probeScratch.differs[ht.probeScratch.toCheck[i]] {
			// If the current key matches with the probe key, we want to update headID
			// with the current key if it has not been set yet.
			keyID := ht.probeScratch.groupID[ht.probeScratch.toCheck[i]]
			if ht.probeScratch.headID[ht.probeScratch.toCheck[i]] == 0 {
				ht.probeScratch.headID[ht.probeScratch.toCheck[i]] = keyID
			}

		}

		if ht.probeScratch.differs[ht.probeScratch.toCheck[i]] {
			// Continue probing in this next chain for the probe key.
			ht.probeScratch.differs[ht.probeScratch.toCheck[i]] = false
			ht.probeScratch.toCheck[nDiffers] = ht.probeScratch.toCheck[i]
			nDiffers++
		}
	}

	return nDiffers
}

// updateSel updates the selection vector in the given batch using the headID
// buffer. For each nonzero keyID in headID, it will be translated to the actual
// key index using the convention keyID = keys.indexOf(key) + 1. If the input
// batch's selection vector is nil, the key index will be directly used to
// populate the selection vector. Otherwise, the selection vector's value at the
// key index will be used. The duplicated keyIDs will be discarded. The
// hashBuffer will also compact and discard hash values of duplicated keys.
func (ht *hashTable) updateSel(b coldata.Batch) {
	distinctCount := 0

	if sel := b.Selection(); sel != nil {
		// Reuse the buffer allocated for distinct.
		visited := ht.probeScratch.distinct
		copy(visited, zeroBoolColumn)

		for i := 0; i < b.Length(); i++ {
			if ht.probeScratch.headID[i] != 0 {
				if hasVisited := visited[ht.probeScratch.headID[i]-1]; !hasVisited {
					sel[distinctCount] = sel[ht.probeScratch.headID[i]-1]
					visited[ht.probeScratch.headID[i]-1] = true

					// Compacting and deduplicating hash buffer.
					ht.probeScratch.hashBuffer[distinctCount] = ht.probeScratch.hashBuffer[i]
					distinctCount++
				}
			}
			ht.probeScratch.headID[i] = 0
			ht.probeScratch.differs[i] = false
		}

	} else {
		b.SetSelection(true)
		sel = b.Selection()
		// Reuse the buffer allocated for distinct.
		visited := ht.probeScratch.distinct
		copy(visited, zeroBoolColumn)

		for i := 0; i < b.Length(); i++ {
			if ht.probeScratch.headID[i] != 0 {
				if hasVisited := visited[ht.probeScratch.headID[i]-1]; !hasVisited {
					sel[distinctCount] = int(ht.probeScratch.headID[i] - 1)
					visited[ht.probeScratch.headID[i]-1] = true

					// Compacting and deduplicating hash buffer.
					ht.probeScratch.hashBuffer[distinctCount] = ht.probeScratch.hashBuffer[i]
					distinctCount++
				}
			}
			ht.probeScratch.headID[i] = 0
			ht.probeScratch.differs[i] = false
		}

	}

	b.SetLength(distinctCount)
}

// distinctCheck determines if the current key in the groupID bucket matches the
// equality column key. If there is a match, then the key is removed from
// toCheck. If the bucket has reached the end, the key is rejected. The toCheck
// list is reconstructed to only hold the indices of the eqCol keys that have
// not been found. The new length of toCheck is returned by this function.
func (ht *hashTable) distinctCheck(
	probeKeyTypes []coltypes.T, nToCheck uint64, probeSel []int,
) uint64 {
	probeVecs := ht.probeScratch.keys
	buildVecs := ht.vals.ColVecs()
	buildKeyCols := ht.keyCols
	var buildSel []int
	ht.checkCols(probeVecs, buildVecs, probeKeyTypes, buildKeyCols, nToCheck, probeSel, buildSel)

	// Select the indices that differ and put them into toCheck.
	nDiffers := uint64(0)
	for i := uint64(0); i < nToCheck; i++ {
		if ht.probeScratch.differs[ht.probeScratch.toCheck[i]] {
			ht.probeScratch.differs[ht.probeScratch.toCheck[i]] = false
			ht.probeScratch.toCheck[nDiffers] = ht.probeScratch.toCheck[i]
			nDiffers++
		}
	}

	return nDiffers
}
