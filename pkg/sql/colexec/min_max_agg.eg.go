// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"math"
	"time"
	"unsafe"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/pkg/errors"
)

func newMinAgg(allocator *Allocator, t coltypes.T) (aggregateFunc, error) {
	switch t {
	case coltypes.Bool:
		allocator.AdjustMemoryUsage(int64(sizeOfminBoolAgg))
		return &minBoolAgg{allocator: allocator}, nil
	case coltypes.Bytes:
		allocator.AdjustMemoryUsage(int64(sizeOfminBytesAgg))
		return &minBytesAgg{allocator: allocator}, nil
	case coltypes.Decimal:
		allocator.AdjustMemoryUsage(int64(sizeOfminDecimalAgg))
		return &minDecimalAgg{allocator: allocator}, nil
	case coltypes.Int16:
		allocator.AdjustMemoryUsage(int64(sizeOfminInt16Agg))
		return &minInt16Agg{allocator: allocator}, nil
	case coltypes.Int32:
		allocator.AdjustMemoryUsage(int64(sizeOfminInt32Agg))
		return &minInt32Agg{allocator: allocator}, nil
	case coltypes.Int64:
		allocator.AdjustMemoryUsage(int64(sizeOfminInt64Agg))
		return &minInt64Agg{allocator: allocator}, nil
	case coltypes.Float64:
		allocator.AdjustMemoryUsage(int64(sizeOfminFloat64Agg))
		return &minFloat64Agg{allocator: allocator}, nil
	case coltypes.Timestamp:
		allocator.AdjustMemoryUsage(int64(sizeOfminTimestampAgg))
		return &minTimestampAgg{allocator: allocator}, nil
	case coltypes.Interval:
		allocator.AdjustMemoryUsage(int64(sizeOfminIntervalAgg))
		return &minIntervalAgg{allocator: allocator}, nil
	default:
		return nil, errors.Errorf("unsupported min/max agg type %s", t)
	}
}

type minBoolAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg bool
	// col points to the output vector we are updating.
	col []bool
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBoolAgg{}

const sizeOfminBoolAgg = unsafe.Sizeof(minBoolAgg{})

func (a *minBoolAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bool()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minBoolAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minBoolAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minBoolAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minBoolAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minBoolAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minBytesAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBytesAgg{}

const sizeOfminBytesAgg = unsafe.Sizeof(minBytesAgg{})

func (a *minBytesAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bytes()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minBytesAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minBytesAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minBytesAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minBytesAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col.Set(a.curIdx, a.curAgg)
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()
	oldCurAggSize := len(a.curAgg)
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			}
		},
	)
	a.allocator.AdjustMemoryUsage(int64(len(a.curAgg) - oldCurAggSize))
}

func (a *minBytesAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minDecimalAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col []apd.Decimal
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minDecimalAgg{}

const sizeOfminDecimalAgg = unsafe.Sizeof(minDecimalAgg{})

func (a *minDecimalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Decimal()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minDecimalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minDecimalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minDecimalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minDecimalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx].Set(&a.curAgg)
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minDecimalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt16Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int16
	// col points to the output vector we are updating.
	col []int16
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt16Agg{}

const sizeOfminInt16Agg = unsafe.Sizeof(minInt16Agg{})

func (a *minInt16Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int16()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt16Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minInt16Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt16Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minInt16Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt16Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt32Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int32
	// col points to the output vector we are updating.
	col []int32
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt32Agg{}

const sizeOfminInt32Agg = unsafe.Sizeof(minInt32Agg{})

func (a *minInt32Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int32()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt32Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minInt32Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt32Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minInt32Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt32Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt64Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt64Agg{}

const sizeOfminInt64Agg = unsafe.Sizeof(minInt64Agg{})

func (a *minInt64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minInt64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minInt64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minFloat64Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg float64
	// col points to the output vector we are updating.
	col []float64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minFloat64Agg{}

const sizeOfminFloat64Agg = unsafe.Sizeof(minFloat64Agg{})

func (a *minFloat64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Float64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minFloat64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minFloat64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minFloat64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minFloat64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minFloat64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minTimestampAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg time.Time
	// col points to the output vector we are updating.
	col []time.Time
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minTimestampAgg{}

const sizeOfminTimestampAgg = unsafe.Sizeof(minTimestampAgg{})

func (a *minTimestampAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Timestamp()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minTimestampAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minTimestampAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minTimestampAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minTimestampAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minTimestampAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minIntervalAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg duration.Duration
	// col points to the output vector we are updating.
	col []duration.Duration
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minIntervalAgg{}

const sizeOfminIntervalAgg = unsafe.Sizeof(minIntervalAgg{})

func (a *minIntervalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Interval()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minIntervalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *minIntervalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minIntervalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minIntervalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minIntervalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

func newMaxAgg(allocator *Allocator, t coltypes.T) (aggregateFunc, error) {
	switch t {
	case coltypes.Bool:
		allocator.AdjustMemoryUsage(int64(sizeOfmaxBoolAgg))
		return &maxBoolAgg{allocator: allocator}, nil
	case coltypes.Bytes:
		allocator.AdjustMemoryUsage(int64(sizeOfmaxBytesAgg))
		return &maxBytesAgg{allocator: allocator}, nil
	case coltypes.Decimal:
		allocator.AdjustMemoryUsage(int64(sizeOfmaxDecimalAgg))
		return &maxDecimalAgg{allocator: allocator}, nil
	case coltypes.Int16:
		allocator.AdjustMemoryUsage(int64(sizeOfmaxInt16Agg))
		return &maxInt16Agg{allocator: allocator}, nil
	case coltypes.Int32:
		allocator.AdjustMemoryUsage(int64(sizeOfmaxInt32Agg))
		return &maxInt32Agg{allocator: allocator}, nil
	case coltypes.Int64:
		allocator.AdjustMemoryUsage(int64(sizeOfmaxInt64Agg))
		return &maxInt64Agg{allocator: allocator}, nil
	case coltypes.Float64:
		allocator.AdjustMemoryUsage(int64(sizeOfmaxFloat64Agg))
		return &maxFloat64Agg{allocator: allocator}, nil
	case coltypes.Timestamp:
		allocator.AdjustMemoryUsage(int64(sizeOfmaxTimestampAgg))
		return &maxTimestampAgg{allocator: allocator}, nil
	case coltypes.Interval:
		allocator.AdjustMemoryUsage(int64(sizeOfmaxIntervalAgg))
		return &maxIntervalAgg{allocator: allocator}, nil
	default:
		return nil, errors.Errorf("unsupported min/max agg type %s", t)
	}
}

type maxBoolAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg bool
	// col points to the output vector we are updating.
	col []bool
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBoolAgg{}

const sizeOfmaxBoolAgg = unsafe.Sizeof(maxBoolAgg{})

func (a *maxBoolAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bool()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxBoolAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxBoolAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxBoolAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxBoolAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxBoolAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxBytesAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBytesAgg{}

const sizeOfmaxBytesAgg = unsafe.Sizeof(maxBytesAgg{})

func (a *maxBytesAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bytes()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxBytesAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxBytesAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxBytesAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxBytesAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col.Set(a.curIdx, a.curAgg)
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()
	oldCurAggSize := len(a.curAgg)
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			}
		},
	)
	a.allocator.AdjustMemoryUsage(int64(len(a.curAgg) - oldCurAggSize))
}

func (a *maxBytesAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxDecimalAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col []apd.Decimal
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxDecimalAgg{}

const sizeOfmaxDecimalAgg = unsafe.Sizeof(maxDecimalAgg{})

func (a *maxDecimalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Decimal()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxDecimalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxDecimalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxDecimalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxDecimalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx].Set(&a.curAgg)
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxDecimalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt16Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int16
	// col points to the output vector we are updating.
	col []int16
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt16Agg{}

const sizeOfmaxInt16Agg = unsafe.Sizeof(maxInt16Agg{})

func (a *maxInt16Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int16()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt16Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxInt16Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt16Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxInt16Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt16Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt32Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int32
	// col points to the output vector we are updating.
	col []int32
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt32Agg{}

const sizeOfmaxInt32Agg = unsafe.Sizeof(maxInt32Agg{})

func (a *maxInt32Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int32()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt32Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxInt32Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt32Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxInt32Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt32Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt64Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt64Agg{}

const sizeOfmaxInt64Agg = unsafe.Sizeof(maxInt64Agg{})

func (a *maxInt64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxInt64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxInt64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxFloat64Agg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg float64
	// col points to the output vector we are updating.
	col []float64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxFloat64Agg{}

const sizeOfmaxFloat64Agg = unsafe.Sizeof(maxFloat64Agg{})

func (a *maxFloat64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Float64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxFloat64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxFloat64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxFloat64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxFloat64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxFloat64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxTimestampAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg time.Time
	// col points to the output vector we are updating.
	col []time.Time
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxTimestampAgg{}

const sizeOfmaxTimestampAgg = unsafe.Sizeof(maxTimestampAgg{})

func (a *maxTimestampAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Timestamp()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxTimestampAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxTimestampAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxTimestampAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxTimestampAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxTimestampAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxIntervalAgg struct {
	allocator *Allocator
	done      bool
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg duration.Duration
	// col points to the output vector we are updating.
	col []duration.Duration
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxIntervalAgg{}

const sizeOfmaxIntervalAgg = unsafe.Sizeof(maxIntervalAgg{})

func (a *maxIntervalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Interval()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxIntervalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
	a.done = false
}

func (a *maxIntervalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxIntervalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxIntervalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// The aggregation is finished. Flush the last value. If we haven't found
		// any non-nulls for this group so far, the output for this group should
		// be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxIntervalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}
