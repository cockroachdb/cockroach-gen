// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"time"
	"unsafe"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/pkg/errors"
)

func newAnyNotNullAgg(allocator *Allocator, t coltypes.T) (aggregateFunc, error) {
	switch t {
	case coltypes.Bool:
		allocator.AdjustMemoryUsage(int64(sizeOfAnyNotNullBoolAgg))
		return &anyNotNullBoolAgg{allocator: allocator}, nil
	case coltypes.Bytes:
		allocator.AdjustMemoryUsage(int64(sizeOfAnyNotNullBytesAgg))
		return &anyNotNullBytesAgg{allocator: allocator}, nil
	case coltypes.Decimal:
		allocator.AdjustMemoryUsage(int64(sizeOfAnyNotNullDecimalAgg))
		return &anyNotNullDecimalAgg{allocator: allocator}, nil
	case coltypes.Int16:
		allocator.AdjustMemoryUsage(int64(sizeOfAnyNotNullInt16Agg))
		return &anyNotNullInt16Agg{allocator: allocator}, nil
	case coltypes.Int32:
		allocator.AdjustMemoryUsage(int64(sizeOfAnyNotNullInt32Agg))
		return &anyNotNullInt32Agg{allocator: allocator}, nil
	case coltypes.Int64:
		allocator.AdjustMemoryUsage(int64(sizeOfAnyNotNullInt64Agg))
		return &anyNotNullInt64Agg{allocator: allocator}, nil
	case coltypes.Float64:
		allocator.AdjustMemoryUsage(int64(sizeOfAnyNotNullFloat64Agg))
		return &anyNotNullFloat64Agg{allocator: allocator}, nil
	case coltypes.Timestamp:
		allocator.AdjustMemoryUsage(int64(sizeOfAnyNotNullTimestampAgg))
		return &anyNotNullTimestampAgg{allocator: allocator}, nil
	case coltypes.Interval:
		allocator.AdjustMemoryUsage(int64(sizeOfAnyNotNullIntervalAgg))
		return &anyNotNullIntervalAgg{allocator: allocator}, nil
	default:
		return nil, errors.Errorf("unsupported any not null agg type %s", t)
	}
}

// anyNotNullBoolAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBoolAgg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         coldata.Vec
	col                         []bool
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      bool
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullBoolAgg{}

const sizeOfAnyNotNullBoolAgg = unsafe.Sizeof(anyNotNullBoolAgg{})

func (a *anyNotNullBoolAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Bool()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBoolAgg) Reset() {
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBoolAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBoolAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullBoolAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullBoolAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullBytesAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBytesAgg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         coldata.Vec
	col                         *coldata.Bytes
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      []byte
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullBytesAgg{}

const sizeOfAnyNotNullBytesAgg = unsafe.Sizeof(anyNotNullBytesAgg{})

func (a *anyNotNullBytesAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Bytes()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBytesAgg) Reset() {
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBytesAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBytesAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullBytesAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col.Set(a.curIdx, a.curAgg)
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()
	oldCurAggSize := len(a.curAgg)
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
	a.allocator.AdjustMemoryUsage(int64(len(a.curAgg) - oldCurAggSize))
}

func (a *anyNotNullBytesAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullDecimalAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullDecimalAgg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         coldata.Vec
	col                         []apd.Decimal
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      apd.Decimal
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullDecimalAgg{}

const sizeOfAnyNotNullDecimalAgg = unsafe.Sizeof(anyNotNullDecimalAgg{})

func (a *anyNotNullDecimalAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Decimal()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullDecimalAgg) Reset() {
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullDecimalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullDecimalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullDecimalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx].Set(&a.curAgg)
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullDecimalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullInt16Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt16Agg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         coldata.Vec
	col                         []int16
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int16
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt16Agg{}

const sizeOfAnyNotNullInt16Agg = unsafe.Sizeof(anyNotNullInt16Agg{})

func (a *anyNotNullInt16Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Int16()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt16Agg) Reset() {
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt16Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt16Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullInt16Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt16Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullInt32Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt32Agg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         coldata.Vec
	col                         []int32
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int32
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt32Agg{}

const sizeOfAnyNotNullInt32Agg = unsafe.Sizeof(anyNotNullInt32Agg{})

func (a *anyNotNullInt32Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Int32()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt32Agg) Reset() {
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt32Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt32Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullInt32Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt32Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullInt64Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt64Agg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         coldata.Vec
	col                         []int64
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int64
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt64Agg{}

const sizeOfAnyNotNullInt64Agg = unsafe.Sizeof(anyNotNullInt64Agg{})

func (a *anyNotNullInt64Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Int64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt64Agg) Reset() {
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullInt64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullFloat64Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullFloat64Agg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         coldata.Vec
	col                         []float64
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      float64
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullFloat64Agg{}

const sizeOfAnyNotNullFloat64Agg = unsafe.Sizeof(anyNotNullFloat64Agg{})

func (a *anyNotNullFloat64Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Float64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullFloat64Agg) Reset() {
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullFloat64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullFloat64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullFloat64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullFloat64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullTimestampAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullTimestampAgg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         coldata.Vec
	col                         []time.Time
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      time.Time
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullTimestampAgg{}

const sizeOfAnyNotNullTimestampAgg = unsafe.Sizeof(anyNotNullTimestampAgg{})

func (a *anyNotNullTimestampAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Timestamp()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullTimestampAgg) Reset() {
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullTimestampAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullTimestampAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullTimestampAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullTimestampAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

// anyNotNullIntervalAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullIntervalAgg struct {
	allocator                   *Allocator
	done                        bool
	groups                      []bool
	vec                         coldata.Vec
	col                         []duration.Duration
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      duration.Duration
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullIntervalAgg{}

const sizeOfAnyNotNullIntervalAgg = unsafe.Sizeof(anyNotNullIntervalAgg{})

func (a *anyNotNullIntervalAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Interval()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullIntervalAgg) Reset() {
	a.curIdx = -1
	a.done = false
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullIntervalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullIntervalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullIntervalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	if a.done {
		return
	}
	inputLen := b.Length()
	if inputLen == 0 {
		// If we haven't found any non-nulls for this group so far, the output for
		// this group should be null.
		if !a.foundNonNullForCurrentGroup {
			a.nulls.SetNull(a.curIdx)
		} else {
			a.allocator.PerformOperation(
				[]coldata.Vec{a.vec},
				func() {
					a.col[a.curIdx] = a.curAgg
				},
			)
		}
		a.curIdx++
		a.done = true
		return
	}
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullIntervalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}
