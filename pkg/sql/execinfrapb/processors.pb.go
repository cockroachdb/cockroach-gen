// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors.proto

// Beware! This package name must not be changed, even though it doesn't match
// the Go package name, because it defines the Protobuf message names which
// can't be changed without breaking backward compatibility.

package execinfrapb

import (
	fmt "fmt"
	types "github.com/cockroachdb/cockroach/pkg/sql/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Each processor has the following components:
//
//   - one or more input synchronizers; each one merges rows between one or more
//     input streams;
//
//   - a processor "core" which encapsulates the inner logic of each processor;
//
//   - a post-processing stage which allows "inline" post-processing on results
//     (like projection or filtering);
//
//   - one or more output synchronizers; each one directs rows to one or more
//     output streams.
//
// == Internal columns ==
//
// The core outputs rows of a certain schema to the post-processing stage. We
// call this the "internal schema" (or "internal columns") and it differs for
// each type of core. Column indices in a PostProcessSpec refers to these
// internal columns. Some columns may be unused by the post-processing stage;
// processor implementations are internally optimized to not produce values for
// such unneeded columns.
type ProcessorSpec struct {
	// In most cases, there is one input.
	Input []InputSyncSpec    `protobuf:"bytes,1,rep,name=input" json:"input"`
	Core  ProcessorCoreUnion `protobuf:"bytes,2,opt,name=core" json:"core"`
	Post  PostProcessSpec    `protobuf:"bytes,4,opt,name=post" json:"post"`
	// In most cases, there is one output.
	Output []OutputRouterSpec `protobuf:"bytes,3,rep,name=output" json:"output"`
	// An optional identifier that can be used to correlate processors that are
	// part of the same stage (e.g. multiple joiners that are part of a
	// distributed join). This has no consequence on the running of flows, but is
	// useful for plan diagrams.
	StageID int32 `protobuf:"varint,5,opt,name=stage_id,json=stageId" json:"stage_id"`
	// processor_id uniquely identifies a processor within a physical plan. This
	// has no consequence on the running of flows, but is useful for plan
	// diagrams and linking information like tracing spans and log messages to
	// processors.
	ProcessorID int32 `protobuf:"varint,6,opt,name=processor_id,json=processorId" json:"processor_id"`
	// Schema for the rows produced by this processor (after post-processing has
	// been applied, if there is any).
	//
	// This can be aliased with InputSyncSpec.ColumnTypes, so it must not be
	// modified in-place during planning.
	ResultTypes []*types.T `protobuf:"bytes,7,rep,name=result_types,json=resultTypes" json:"result_types,omitempty"`
	// estimated_row_count contains the number of rows that the optimizer expects
	// will be emitted from this processor, or 0 if the estimate wasn't populated.
	EstimatedRowCount uint64 `protobuf:"varint,8,opt,name=estimated_row_count,json=estimatedRowCount" json:"estimated_row_count"`
}

func (m *ProcessorSpec) Reset()         { *m = ProcessorSpec{} }
func (m *ProcessorSpec) String() string { return proto.CompactTextString(m) }
func (*ProcessorSpec) ProtoMessage()    {}
func (*ProcessorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7eecd35e2274091, []int{0}
}
func (m *ProcessorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProcessorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessorSpec.Merge(m, src)
}
func (m *ProcessorSpec) XXX_Size() int {
	return m.Size()
}
func (m *ProcessorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessorSpec proto.InternalMessageInfo

type ProcessorCoreUnion struct {
	Noop                    *NoopCoreSpec                `protobuf:"bytes,1,opt,name=noop" json:"noop,omitempty"`
	TableReader             *TableReaderSpec             `protobuf:"bytes,2,opt,name=tableReader" json:"tableReader,omitempty"`
	JoinReader              *JoinReaderSpec              `protobuf:"bytes,3,opt,name=joinReader" json:"joinReader,omitempty"`
	Sorter                  *SorterSpec                  `protobuf:"bytes,4,opt,name=sorter" json:"sorter,omitempty"`
	Aggregator              *AggregatorSpec              `protobuf:"bytes,5,opt,name=aggregator" json:"aggregator,omitempty"`
	Distinct                *DistinctSpec                `protobuf:"bytes,7,opt,name=distinct" json:"distinct,omitempty"`
	MergeJoiner             *MergeJoinerSpec             `protobuf:"bytes,8,opt,name=mergeJoiner" json:"mergeJoiner,omitempty"`
	HashJoiner              *HashJoinerSpec              `protobuf:"bytes,9,opt,name=hashJoiner" json:"hashJoiner,omitempty"`
	Values                  *ValuesCoreSpec              `protobuf:"bytes,10,opt,name=values" json:"values,omitempty"`
	Backfiller              *BackfillerSpec              `protobuf:"bytes,11,opt,name=backfiller" json:"backfiller,omitempty"`
	ReadImport              *ReadImportDataSpec          `protobuf:"bytes,13,opt,name=readImport" json:"readImport,omitempty"`
	Sampler                 *SamplerSpec                 `protobuf:"bytes,15,opt,name=Sampler" json:"Sampler,omitempty"`
	SampleAggregator        *SampleAggregatorSpec        `protobuf:"bytes,16,opt,name=SampleAggregator" json:"SampleAggregator,omitempty"`
	ZigzagJoiner            *ZigzagJoinerSpec            `protobuf:"bytes,21,opt,name=zigzagJoiner" json:"zigzagJoiner,omitempty"`
	ProjectSet              *ProjectSetSpec              `protobuf:"bytes,22,opt,name=projectSet" json:"projectSet,omitempty"`
	Windower                *WindowerSpec                `protobuf:"bytes,23,opt,name=windower" json:"windower,omitempty"`
	LocalPlanNode           *LocalPlanNodeSpec           `protobuf:"bytes,24,opt,name=localPlanNode" json:"localPlanNode,omitempty"`
	ChangeAggregator        *ChangeAggregatorSpec        `protobuf:"bytes,25,opt,name=changeAggregator" json:"changeAggregator,omitempty"`
	ChangeFrontier          *ChangeFrontierSpec          `protobuf:"bytes,26,opt,name=changeFrontier" json:"changeFrontier,omitempty"`
	Ordinality              *OrdinalitySpec              `protobuf:"bytes,27,opt,name=ordinality" json:"ordinality,omitempty"`
	BulkRowWriter           *BulkRowWriterSpec           `protobuf:"bytes,28,opt,name=bulkRowWriter" json:"bulkRowWriter,omitempty"`
	InvertedFilterer        *InvertedFiltererSpec        `protobuf:"bytes,29,opt,name=invertedFilterer" json:"invertedFilterer,omitempty"`
	InvertedJoiner          *InvertedJoinerSpec          `protobuf:"bytes,30,opt,name=invertedJoiner" json:"invertedJoiner,omitempty"`
	BackupData              *BackupDataSpec              `protobuf:"bytes,31,opt,name=backupData" json:"backupData,omitempty"`
	SplitAndScatter         *SplitAndScatterSpec         `protobuf:"bytes,32,opt,name=splitAndScatter" json:"splitAndScatter,omitempty"`
	RestoreData             *RestoreDataSpec             `protobuf:"bytes,33,opt,name=restoreData" json:"restoreData,omitempty"`
	Filterer                *FiltererSpec                `protobuf:"bytes,34,opt,name=filterer" json:"filterer,omitempty"`
	StreamIngestionData     *StreamIngestionDataSpec     `protobuf:"bytes,35,opt,name=streamIngestionData" json:"streamIngestionData,omitempty"`
	StreamIngestionFrontier *StreamIngestionFrontierSpec `protobuf:"bytes,36,opt,name=streamIngestionFrontier" json:"streamIngestionFrontier,omitempty"`
	Exporter                *ExportSpec                  `protobuf:"bytes,37,opt,name=exporter" json:"exporter,omitempty"`
	IndexBackfillMerger     *IndexBackfillMergerSpec     `protobuf:"bytes,38,opt,name=indexBackfillMerger" json:"indexBackfillMerger,omitempty"`
	Ttl                     *TTLSpec                     `protobuf:"bytes,39,opt,name=ttl" json:"ttl,omitempty"`
	CloudStorageTest        *CloudStorageTestSpec        `protobuf:"bytes,42,opt,name=cloudStorageTest" json:"cloudStorageTest,omitempty"`
}

func (m *ProcessorCoreUnion) Reset()         { *m = ProcessorCoreUnion{} }
func (m *ProcessorCoreUnion) String() string { return proto.CompactTextString(m) }
func (*ProcessorCoreUnion) ProtoMessage()    {}
func (*ProcessorCoreUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7eecd35e2274091, []int{1}
}
func (m *ProcessorCoreUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessorCoreUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProcessorCoreUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessorCoreUnion.Merge(m, src)
}
func (m *ProcessorCoreUnion) XXX_Size() int {
	return m.Size()
}
func (m *ProcessorCoreUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessorCoreUnion.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessorCoreUnion proto.InternalMessageInfo

// NoopCoreSpec indicates a "no-op" processor core. This is used when we just
// need post-processing or when only a synchronizer is required (e.g. at the
// final endpoint).
type NoopCoreSpec struct {
}

func (m *NoopCoreSpec) Reset()         { *m = NoopCoreSpec{} }
func (m *NoopCoreSpec) String() string { return proto.CompactTextString(m) }
func (*NoopCoreSpec) ProtoMessage()    {}
func (*NoopCoreSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7eecd35e2274091, []int{2}
}
func (m *NoopCoreSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NoopCoreSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NoopCoreSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoopCoreSpec.Merge(m, src)
}
func (m *NoopCoreSpec) XXX_Size() int {
	return m.Size()
}
func (m *NoopCoreSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NoopCoreSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NoopCoreSpec proto.InternalMessageInfo

// LocalPlanNodeSpec is the specification for a local planNode wrapping
// processor. It's created for situations where a planNode has no DistSQL
// processor equivalent, and constrains the plan to live on the gateway node.
// This spec contains just an index, which is used by the execution engine to
// find the planNode instance this processor is executing in an array of local
// planNodes. See LocalProcessors and LocalProcessorIndexes on
// distsqlplan.PhysicalPlan.
type LocalPlanNodeSpec struct {
	RowSourceIdx uint32 `protobuf:"varint,1,opt,name=RowSourceIdx" json:"RowSourceIdx"`
	NumInputs    uint32 `protobuf:"varint,2,opt,name=NumInputs" json:"NumInputs"`
	Name         string `protobuf:"bytes,3,opt,name=Name" json:"Name"`
}

func (m *LocalPlanNodeSpec) Reset()         { *m = LocalPlanNodeSpec{} }
func (m *LocalPlanNodeSpec) String() string { return proto.CompactTextString(m) }
func (*LocalPlanNodeSpec) ProtoMessage()    {}
func (*LocalPlanNodeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7eecd35e2274091, []int{3}
}
func (m *LocalPlanNodeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalPlanNodeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalPlanNodeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalPlanNodeSpec.Merge(m, src)
}
func (m *LocalPlanNodeSpec) XXX_Size() int {
	return m.Size()
}
func (m *LocalPlanNodeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalPlanNodeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LocalPlanNodeSpec proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ProcessorSpec)(nil), "cockroach.sql.distsqlrun.ProcessorSpec")
	proto.RegisterType((*ProcessorCoreUnion)(nil), "cockroach.sql.distsqlrun.ProcessorCoreUnion")
	proto.RegisterType((*NoopCoreSpec)(nil), "cockroach.sql.distsqlrun.NoopCoreSpec")
	proto.RegisterType((*LocalPlanNodeSpec)(nil), "cockroach.sql.distsqlrun.LocalPlanNodeSpec")
}

func init() { proto.RegisterFile("sql/execinfrapb/processors.proto", fileDescriptor_d7eecd35e2274091) }

var fileDescriptor_d7eecd35e2274091 = []byte{
	// 1269 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x97, 0xdd, 0x72, 0xd3, 0x46,
	0x1b, 0xc7, 0xe3, 0x37, 0x22, 0x31, 0x6b, 0x87, 0x98, 0x4d, 0x78, 0xd9, 0xa6, 0xad, 0x63, 0x5c,
	0x3e, 0x5c, 0x0a, 0x66, 0x4a, 0x3f, 0x0e, 0x98, 0x76, 0x0a, 0x76, 0xca, 0x60, 0x97, 0x06, 0x2a,
	0xbb, 0x65, 0x86, 0x13, 0xcf, 0x46, 0xda, 0x28, 0x02, 0x59, 0x2b, 0x76, 0x57, 0x38, 0xd0, 0xd3,
	0x5e, 0x40, 0x2f, 0xa1, 0x97, 0x93, 0x43, 0x0e, 0x39, 0x62, 0xda, 0x30, 0xbd, 0x8f, 0xce, 0xee,
	0xea, 0xcb, 0x0a, 0x96, 0x72, 0xe2, 0x91, 0x57, 0xff, 0xff, 0x4f, 0xbb, 0xcf, 0xf3, 0xec, 0xa3,
	0x15, 0x68, 0xf1, 0x17, 0xde, 0x2d, 0x72, 0x48, 0x2c, 0xd7, 0xdf, 0x67, 0x38, 0xd8, 0xbb, 0x15,
	0x30, 0x6a, 0x11, 0xce, 0x29, 0xe3, 0xdd, 0x80, 0x51, 0x41, 0x21, 0xb2, 0xa8, 0xf5, 0x9c, 0x51,
	0x6c, 0x1d, 0x74, 0xf9, 0x0b, 0xaf, 0x6b, 0xbb, 0x5c, 0xf0, 0x17, 0x1e, 0x0b, 0xfd, 0xad, 0xad,
	0xbc, 0xd7, 0xc6, 0x02, 0x6b, 0xd7, 0xd6, 0x95, 0xc5, 0xdc, 0xc9, 0x1e, 0xe6, 0x24, 0x92, 0x5d,
	0x2e, 0x90, 0xc9, 0xa7, 0x95, 0xab, 0x84, 0x88, 0x55, 0x9d, 0xa2, 0x47, 0x86, 0xde, 0xf3, 0x89,
	0x4b, 0x23, 0xe5, 0x8d, 0x02, 0xa5, 0x75, 0x80, 0x7d, 0x87, 0xec, 0x13, 0x62, 0xf3, 0x53, 0xa8,
	0x05, 0xde, 0xf3, 0xc8, 0x84, 0x0b, 0x2c, 0x62, 0xf5, 0x05, 0xa9, 0x16, 0xaf, 0x02, 0xc2, 0xf5,
	0x6f, 0x34, 0xbc, 0xe9, 0x50, 0x87, 0xaa, 0xcb, 0x5b, 0xf2, 0x4a, 0x8f, 0xb6, 0xff, 0x30, 0xc0,
	0xda, 0xe3, 0x98, 0x36, 0x0a, 0x88, 0x05, 0xfb, 0xe0, 0x8c, 0xeb, 0x07, 0xa1, 0x40, 0x95, 0xd6,
	0x72, 0xa7, 0x76, 0xfb, 0x5a, 0x77, 0x51, 0xf4, 0xbb, 0x03, 0x29, 0x1b, 0xbd, 0xf2, 0x2d, 0xe9,
	0xeb, 0x19, 0x47, 0xef, 0xb6, 0x97, 0x4c, 0xed, 0x85, 0xf7, 0x81, 0x61, 0x51, 0x46, 0xd0, 0xff,
	0x5a, 0x95, 0x4e, 0xed, 0xf6, 0x8d, 0xc5, 0x8c, 0xe4, 0xd9, 0x7d, 0xca, 0xc8, 0xaf, 0xbe, 0x4b,
	0xfd, 0x08, 0xa4, 0xfc, 0xb0, 0x0f, 0x8c, 0x80, 0x72, 0x81, 0x0c, 0xc5, 0xf9, 0xbc, 0x80, 0x43,
	0xb9, 0x88, 0x58, 0x99, 0xd9, 0x28, 0x33, 0x7c, 0x00, 0x56, 0x68, 0x28, 0xe4, 0x92, 0x96, 0xd5,
	0x92, 0xae, 0x2f, 0xc6, 0x3c, 0x52, 0x3a, 0x93, 0x86, 0x82, 0xb0, 0x0c, 0x27, 0xf2, 0xc3, 0xeb,
	0xa0, 0xca, 0x05, 0x76, 0xc8, 0xc4, 0xb5, 0xd1, 0x99, 0x56, 0xa5, 0x73, 0xa6, 0xb7, 0x2e, 0xef,
	0x1f, 0xbf, 0xdb, 0x5e, 0x1d, 0xc9, 0xf1, 0xc1, 0x8e, 0xb9, 0xaa, 0x04, 0x03, 0x1b, 0x7e, 0x0b,
	0xea, 0x49, 0x9a, 0xa4, 0x7e, 0x45, 0xe9, 0x37, 0x22, 0x7d, 0x2d, 0x59, 0xf8, 0x60, 0xc7, 0xac,
	0x25, 0xc2, 0x81, 0x0d, 0xbf, 0x07, 0x75, 0x46, 0x78, 0xe8, 0x89, 0x89, 0xca, 0x1e, 0x5a, 0x55,
	0x73, 0xde, 0xca, 0xcd, 0x99, 0x93, 0x69, 0x57, 0x67, 0x77, 0x6c, 0xd6, 0xb4, 0x7e, 0x2c, 0xff,
	0xc2, 0xaf, 0xc1, 0x06, 0xe1, 0xc2, 0x9d, 0x62, 0x41, 0xec, 0x09, 0xa3, 0xb3, 0x89, 0x45, 0x43,
	0x5f, 0xa0, 0x6a, 0xab, 0xd2, 0x31, 0xa2, 0xd5, 0x9c, 0x4f, 0x04, 0x26, 0x9d, 0xf5, 0xe5, 0xed,
	0xf6, 0xbf, 0x9b, 0x00, 0x9e, 0x4c, 0x05, 0xbc, 0x03, 0x0c, 0x9f, 0xd2, 0x00, 0x55, 0x54, 0xf8,
	0xaf, 0x2e, 0x8e, 0xdb, 0x2e, 0xa5, 0x81, 0xb4, 0xc9, 0x98, 0x99, 0xca, 0x03, 0x7f, 0x02, 0x35,
	0x55, 0x9b, 0x26, 0xc1, 0x36, 0x61, 0x51, 0x25, 0x14, 0x64, 0x70, 0x9c, 0x8a, 0x15, 0x25, 0xeb,
	0x86, 0x0f, 0x00, 0x78, 0x46, 0x5d, 0x3f, 0x62, 0x2d, 0x2b, 0x56, 0x67, 0x31, 0x6b, 0x98, 0x68,
	0x15, 0x2a, 0xe3, 0x85, 0xdf, 0x81, 0x15, 0x4e, 0x99, 0x20, 0x2c, 0xaa, 0xa9, 0xcb, 0x8b, 0x29,
	0x23, 0xa5, 0x53, 0x84, 0xc8, 0x23, 0xe7, 0x81, 0x1d, 0x87, 0x11, 0x07, 0x0b, 0xca, 0x54, 0x09,
	0x14, 0xce, 0xe3, 0x5e, 0xa2, 0xd5, 0xf3, 0x48, 0xbd, 0xb0, 0x07, 0xaa, 0x52, 0xe8, 0xfa, 0x96,
	0x40, 0xab, 0x65, 0xe1, 0xdd, 0x89, 0x94, 0x8a, 0x92, 0xf8, 0x64, 0x88, 0xa7, 0x84, 0x39, 0x44,
	0x2e, 0x97, 0x30, 0x95, 0xe3, 0xc2, 0x10, 0xff, 0x9c, 0x8a, 0x75, 0x88, 0x33, 0x6e, 0xb9, 0xb4,
	0x03, 0xcc, 0x0f, 0x22, 0xd6, 0xd9, 0xb2, 0xa5, 0x3d, 0x48, 0xb4, 0x7a, 0x69, 0xa9, 0x17, 0xde,
	0x05, 0x2b, 0x2f, 0xb1, 0x17, 0x12, 0x8e, 0x40, 0x19, 0xe5, 0x37, 0xa5, 0x4b, 0x2a, 0x27, 0xf2,
	0xc9, 0xb9, 0xec, 0x61, 0xeb, 0xf9, 0xbe, 0xeb, 0x79, 0x84, 0xa1, 0x5a, 0x19, 0xa5, 0x97, 0x68,
	0xf5, 0x5c, 0x52, 0x2f, 0x7c, 0x08, 0x00, 0x23, 0xd8, 0x1e, 0x4c, 0x03, 0xca, 0x04, 0x5a, 0x2b,
	0x6b, 0x47, 0x66, 0xa2, 0xdd, 0xc1, 0x02, 0x6b, 0x5a, 0xea, 0x87, 0x3f, 0x80, 0xd5, 0x11, 0x9e,
	0x06, 0x72, 0x52, 0xeb, 0x0a, 0x75, 0xa5, 0xa0, 0x7a, 0xb4, 0x50, 0x31, 0x62, 0x17, 0x7c, 0x0a,
	0x1a, 0xfa, 0x32, 0xad, 0x0c, 0xd4, 0x50, 0xa4, 0x6e, 0x19, 0x29, 0x57, 0x4b, 0x27, 0x38, 0x70,
	0x17, 0xd4, 0x5f, 0xbb, 0xce, 0x6b, 0xec, 0x44, 0x29, 0xbc, 0xa0, 0xb8, 0x05, 0xcd, 0xee, 0x69,
	0x46, 0xad, 0x98, 0x73, 0x7e, 0x99, 0x84, 0x80, 0xd1, 0x67, 0xc4, 0x12, 0x23, 0x22, 0xd0, 0xff,
	0xcb, 0x92, 0xf0, 0x38, 0xd1, 0xea, 0xb0, 0xa5, 0x5e, 0x59, 0xeb, 0x33, 0xd7, 0xb7, 0xe9, 0x8c,
	0x30, 0x74, 0xb1, 0xac, 0xd6, 0x9f, 0x44, 0x4a, 0x5d, 0xeb, 0xb1, 0x0f, 0xfe, 0x02, 0xd6, 0x3c,
	0x6a, 0x61, 0xef, 0xb1, 0x87, 0xfd, 0x5d, 0x6a, 0x13, 0x84, 0x14, 0xe8, 0x8b, 0xc5, 0xa0, 0x87,
	0x59, 0xb9, 0xa2, 0xcd, 0x13, 0x64, 0x32, 0xf4, 0xbb, 0x36, 0x93, 0x8c, 0x8f, 0xca, 0x92, 0xd1,
	0xcf, 0x39, 0x74, 0x32, 0xf2, 0x1c, 0x38, 0x06, 0xe7, 0xf4, 0xd8, 0x7d, 0x46, 0x7d, 0xe1, 0x12,
	0x86, 0xb6, 0xca, 0x6a, 0xaf, 0x3f, 0xa7, 0x57, 0xdc, 0x1c, 0x43, 0xa6, 0x84, 0x32, 0xdb, 0xf5,
	0xb1, 0xe7, 0x8a, 0x57, 0xe8, 0xe3, 0xb2, 0x94, 0x3c, 0x4a, 0xb4, 0x3a, 0x25, 0xa9, 0x57, 0x86,
	0x53, 0x9e, 0x48, 0x4c, 0x3a, 0x7b, 0xc2, 0x5c, 0xd9, 0x0d, 0x3f, 0x29, 0x0b, 0x67, 0x2f, 0x2b,
	0xd7, 0xe1, 0x9c, 0x23, 0xc8, 0x70, 0xba, 0xfe, 0x4b, 0xc2, 0x04, 0xb1, 0xef, 0xbb, 0x9e, 0x20,
	0x8c, 0x30, 0xf4, 0x69, 0x59, 0x38, 0x07, 0x39, 0x87, 0x0e, 0x67, 0x9e, 0x23, 0xc3, 0x19, 0x8f,
	0x45, 0xd5, 0xdd, 0x2c, 0x0b, 0xe7, 0x60, 0x4e, 0xaf, 0xc3, 0x39, 0xcf, 0x88, 0xdb, 0x4c, 0x18,
	0xc8, 0xcd, 0x8e, 0xb6, 0x4f, 0xd3, 0x66, 0xb4, 0x36, 0x6d, 0x33, 0xfa, 0x3f, 0x7c, 0x02, 0xd6,
	0x79, 0xe0, 0xb9, 0xe2, 0x9e, 0x6f, 0x8f, 0x2c, 0x2c, 0x64, 0x40, 0x5b, 0x0a, 0x77, 0xb3, 0x60,
	0x5b, 0xcf, 0x1b, 0x14, 0x33, 0x4f, 0x91, 0x2d, 0x9e, 0x11, 0x2e, 0x28, 0x23, 0x6a, 0x8e, 0x97,
	0xca, 0x5a, 0xbc, 0x99, 0x8a, 0x75, 0x8b, 0xcf, 0xb8, 0xe5, 0x3e, 0xdc, 0x8f, 0x33, 0xd3, 0x2e,
	0xdb, 0x87, 0x73, 0x19, 0x49, 0x7c, 0xd0, 0x02, 0x1b, 0x5c, 0x30, 0x82, 0xa7, 0x03, 0xdf, 0x91,
	0xe7, 0x08, 0xea, 0xab, 0x89, 0x7d, 0xa6, 0x70, 0x5f, 0x16, 0xac, 0xf6, 0xa4, 0x49, 0x91, 0x3f,
	0x44, 0x83, 0x14, 0x5c, 0xcc, 0x0d, 0x27, 0xdb, 0xe8, 0xb2, 0x7a, 0xd0, 0x37, 0xa7, 0x7e, 0xd0,
	0xdc, 0x7e, 0x5a, 0x44, 0x85, 0x77, 0x41, 0x95, 0x1c, 0x06, 0xfa, 0x5c, 0x70, 0xa5, 0xec, 0x5c,
	0xf0, 0xa3, 0x52, 0xea, 0xb8, 0xc4, 0x2e, 0x19, 0x17, 0xd7, 0xb7, 0xc9, 0x61, 0xfc, 0x2e, 0x52,
	0xef, 0x5a, 0x86, 0xae, 0x96, 0xc5, 0x65, 0x70, 0xd2, 0xa4, 0xe3, 0xf2, 0x01, 0x1a, 0xfc, 0x0a,
	0x2c, 0x0b, 0xe1, 0xa1, 0x6b, 0x0a, 0x7a, 0xa9, 0xe0, 0x2c, 0x35, 0x7e, 0xa8, 0x20, 0x52, 0xad,
	0xda, 0x9c, 0x47, 0x43, 0x7b, 0x24, 0x28, 0xc3, 0x0e, 0x19, 0x13, 0x2e, 0xd0, 0xf5, 0xd2, 0x36,
	0x97, 0x73, 0x44, 0x6d, 0x2e, 0x37, 0x7a, 0xc7, 0x38, 0xfa, 0x6b, 0xbb, 0x32, 0x34, 0xaa, 0x2b,
	0x8d, 0xd5, 0xa1, 0x51, 0xad, 0x37, 0xd6, 0x86, 0x46, 0xf5, 0x5c, 0x63, 0x7d, 0x68, 0x54, 0xcf,
	0x37, 0xe0, 0xd0, 0xa8, 0xc2, 0xc6, 0xc6, 0xd0, 0xa8, 0x6e, 0x34, 0x36, 0x87, 0x46, 0x75, 0xb3,
	0x71, 0xa1, 0x7d, 0x0e, 0xd4, 0xb3, 0x47, 0xc5, 0xf6, 0xef, 0xe0, 0xfc, 0x89, 0x36, 0x0d, 0x3b,
	0xa0, 0x6e, 0xd2, 0xd9, 0x88, 0x86, 0xcc, 0x22, 0x03, 0xfb, 0x50, 0x9d, 0x3e, 0xd7, 0xa2, 0xb3,
	0xeb, 0xdc, 0x1d, 0xd8, 0x06, 0x67, 0x77, 0xc3, 0xa9, 0xfa, 0x0e, 0xe1, 0xea, 0x84, 0x19, 0xcb,
	0xd2, 0x61, 0x88, 0x80, 0xb1, 0x8b, 0xa7, 0x44, 0x1d, 0x1a, 0xcf, 0xc6, 0xdf, 0x05, 0x72, 0xa4,
	0x77, 0xf3, 0xe8, 0x9f, 0xe6, 0xd2, 0xd1, 0x71, 0xb3, 0xf2, 0xe6, 0xb8, 0x59, 0x79, 0x7b, 0xdc,
	0xac, 0xfc, 0x7d, 0xdc, 0xac, 0xfc, 0xf9, 0xbe, 0xb9, 0xf4, 0xe6, 0x7d, 0x73, 0xe9, 0xed, 0xfb,
	0xe6, 0xd2, 0xd3, 0x5a, 0xe6, 0xa3, 0xeb, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x70, 0xc7, 0xc4,
	0x6f, 0xa9, 0x0e, 0x00, 0x00,
}

func (m *ProcessorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessors(dAtA, i, uint64(m.EstimatedRowCount))
	i--
	dAtA[i] = 0x40
	if len(m.ResultTypes) > 0 {
		for iNdEx := len(m.ResultTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResultTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessors(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	i = encodeVarintProcessors(dAtA, i, uint64(m.ProcessorID))
	i--
	dAtA[i] = 0x30
	i = encodeVarintProcessors(dAtA, i, uint64(m.StageID))
	i--
	dAtA[i] = 0x28
	{
		size, err := m.Post.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Output) > 0 {
		for iNdEx := len(m.Output) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Output[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessors(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.Core.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessors(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Input) > 0 {
		for iNdEx := len(m.Input) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Input[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessors(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProcessorCoreUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessorCoreUnion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessorCoreUnion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudStorageTest != nil {
		{
			size, err := m.CloudStorageTest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if m.Ttl != nil {
		{
			size, err := m.Ttl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.IndexBackfillMerger != nil {
		{
			size, err := m.IndexBackfillMerger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.Exporter != nil {
		{
			size, err := m.Exporter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.StreamIngestionFrontier != nil {
		{
			size, err := m.StreamIngestionFrontier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.StreamIngestionData != nil {
		{
			size, err := m.StreamIngestionData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.Filterer != nil {
		{
			size, err := m.Filterer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.RestoreData != nil {
		{
			size, err := m.RestoreData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.SplitAndScatter != nil {
		{
			size, err := m.SplitAndScatter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.BackupData != nil {
		{
			size, err := m.BackupData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.InvertedJoiner != nil {
		{
			size, err := m.InvertedJoiner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.InvertedFilterer != nil {
		{
			size, err := m.InvertedFilterer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.BulkRowWriter != nil {
		{
			size, err := m.BulkRowWriter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.Ordinality != nil {
		{
			size, err := m.Ordinality.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.ChangeFrontier != nil {
		{
			size, err := m.ChangeFrontier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.ChangeAggregator != nil {
		{
			size, err := m.ChangeAggregator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.LocalPlanNode != nil {
		{
			size, err := m.LocalPlanNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Windower != nil {
		{
			size, err := m.Windower.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.ProjectSet != nil {
		{
			size, err := m.ProjectSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ZigzagJoiner != nil {
		{
			size, err := m.ZigzagJoiner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.SampleAggregator != nil {
		{
			size, err := m.SampleAggregator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Sampler != nil {
		{
			size, err := m.Sampler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ReadImport != nil {
		{
			size, err := m.ReadImport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Backfiller != nil {
		{
			size, err := m.Backfiller.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Values != nil {
		{
			size, err := m.Values.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.HashJoiner != nil {
		{
			size, err := m.HashJoiner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.MergeJoiner != nil {
		{
			size, err := m.MergeJoiner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Distinct != nil {
		{
			size, err := m.Distinct.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Aggregator != nil {
		{
			size, err := m.Aggregator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Sorter != nil {
		{
			size, err := m.Sorter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.JoinReader != nil {
		{
			size, err := m.JoinReader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TableReader != nil {
		{
			size, err := m.TableReader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Noop != nil {
		{
			size, err := m.Noop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessors(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NoopCoreSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoopCoreSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NoopCoreSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LocalPlanNodeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalPlanNodeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalPlanNodeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintProcessors(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintProcessors(dAtA, i, uint64(m.NumInputs))
	i--
	dAtA[i] = 0x10
	i = encodeVarintProcessors(dAtA, i, uint64(m.RowSourceIdx))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintProcessors(dAtA []byte, offset int, v uint64) int {
	offset -= sovProcessors(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProcessorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Input) > 0 {
		for _, e := range m.Input {
			l = e.Size()
			n += 1 + l + sovProcessors(uint64(l))
		}
	}
	l = m.Core.Size()
	n += 1 + l + sovProcessors(uint64(l))
	if len(m.Output) > 0 {
		for _, e := range m.Output {
			l = e.Size()
			n += 1 + l + sovProcessors(uint64(l))
		}
	}
	l = m.Post.Size()
	n += 1 + l + sovProcessors(uint64(l))
	n += 1 + sovProcessors(uint64(m.StageID))
	n += 1 + sovProcessors(uint64(m.ProcessorID))
	if len(m.ResultTypes) > 0 {
		for _, e := range m.ResultTypes {
			l = e.Size()
			n += 1 + l + sovProcessors(uint64(l))
		}
	}
	n += 1 + sovProcessors(uint64(m.EstimatedRowCount))
	return n
}

func (m *ProcessorCoreUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Noop != nil {
		l = m.Noop.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.TableReader != nil {
		l = m.TableReader.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.JoinReader != nil {
		l = m.JoinReader.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Sorter != nil {
		l = m.Sorter.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Aggregator != nil {
		l = m.Aggregator.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Distinct != nil {
		l = m.Distinct.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.MergeJoiner != nil {
		l = m.MergeJoiner.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.HashJoiner != nil {
		l = m.HashJoiner.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Values != nil {
		l = m.Values.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Backfiller != nil {
		l = m.Backfiller.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.ReadImport != nil {
		l = m.ReadImport.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.Sampler != nil {
		l = m.Sampler.Size()
		n += 1 + l + sovProcessors(uint64(l))
	}
	if m.SampleAggregator != nil {
		l = m.SampleAggregator.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.ZigzagJoiner != nil {
		l = m.ZigzagJoiner.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.ProjectSet != nil {
		l = m.ProjectSet.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.Windower != nil {
		l = m.Windower.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.LocalPlanNode != nil {
		l = m.LocalPlanNode.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.ChangeAggregator != nil {
		l = m.ChangeAggregator.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.ChangeFrontier != nil {
		l = m.ChangeFrontier.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.Ordinality != nil {
		l = m.Ordinality.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.BulkRowWriter != nil {
		l = m.BulkRowWriter.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.InvertedFilterer != nil {
		l = m.InvertedFilterer.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.InvertedJoiner != nil {
		l = m.InvertedJoiner.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.BackupData != nil {
		l = m.BackupData.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.SplitAndScatter != nil {
		l = m.SplitAndScatter.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.RestoreData != nil {
		l = m.RestoreData.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.Filterer != nil {
		l = m.Filterer.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.StreamIngestionData != nil {
		l = m.StreamIngestionData.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.StreamIngestionFrontier != nil {
		l = m.StreamIngestionFrontier.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.Exporter != nil {
		l = m.Exporter.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.IndexBackfillMerger != nil {
		l = m.IndexBackfillMerger.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.Ttl != nil {
		l = m.Ttl.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	if m.CloudStorageTest != nil {
		l = m.CloudStorageTest.Size()
		n += 2 + l + sovProcessors(uint64(l))
	}
	return n
}

func (m *NoopCoreSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LocalPlanNodeSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessors(uint64(m.RowSourceIdx))
	n += 1 + sovProcessors(uint64(m.NumInputs))
	l = len(m.Name)
	n += 1 + l + sovProcessors(uint64(l))
	return n
}

func sovProcessors(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProcessors(x uint64) (n int) {
	return sovProcessors(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ProcessorCoreUnion) GetValue() interface{} {
	if this.Noop != nil {
		return this.Noop
	}
	if this.TableReader != nil {
		return this.TableReader
	}
	if this.JoinReader != nil {
		return this.JoinReader
	}
	if this.Sorter != nil {
		return this.Sorter
	}
	if this.Aggregator != nil {
		return this.Aggregator
	}
	if this.Distinct != nil {
		return this.Distinct
	}
	if this.MergeJoiner != nil {
		return this.MergeJoiner
	}
	if this.HashJoiner != nil {
		return this.HashJoiner
	}
	if this.Values != nil {
		return this.Values
	}
	if this.Backfiller != nil {
		return this.Backfiller
	}
	if this.ReadImport != nil {
		return this.ReadImport
	}
	if this.Sampler != nil {
		return this.Sampler
	}
	if this.SampleAggregator != nil {
		return this.SampleAggregator
	}
	if this.ZigzagJoiner != nil {
		return this.ZigzagJoiner
	}
	if this.ProjectSet != nil {
		return this.ProjectSet
	}
	if this.Windower != nil {
		return this.Windower
	}
	if this.LocalPlanNode != nil {
		return this.LocalPlanNode
	}
	if this.ChangeAggregator != nil {
		return this.ChangeAggregator
	}
	if this.ChangeFrontier != nil {
		return this.ChangeFrontier
	}
	if this.Ordinality != nil {
		return this.Ordinality
	}
	if this.BulkRowWriter != nil {
		return this.BulkRowWriter
	}
	if this.InvertedFilterer != nil {
		return this.InvertedFilterer
	}
	if this.InvertedJoiner != nil {
		return this.InvertedJoiner
	}
	if this.BackupData != nil {
		return this.BackupData
	}
	if this.SplitAndScatter != nil {
		return this.SplitAndScatter
	}
	if this.RestoreData != nil {
		return this.RestoreData
	}
	if this.Filterer != nil {
		return this.Filterer
	}
	if this.StreamIngestionData != nil {
		return this.StreamIngestionData
	}
	if this.StreamIngestionFrontier != nil {
		return this.StreamIngestionFrontier
	}
	if this.Exporter != nil {
		return this.Exporter
	}
	if this.IndexBackfillMerger != nil {
		return this.IndexBackfillMerger
	}
	if this.Ttl != nil {
		return this.Ttl
	}
	if this.CloudStorageTest != nil {
		return this.CloudStorageTest
	}
	return nil
}

func (this *ProcessorCoreUnion) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *NoopCoreSpec:
		this.Noop = vt
	case *TableReaderSpec:
		this.TableReader = vt
	case *JoinReaderSpec:
		this.JoinReader = vt
	case *SorterSpec:
		this.Sorter = vt
	case *AggregatorSpec:
		this.Aggregator = vt
	case *DistinctSpec:
		this.Distinct = vt
	case *MergeJoinerSpec:
		this.MergeJoiner = vt
	case *HashJoinerSpec:
		this.HashJoiner = vt
	case *ValuesCoreSpec:
		this.Values = vt
	case *BackfillerSpec:
		this.Backfiller = vt
	case *ReadImportDataSpec:
		this.ReadImport = vt
	case *SamplerSpec:
		this.Sampler = vt
	case *SampleAggregatorSpec:
		this.SampleAggregator = vt
	case *ZigzagJoinerSpec:
		this.ZigzagJoiner = vt
	case *ProjectSetSpec:
		this.ProjectSet = vt
	case *WindowerSpec:
		this.Windower = vt
	case *LocalPlanNodeSpec:
		this.LocalPlanNode = vt
	case *ChangeAggregatorSpec:
		this.ChangeAggregator = vt
	case *ChangeFrontierSpec:
		this.ChangeFrontier = vt
	case *OrdinalitySpec:
		this.Ordinality = vt
	case *BulkRowWriterSpec:
		this.BulkRowWriter = vt
	case *InvertedFiltererSpec:
		this.InvertedFilterer = vt
	case *InvertedJoinerSpec:
		this.InvertedJoiner = vt
	case *BackupDataSpec:
		this.BackupData = vt
	case *SplitAndScatterSpec:
		this.SplitAndScatter = vt
	case *RestoreDataSpec:
		this.RestoreData = vt
	case *FiltererSpec:
		this.Filterer = vt
	case *StreamIngestionDataSpec:
		this.StreamIngestionData = vt
	case *StreamIngestionFrontierSpec:
		this.StreamIngestionFrontier = vt
	case *ExportSpec:
		this.Exporter = vt
	case *IndexBackfillMergerSpec:
		this.IndexBackfillMerger = vt
	case *TTLSpec:
		this.Ttl = vt
	case *CloudStorageTestSpec:
		this.CloudStorageTest = vt
	default:
		return false
	}
	return true
}
func (m *ProcessorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input, InputSyncSpec{})
			if err := m.Input[len(m.Input)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Core.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output, OutputRouterSpec{})
			if err := m.Output[len(m.Output)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Post.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageID", wireType)
			}
			m.StageID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StageID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessorID", wireType)
			}
			m.ProcessorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessorID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultTypes = append(m.ResultTypes, &types.T{})
			if err := m.ResultTypes[len(m.ResultTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedRowCount", wireType)
			}
			m.EstimatedRowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedRowCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessorCoreUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorCoreUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorCoreUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Noop == nil {
				m.Noop = &NoopCoreSpec{}
			}
			if err := m.Noop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableReader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableReader == nil {
				m.TableReader = &TableReaderSpec{}
			}
			if err := m.TableReader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinReader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JoinReader == nil {
				m.JoinReader = &JoinReaderSpec{}
			}
			if err := m.JoinReader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sorter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sorter == nil {
				m.Sorter = &SorterSpec{}
			}
			if err := m.Sorter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggregator == nil {
				m.Aggregator = &AggregatorSpec{}
			}
			if err := m.Aggregator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Distinct == nil {
				m.Distinct = &DistinctSpec{}
			}
			if err := m.Distinct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeJoiner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MergeJoiner == nil {
				m.MergeJoiner = &MergeJoinerSpec{}
			}
			if err := m.MergeJoiner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashJoiner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashJoiner == nil {
				m.HashJoiner = &HashJoinerSpec{}
			}
			if err := m.HashJoiner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = &ValuesCoreSpec{}
			}
			if err := m.Values.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backfiller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Backfiller == nil {
				m.Backfiller = &BackfillerSpec{}
			}
			if err := m.Backfiller.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadImport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadImport == nil {
				m.ReadImport = &ReadImportDataSpec{}
			}
			if err := m.ReadImport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sampler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sampler == nil {
				m.Sampler = &SamplerSpec{}
			}
			if err := m.Sampler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleAggregator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SampleAggregator == nil {
				m.SampleAggregator = &SampleAggregatorSpec{}
			}
			if err := m.SampleAggregator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZigzagJoiner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZigzagJoiner == nil {
				m.ZigzagJoiner = &ZigzagJoinerSpec{}
			}
			if err := m.ZigzagJoiner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProjectSet == nil {
				m.ProjectSet = &ProjectSetSpec{}
			}
			if err := m.ProjectSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Windower == nil {
				m.Windower = &WindowerSpec{}
			}
			if err := m.Windower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPlanNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalPlanNode == nil {
				m.LocalPlanNode = &LocalPlanNodeSpec{}
			}
			if err := m.LocalPlanNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeAggregator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeAggregator == nil {
				m.ChangeAggregator = &ChangeAggregatorSpec{}
			}
			if err := m.ChangeAggregator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeFrontier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeFrontier == nil {
				m.ChangeFrontier = &ChangeFrontierSpec{}
			}
			if err := m.ChangeFrontier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ordinality == nil {
				m.Ordinality = &OrdinalitySpec{}
			}
			if err := m.Ordinality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulkRowWriter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BulkRowWriter == nil {
				m.BulkRowWriter = &BulkRowWriterSpec{}
			}
			if err := m.BulkRowWriter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedFilterer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvertedFilterer == nil {
				m.InvertedFilterer = &InvertedFiltererSpec{}
			}
			if err := m.InvertedFilterer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedJoiner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvertedJoiner == nil {
				m.InvertedJoiner = &InvertedJoinerSpec{}
			}
			if err := m.InvertedJoiner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackupData == nil {
				m.BackupData = &BackupDataSpec{}
			}
			if err := m.BackupData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitAndScatter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitAndScatter == nil {
				m.SplitAndScatter = &SplitAndScatterSpec{}
			}
			if err := m.SplitAndScatter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RestoreData == nil {
				m.RestoreData = &RestoreDataSpec{}
			}
			if err := m.RestoreData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filterer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filterer == nil {
				m.Filterer = &FiltererSpec{}
			}
			if err := m.Filterer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamIngestionData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamIngestionData == nil {
				m.StreamIngestionData = &StreamIngestionDataSpec{}
			}
			if err := m.StreamIngestionData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamIngestionFrontier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamIngestionFrontier == nil {
				m.StreamIngestionFrontier = &StreamIngestionFrontierSpec{}
			}
			if err := m.StreamIngestionFrontier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exporter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exporter == nil {
				m.Exporter = &ExportSpec{}
			}
			if err := m.Exporter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexBackfillMerger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexBackfillMerger == nil {
				m.IndexBackfillMerger = &IndexBackfillMergerSpec{}
			}
			if err := m.IndexBackfillMerger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ttl == nil {
				m.Ttl = &TTLSpec{}
			}
			if err := m.Ttl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudStorageTest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudStorageTest == nil {
				m.CloudStorageTest = &CloudStorageTestSpec{}
			}
			if err := m.CloudStorageTest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoopCoreSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoopCoreSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoopCoreSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalPlanNodeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalPlanNodeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalPlanNodeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowSourceIdx", wireType)
			}
			m.RowSourceIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowSourceIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumInputs", wireType)
			}
			m.NumInputs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumInputs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessors
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessors(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessors
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessors
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProcessors
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProcessors
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProcessors
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProcessors        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessors          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProcessors = fmt.Errorf("proto: unexpected end of group")
)
