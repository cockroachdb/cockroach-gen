// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors_bulk_io.proto

// Beware! This package name must not be changed, even though it doesn't match
// the Go package name, because it defines the Protobuf message names which
// can't be changed without breaking backward compatibility.

package execinfrapb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	cloudpb "github.com/cockroachdb/cockroach/pkg/cloud/cloudpb"
	github_com_cockroachdb_cockroach_pkg_jobs_jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	github_com_cockroachdb_cockroach_pkg_security_username "github.com/cockroachdb/cockroach/pkg/security/username"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BackfillerSpec_Type int32

const (
	BackfillerSpec_Invalid BackfillerSpec_Type = 0
	BackfillerSpec_Column  BackfillerSpec_Type = 1
	BackfillerSpec_Index   BackfillerSpec_Type = 2
)

var BackfillerSpec_Type_name = map[int32]string{
	0: "Invalid",
	1: "Column",
	2: "Index",
}

var BackfillerSpec_Type_value = map[string]int32{
	"Invalid": 0,
	"Column":  1,
	"Index":   2,
}

func (x BackfillerSpec_Type) Enum() *BackfillerSpec_Type {
	p := new(BackfillerSpec_Type)
	*p = x
	return p
}

func (x BackfillerSpec_Type) String() string {
	return proto.EnumName(BackfillerSpec_Type_name, int32(x))
}

func (x *BackfillerSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BackfillerSpec_Type_value, data, "BackfillerSpec_Type")
	if err != nil {
		return err
	}
	*x = BackfillerSpec_Type(value)
	return nil
}

func (BackfillerSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{0, 0}
}

// BackfillerSpec is the specification for a "schema change backfiller".
// The created backfill processor runs a backfill for the first mutations in
// the table descriptor mutation list with the same mutation id and type.
// A backfiller processor performs KV operations to retrieve rows for a
// table and backfills the new indexes/columns contained in the table
// descriptor. It checkpoints its progress by updating the table
// descriptor in the database, and doesn't emit any rows nor support
// any post-processing.
type BackfillerSpec struct {
	// TODO(lidor): job_id is not needed when interoperability with 22.2 is
	// dropped, the new way to send the job tag is using 'job_tag' in the
	// SetupFlowRequest message.
	JobID int64                  `protobuf:"varint,13,opt,name=job_id,json=jobId" json:"job_id"`
	Type  BackfillerSpec_Type    `protobuf:"varint,1,opt,name=type,enum=cockroach.sql.distsqlrun.BackfillerSpec_Type" json:"type"`
	Table descpb.TableDescriptor `protobuf:"bytes,2,opt,name=table" json:"table"`
	Spans []roachpb.Span         `protobuf:"bytes,10,rep,name=spans" json:"spans"`
	// Run the backfill for approximately this duration.
	// The backfill will always process at least one backfill chunk.
	Duration time.Duration `protobuf:"varint,4,opt,name=duration,casttype=time.Duration" json:"duration"`
	// The backfill involves a complete table scan in chunks,
	// where each chunk is a transactional read of a set of rows
	// along with a backfill for the rows. This is the maximum number
	// of entries backfilled per chunk.
	ChunkSize int64 `protobuf:"varint,5,opt,name=chunk_size,json=chunkSize" json:"chunk_size"`
	// The column backfiller will run an update batch immediately
	// once its estimated byte size reaches UpdateChunkSizeThresholdBytes, if nonzero.
	UpdateChunkSizeThresholdBytes uint64 `protobuf:"varint,14,opt,name=update_chunk_size_threshold_bytes,json=updateChunkSizeThresholdBytes" json:"update_chunk_size_threshold_bytes"`
	// WriteAsOf is the time that the backfill entries should be written.
	// Note: Older nodes may also use this as the read time instead of readAsOf.
	WriteAsOf hlc.Timestamp `protobuf:"bytes,7,opt,name=writeAsOf" json:"writeAsOf"`
	// The timestamp to perform index backfill historical scans at.
	ReadAsOf hlc.Timestamp `protobuf:"bytes,9,opt,name=readAsOf" json:"readAsOf"`
	// IndexesToBackfill is the set of indexes to backfill. This is populated only
	// starting in 21.1, prior to that the implied index set are those containing
	// the mutation ID of the first mutation on the table descriptor.
	IndexesToBackfill []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,8,rep,name=indexes_to_backfill,json=indexesToBackfill,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"indexes_to_backfill,omitempty"`
	InitialSplits     int32                                                             `protobuf:"varint,11,opt,name=initial_splits,json=initialSplits" json:"initial_splits"`
	// WriteAtBatchTimestamp will write the SST MVCC timestamps at the batch
	// timestamp, even if the request gets pushed server-side. This ensures the
	// writes comply with the timestamp cache and closed timestamp. See also
	// AddSSTableRequest.SSTTimestampToRequestTimestamp.
	//
	// Note that older nodes do not respect this flag so callers should
	// check MVCCAddSSTable before setting this option.
	WriteAtBatchTimestamp bool `protobuf:"varint,12,opt,name=write_at_batch_timestamp,json=writeAtBatchTimestamp" json:"write_at_batch_timestamp"`
}

func (m *BackfillerSpec) Reset()         { *m = BackfillerSpec{} }
func (m *BackfillerSpec) String() string { return proto.CompactTextString(m) }
func (*BackfillerSpec) ProtoMessage()    {}
func (*BackfillerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{0}
}
func (m *BackfillerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackfillerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BackfillerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackfillerSpec.Merge(m, src)
}
func (m *BackfillerSpec) XXX_Size() int {
	return m.Size()
}
func (m *BackfillerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BackfillerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BackfillerSpec proto.InternalMessageInfo

// JobProgress identifies the job to report progress on. This reporting
// happens outside this package.
type JobProgress struct {
	JobID github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID `protobuf:"varint,1,opt,name=job_id,json=jobId,casttype=github.com/cockroachdb/cockroach/pkg/jobs/jobspb.JobID" json:"job_id"`
	// contribution is the percent of work of the total this processor will
	// process.
	Contribution float32 `protobuf:"fixed32,2,opt,name=contribution" json:"contribution"`
	// slot is the index into the job details for this processor's completion.
	Slot int32 `protobuf:"varint,3,opt,name=slot" json:"slot"`
}

func (m *JobProgress) Reset()         { *m = JobProgress{} }
func (m *JobProgress) String() string { return proto.CompactTextString(m) }
func (*JobProgress) ProtoMessage()    {}
func (*JobProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{1}
}
func (m *JobProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *JobProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobProgress.Merge(m, src)
}
func (m *JobProgress) XXX_Size() int {
	return m.Size()
}
func (m *JobProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_JobProgress.DiscardUnknown(m)
}

var xxx_messageInfo_JobProgress proto.InternalMessageInfo

type ReadImportDataSpec struct {
	// TODO(lidor): job_id is not needed when interoperability with 22.2 is
	// dropped, the new way to send the job tag is using 'job_tag' in the
	// SetupFlowRequest message.
	JobID  int64                `protobuf:"varint,19,opt,name=job_id,json=jobId" json:"job_id"`
	Format roachpb.IOFileFormat `protobuf:"bytes,8,opt,name=format" json:"format"`
	// sample_size is the rate at which to output rows, based on an input row's size.
	SampleSize int32 `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	// tables supports input formats that can read multiple tables. If it is
	// non-empty, the keys specify the names of tables for which the processor
	// should read and emit data (ignoring data for any other tables that is
	// present in the input).
	//
	// TODO(dt): If a key has a nil value, the schema for that table should be
	// determined from the input on-the-fly (e.g. by parsing a CREATE TABLE in a
	// dump file) and the processor should emit a key/value for the generated
	// TableDescriptor with the corresponding descriptor ID key. If tables is
	// empty (and table_desc above is not specified), the processor should read
	// all tables in the input, determining their schemas on the fly.
	Tables map[string]*ReadImportDataSpec_ImportTable `protobuf:"bytes,9,rep,name=tables" json:"tables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// uri is a cloud.ExternalStorage URI pointing to the CSV files to be
	// read. The map key must be unique across the entire IMPORT job.
	Uri map[int32]string `protobuf:"bytes,7,rep,name=uri" json:"uri,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// resume_pos specifies a map from an input ID to an offset in that
	// input from which the processing should continue.
	// The meaning of offset is specific to each processor.
	ResumePos              map[int32]int64 `protobuf:"bytes,14,rep,name=resume_pos,json=resumePos" json:"resume_pos,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Progress               JobProgress     `protobuf:"bytes,6,opt,name=progress" json:"progress"`
	SkipMissingForeignKeys bool            `protobuf:"varint,10,opt,name=skip_missing_foreign_keys,json=skipMissingForeignKeys" json:"skip_missing_foreign_keys"`
	// walltimeNanos is the MVCC time at which the created KVs will be written.
	WalltimeNanos int64 `protobuf:"varint,11,opt,name=walltimeNanos" json:"walltimeNanos"`
	// If set, specifies reader parallelism; 0 implies "use default".
	ReaderParallelism int32 `protobuf:"varint,13,opt,name=readerParallelism" json:"readerParallelism"`
	// User who initiated the import. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,15,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto"`
	Types     []*descpb.TypeDescriptor                                                `protobuf:"bytes,16,rep,name=types" json:"types,omitempty"`
	// If the database being imported into is a multi-region database, then this
	// field stores the databases' primary region.
	DatabasePrimaryRegion github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName `protobuf:"bytes,17,opt,name=database_primary_region,json=databasePrimaryRegion,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.RegionName" json:"database_primary_region"`
	InitialSplits         int32                                                             `protobuf:"varint,18,opt,name=initial_splits,json=initialSplits" json:"initial_splits"`
}

func (m *ReadImportDataSpec) Reset()         { *m = ReadImportDataSpec{} }
func (m *ReadImportDataSpec) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec) ProtoMessage()    {}
func (*ReadImportDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{2}
}
func (m *ReadImportDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReadImportDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec.Merge(m, src)
}
func (m *ReadImportDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec proto.InternalMessageInfo

type ReadImportDataSpec_ImportTable struct {
	Desc *descpb.TableDescriptor `protobuf:"bytes,1,opt,name=desc" json:"desc,omitempty"`
	// targetCols is used to store the target columns for each existing table
	// being imported into. These are the columns for which the processor should
	// read and emit data (ignoring data for any other tables or columns outside
	// of the targetCols, that is present in the input).
	TargetCols []string `protobuf:"bytes,2,rep,name=targetCols" json:"targetCols,omitempty"`
}

func (m *ReadImportDataSpec_ImportTable) Reset()         { *m = ReadImportDataSpec_ImportTable{} }
func (m *ReadImportDataSpec_ImportTable) String() string { return proto.CompactTextString(m) }
func (*ReadImportDataSpec_ImportTable) ProtoMessage()    {}
func (*ReadImportDataSpec_ImportTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{2, 0}
}
func (m *ReadImportDataSpec_ImportTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReadImportDataSpec_ImportTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.Merge(m, src)
}
func (m *ReadImportDataSpec_ImportTable) XXX_Size() int {
	return m.Size()
}
func (m *ReadImportDataSpec_ImportTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadImportDataSpec_ImportTable.DiscardUnknown(m)
}

var xxx_messageInfo_ReadImportDataSpec_ImportTable proto.InternalMessageInfo

// StreamIngestionPartitionSpec contains information about a partition and how
// to connect to it.
type StreamIngestionPartitionSpec struct {
	PartitionID       string         `protobuf:"bytes,1,opt,name=partition_id,json=partitionId" json:"partition_id"`
	SubscriptionToken string         `protobuf:"bytes,2,opt,name=subscription_token,json=subscriptionToken" json:"subscription_token"`
	Address           string         `protobuf:"bytes,3,opt,name=address" json:"address"`
	Spans             []roachpb.Span `protobuf:"bytes,4,rep,name=spans" json:"spans"`
}

func (m *StreamIngestionPartitionSpec) Reset()         { *m = StreamIngestionPartitionSpec{} }
func (m *StreamIngestionPartitionSpec) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionPartitionSpec) ProtoMessage()    {}
func (*StreamIngestionPartitionSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{3}
}
func (m *StreamIngestionPartitionSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionPartitionSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamIngestionPartitionSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionPartitionSpec.Merge(m, src)
}
func (m *StreamIngestionPartitionSpec) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionPartitionSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionPartitionSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionPartitionSpec proto.InternalMessageInfo

type StreamIngestionDataSpec struct {
	// StreamID is the ID of the stream (which is shared across the producer and consumer).
	StreamID uint64 `protobuf:"varint,5,opt,name=stream_id,json=streamId" json:"stream_id"`
	// PartitionSpecs maps partition IDs to their specifications.
	PartitionSpecs map[string]StreamIngestionPartitionSpec `protobuf:"bytes,6,rep,name=partition_specs,json=partitionSpecs" json:"partition_specs" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The processor will ingest events from StartTime onwards.
	StartTime hlc.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time"`
	// StreamAddress locate the stream so that a stream client can be initialized.
	StreamAddress string `protobuf:"bytes,3,opt,name=stream_address,json=streamAddress" json:"stream_address"`
	// JobID is the job ID of the stream ingestion job.
	JobID int64 `protobuf:"varint,4,opt,name=job_id,json=jobId" json:"job_id"`
	// The processor will rekey the tenant's keyspace to a new tenant based on 'tenant_rekey'.
	TenantRekey TenantRekey `protobuf:"bytes,9,opt,name=tenant_rekey,json=tenantRekey" json:"tenant_rekey"`
	// Checkpoint stores a set of resolved spans denoting completed progress.
	Checkpoint jobspb.StreamIngestionCheckpoint `protobuf:"bytes,10,opt,name=checkpoint" json:"checkpoint"`
}

func (m *StreamIngestionDataSpec) Reset()         { *m = StreamIngestionDataSpec{} }
func (m *StreamIngestionDataSpec) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionDataSpec) ProtoMessage()    {}
func (*StreamIngestionDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{4}
}
func (m *StreamIngestionDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamIngestionDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionDataSpec.Merge(m, src)
}
func (m *StreamIngestionDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionDataSpec proto.InternalMessageInfo

type StreamIngestionFrontierSpec struct {
	// HighWaterAtStart is set by the ingestion job when initializing the frontier
	// processor. It is used as sanity check by the frontier processor to ensure
	// that it does not receive updates at a timestamp lower than this field. This
	// consequently prevents the job progress from regressing during ingestion.
	HighWaterAtStart hlc.Timestamp `protobuf:"bytes,1,opt,name=high_water_at_start,json=highWaterAtStart" json:"high_water_at_start"`
	// TrackedSpans is the entire span set being watched. The spans do not really
	// represent KV spans but uniquely identify the partitions in the ingestion
	// stream. Once all the partitions in the ingestion stream have been resolved
	// at a certain timestamp, then it's safe to resolve the ingestion at that
	// timestamp.
	TrackedSpans []roachpb.Span `protobuf:"bytes,2,rep,name=tracked_spans,json=trackedSpans" json:"tracked_spans"`
	// Mapping between a source cluster partition ID and its subscribing sql instance ID
	// in the destination cluster. This describes the flow topology of the replication stream.
	SubscribingSQLInstances map[string]uint32 `protobuf:"bytes,6,rep,name=subscribing_sql_instances,json=subscribingSqlInstances" json:"subscribing_sql_instances" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// JobID is the job ID of the stream ingestion job.
	JobID int64 `protobuf:"varint,3,opt,name=job_id,json=jobId" json:"job_id"`
	// StreamID is the ID of the stream.
	StreamID uint64 `protobuf:"varint,4,opt,name=stream_id,json=streamId" json:"stream_id"`
	// Checkpoint stores a set of resolved spans denoting completed progress
	Checkpoint jobspb.StreamIngestionCheckpoint `protobuf:"bytes,7,opt,name=checkpoint" json:"checkpoint"`
	// StreamAddresses are the addresses that can be connected to to interact with the source job
	StreamAddresses []string `protobuf:"bytes,8,rep,name=stream_addresses,json=streamAddresses" json:"stream_addresses,omitempty"`
}

func (m *StreamIngestionFrontierSpec) Reset()         { *m = StreamIngestionFrontierSpec{} }
func (m *StreamIngestionFrontierSpec) String() string { return proto.CompactTextString(m) }
func (*StreamIngestionFrontierSpec) ProtoMessage()    {}
func (*StreamIngestionFrontierSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{5}
}
func (m *StreamIngestionFrontierSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamIngestionFrontierSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StreamIngestionFrontierSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamIngestionFrontierSpec.Merge(m, src)
}
func (m *StreamIngestionFrontierSpec) XXX_Size() int {
	return m.Size()
}
func (m *StreamIngestionFrontierSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamIngestionFrontierSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StreamIngestionFrontierSpec proto.InternalMessageInfo

type BackupDataSpec struct {
	// TODO(lidor): job_id is not needed when interoperability with 22.2 is
	// dropped, the new way to send the job tag is using 'job_tag' in the
	// SetupFlowRequest message.
	JobID            int64                          `protobuf:"varint,11,opt,name=job_id,json=jobId" json:"job_id"`
	Spans            []roachpb.Span                 `protobuf:"bytes,1,rep,name=spans" json:"spans"`
	IntroducedSpans  []roachpb.Span                 `protobuf:"bytes,2,rep,name=introduced_spans,json=introducedSpans" json:"introduced_spans"`
	DefaultURI       string                         `protobuf:"bytes,3,opt,name=default_uri,json=defaultUri" json:"default_uri"`
	URIsByLocalityKV map[string]string              `protobuf:"bytes,4,rep,name=uris_by_locality_kv,json=urisByLocalityKv" json:"uris_by_locality_kv,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	MVCCFilter       roachpb.MVCCFilter             `protobuf:"varint,5,opt,name=mvcc_filter,json=mvccFilter,enum=cockroach.roachpb.MVCCFilter" json:"mvcc_filter"`
	Encryption       *roachpb.FileEncryptionOptions `protobuf:"bytes,6,opt,name=encryption" json:"encryption,omitempty"`
	BackupStartTime  hlc.Timestamp                  `protobuf:"bytes,7,opt,name=backup_start_time,json=backupStartTime" json:"backup_start_time"`
	BackupEndTime    hlc.Timestamp                  `protobuf:"bytes,8,opt,name=backup_end_time,json=backupEndTime" json:"backup_end_time"`
	// PKIDs is used to convert result from an ExportRequest into row count
	// information passed back to track progress in the backup job.
	PKIDs map[uint64]bool `protobuf:"bytes,9,rep,name=pk_ids,json=pkIds" json:"pk_ids,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// User who initiated the backup. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,10,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto"`
}

func (m *BackupDataSpec) Reset()         { *m = BackupDataSpec{} }
func (m *BackupDataSpec) String() string { return proto.CompactTextString(m) }
func (*BackupDataSpec) ProtoMessage()    {}
func (*BackupDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{6}
}
func (m *BackupDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BackupDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupDataSpec.Merge(m, src)
}
func (m *BackupDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *BackupDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BackupDataSpec proto.InternalMessageInfo

type RestoreFileSpec struct {
	Dir  cloudpb.ExternalStorage `protobuf:"bytes,1,opt,name=dir" json:"dir"`
	Path string                  `protobuf:"bytes,2,opt,name=path" json:"path"`
}

func (m *RestoreFileSpec) Reset()         { *m = RestoreFileSpec{} }
func (m *RestoreFileSpec) String() string { return proto.CompactTextString(m) }
func (*RestoreFileSpec) ProtoMessage()    {}
func (*RestoreFileSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{7}
}
func (m *RestoreFileSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreFileSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestoreFileSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreFileSpec.Merge(m, src)
}
func (m *RestoreFileSpec) XXX_Size() int {
	return m.Size()
}
func (m *RestoreFileSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreFileSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreFileSpec proto.InternalMessageInfo

type TableRekey struct {
	// OldID is the previous ID of `new_desc`.
	OldID uint32 `protobuf:"varint,1,opt,name=old_id,json=oldId" json:"old_id"`
	// NewDesc is an encoded Descriptor message.
	NewDesc []byte `protobuf:"bytes,2,opt,name=new_desc,json=newDesc" json:"new_desc,omitempty"`
}

func (m *TableRekey) Reset()         { *m = TableRekey{} }
func (m *TableRekey) String() string { return proto.CompactTextString(m) }
func (*TableRekey) ProtoMessage()    {}
func (*TableRekey) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{8}
}
func (m *TableRekey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableRekey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableRekey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableRekey.Merge(m, src)
}
func (m *TableRekey) XXX_Size() int {
	return m.Size()
}
func (m *TableRekey) XXX_DiscardUnknown() {
	xxx_messageInfo_TableRekey.DiscardUnknown(m)
}

var xxx_messageInfo_TableRekey proto.InternalMessageInfo

type TenantRekey struct {
	// OldID is a previous tenant ID.
	OldID roachpb.TenantID `protobuf:"bytes,1,opt,name=old_id,json=oldId" json:"old_id"`
	// NewID is the ID with which to replace OldID.
	NewID roachpb.TenantID `protobuf:"bytes,2,opt,name=new_id,json=newId" json:"new_id"`
}

func (m *TenantRekey) Reset()         { *m = TenantRekey{} }
func (m *TenantRekey) String() string { return proto.CompactTextString(m) }
func (*TenantRekey) ProtoMessage()    {}
func (*TenantRekey) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{9}
}
func (m *TenantRekey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantRekey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantRekey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantRekey.Merge(m, src)
}
func (m *TenantRekey) XXX_Size() int {
	return m.Size()
}
func (m *TenantRekey) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantRekey.DiscardUnknown(m)
}

var xxx_messageInfo_TenantRekey proto.InternalMessageInfo

// RestoreDataEntry will be specified at planning time to the SplitAndScatter
// processors, then those processors will stream these, encoded as bytes in rows
// to the RestoreDataProcessors.
// This field has a subset of the importEntry struct defined in restore.
type RestoreSpanEntry struct {
	Span        roachpb.Span      `protobuf:"bytes,1,opt,name=span" json:"span"`
	Files       []RestoreFileSpec `protobuf:"bytes,2,rep,name=files" json:"files"`
	ProgressIdx int64             `protobuf:"varint,3,opt,name=progressIdx" json:"progressIdx"`
}

func (m *RestoreSpanEntry) Reset()         { *m = RestoreSpanEntry{} }
func (m *RestoreSpanEntry) String() string { return proto.CompactTextString(m) }
func (*RestoreSpanEntry) ProtoMessage()    {}
func (*RestoreSpanEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{10}
}
func (m *RestoreSpanEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreSpanEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestoreSpanEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreSpanEntry.Merge(m, src)
}
func (m *RestoreSpanEntry) XXX_Size() int {
	return m.Size()
}
func (m *RestoreSpanEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreSpanEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreSpanEntry proto.InternalMessageInfo

type RestoreDataSpec struct {
	// TODO(lidor): job_id is not needed when interoperability with 22.2 is
	// dropped, the new way to send the job tag is using 'job_tag' in the
	// SetupFlowRequest message.
	JobID        int64                          `protobuf:"varint,6,opt,name=job_id,json=jobId" json:"job_id"`
	RestoreTime  hlc.Timestamp                  `protobuf:"bytes,1,opt,name=restore_time,json=restoreTime" json:"restore_time"`
	Encryption   *roachpb.FileEncryptionOptions `protobuf:"bytes,2,opt,name=encryption" json:"encryption,omitempty"`
	TableRekeys  []TableRekey                   `protobuf:"bytes,3,rep,name=table_rekeys,json=tableRekeys" json:"table_rekeys"`
	TenantRekeys []TenantRekey                  `protobuf:"bytes,5,rep,name=tenant_rekeys,json=tenantRekeys" json:"tenant_rekeys"`
	// PKIDs is used to convert result from an ExportRequest into row count
	// information passed back to track progress in the backup job.
	PKIDs        map[uint64]bool `protobuf:"bytes,4,rep,name=pk_ids,json=pkIds" json:"pk_ids,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	ValidateOnly bool            `protobuf:"varint,8,opt,name=validate_only,json=validateOnly" json:"validate_only"`
}

func (m *RestoreDataSpec) Reset()         { *m = RestoreDataSpec{} }
func (m *RestoreDataSpec) String() string { return proto.CompactTextString(m) }
func (*RestoreDataSpec) ProtoMessage()    {}
func (*RestoreDataSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{11}
}
func (m *RestoreDataSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreDataSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestoreDataSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreDataSpec.Merge(m, src)
}
func (m *RestoreDataSpec) XXX_Size() int {
	return m.Size()
}
func (m *RestoreDataSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreDataSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreDataSpec proto.InternalMessageInfo

type SplitAndScatterSpec struct {
	// TODO(lidor): job_id is not needed when interoperability with 22.2 is
	// dropped, the new way to send the job tag is using 'job_tag' in the
	// SetupFlowRequest message.
	JobID        int64                                   `protobuf:"varint,4,opt,name=job_id,json=jobId" json:"job_id"`
	Chunks       []SplitAndScatterSpec_RestoreEntryChunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks"`
	TableRekeys  []TableRekey                            `protobuf:"bytes,2,rep,name=table_rekeys,json=tableRekeys" json:"table_rekeys"`
	TenantRekeys []TenantRekey                           `protobuf:"bytes,3,rep,name=tenant_rekeys,json=tenantRekeys" json:"tenant_rekeys"`
	ValidateOnly bool                                    `protobuf:"varint,6,opt,name=validate_only,json=validateOnly" json:"validate_only"`
}

func (m *SplitAndScatterSpec) Reset()         { *m = SplitAndScatterSpec{} }
func (m *SplitAndScatterSpec) String() string { return proto.CompactTextString(m) }
func (*SplitAndScatterSpec) ProtoMessage()    {}
func (*SplitAndScatterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{12}
}
func (m *SplitAndScatterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitAndScatterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SplitAndScatterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitAndScatterSpec.Merge(m, src)
}
func (m *SplitAndScatterSpec) XXX_Size() int {
	return m.Size()
}
func (m *SplitAndScatterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitAndScatterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SplitAndScatterSpec proto.InternalMessageInfo

type SplitAndScatterSpec_RestoreEntryChunk struct {
	Entries []RestoreSpanEntry `protobuf:"bytes,1,rep,name=entries" json:"entries"`
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) Reset()         { *m = SplitAndScatterSpec_RestoreEntryChunk{} }
func (m *SplitAndScatterSpec_RestoreEntryChunk) String() string { return proto.CompactTextString(m) }
func (*SplitAndScatterSpec_RestoreEntryChunk) ProtoMessage()    {}
func (*SplitAndScatterSpec_RestoreEntryChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{12, 0}
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitAndScatterSpec_RestoreEntryChunk.Merge(m, src)
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_Size() int {
	return m.Size()
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitAndScatterSpec_RestoreEntryChunk.DiscardUnknown(m)
}

var xxx_messageInfo_SplitAndScatterSpec_RestoreEntryChunk proto.InternalMessageInfo

// ExporterSpec is the specification for a processor that consumes rows and
// writes them to Parquet or CSV files at uri. It outputs a row per file written with
// the file name, row count and byte size.
type ExportSpec struct {
	// destination as a cloud.ExternalStorage URI pointing to an export store
	// location (directory).
	Destination string               `protobuf:"bytes,1,opt,name=destination" json:"destination"`
	NamePattern string               `protobuf:"bytes,2,opt,name=name_pattern,json=namePattern" json:"name_pattern"`
	Format      roachpb.IOFileFormat `protobuf:"bytes,3,opt,name=format" json:"format"`
	// chunk_rows is num rows to write per file. 0 = no limit.
	ChunkRows int64 `protobuf:"varint,4,opt,name=chunk_rows,json=chunkRows" json:"chunk_rows"`
	// chunk_size is the target byte size per file.
	ChunkSize int64 `protobuf:"varint,5,opt,name=chunk_size,json=chunkSize" json:"chunk_size"`
	// User who initiated the export. This is used to check access privileges
	// when using FileTable ExternalStorage.
	UserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,6,opt,name=user_proto,json=userProto,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto"`
	// col_names specifies the logical column names for the exported parquet file.
	ColNames []string `protobuf:"bytes,7,rep,name=col_names,json=colNames" json:"col_names,omitempty"`
}

func (m *ExportSpec) Reset()         { *m = ExportSpec{} }
func (m *ExportSpec) String() string { return proto.CompactTextString(m) }
func (*ExportSpec) ProtoMessage()    {}
func (*ExportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{13}
}
func (m *ExportSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportSpec.Merge(m, src)
}
func (m *ExportSpec) XXX_Size() int {
	return m.Size()
}
func (m *ExportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ExportSpec proto.InternalMessageInfo

// BulkRowWriterSpec is the specification for a processor that consumes rows and
// writes them to a target table using AddSSTable. It outputs a BulkOpSummary.
type BulkRowWriterSpec struct {
	Table descpb.TableDescriptor `protobuf:"bytes,1,opt,name=table" json:"table"`
}

func (m *BulkRowWriterSpec) Reset()         { *m = BulkRowWriterSpec{} }
func (m *BulkRowWriterSpec) String() string { return proto.CompactTextString(m) }
func (*BulkRowWriterSpec) ProtoMessage()    {}
func (*BulkRowWriterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{14}
}
func (m *BulkRowWriterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulkRowWriterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BulkRowWriterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulkRowWriterSpec.Merge(m, src)
}
func (m *BulkRowWriterSpec) XXX_Size() int {
	return m.Size()
}
func (m *BulkRowWriterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_BulkRowWriterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_BulkRowWriterSpec proto.InternalMessageInfo

type IndexBackfillMergerSpec struct {
	Table            descpb.TableDescriptor                                            `protobuf:"bytes,1,opt,name=table" json:"table"`
	TemporaryIndexes []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,2,rep,name=temporary_indexes,json=temporaryIndexes,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"temporary_indexes,omitempty"`
	AddedIndexes     []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID `protobuf:"varint,3,rep,name=added_indexes,json=addedIndexes,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.IndexID" json:"added_indexes,omitempty"`
	Spans            []roachpb.Span                                                    `protobuf:"bytes,4,rep,name=spans" json:"spans"`
	SpanIdx          []int32                                                           `protobuf:"varint,5,rep,name=span_idx,json=spanIdx" json:"span_idx,omitempty"`
	MergeTimestamp   hlc.Timestamp                                                     `protobuf:"bytes,8,opt,name=mergeTimestamp" json:"mergeTimestamp"`
}

func (m *IndexBackfillMergerSpec) Reset()         { *m = IndexBackfillMergerSpec{} }
func (m *IndexBackfillMergerSpec) String() string { return proto.CompactTextString(m) }
func (*IndexBackfillMergerSpec) ProtoMessage()    {}
func (*IndexBackfillMergerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6d46d06b67eadaca, []int{15}
}
func (m *IndexBackfillMergerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexBackfillMergerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexBackfillMergerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexBackfillMergerSpec.Merge(m, src)
}
func (m *IndexBackfillMergerSpec) XXX_Size() int {
	return m.Size()
}
func (m *IndexBackfillMergerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexBackfillMergerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IndexBackfillMergerSpec proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.distsqlrun.BackfillerSpec_Type", BackfillerSpec_Type_name, BackfillerSpec_Type_value)
	proto.RegisterType((*BackfillerSpec)(nil), "cockroach.sql.distsqlrun.BackfillerSpec")
	proto.RegisterType((*JobProgress)(nil), "cockroach.sql.distsqlrun.JobProgress")
	proto.RegisterType((*ReadImportDataSpec)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec")
	proto.RegisterMapType((map[int32]int64)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.ResumePosEntry")
	proto.RegisterMapType((map[string]*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.TablesEntry")
	proto.RegisterMapType((map[int32]string)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.UriEntry")
	proto.RegisterType((*ReadImportDataSpec_ImportTable)(nil), "cockroach.sql.distsqlrun.ReadImportDataSpec.ImportTable")
	proto.RegisterType((*StreamIngestionPartitionSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionPartitionSpec")
	proto.RegisterType((*StreamIngestionDataSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionDataSpec")
	proto.RegisterMapType((map[string]StreamIngestionPartitionSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionDataSpec.PartitionSpecsEntry")
	proto.RegisterType((*StreamIngestionFrontierSpec)(nil), "cockroach.sql.distsqlrun.StreamIngestionFrontierSpec")
	proto.RegisterMapType((map[string]uint32)(nil), "cockroach.sql.distsqlrun.StreamIngestionFrontierSpec.SubscribingSqlInstancesEntry")
	proto.RegisterType((*BackupDataSpec)(nil), "cockroach.sql.distsqlrun.BackupDataSpec")
	proto.RegisterMapType((map[uint64]bool)(nil), "cockroach.sql.distsqlrun.BackupDataSpec.PkIdsEntry")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.distsqlrun.BackupDataSpec.UrisByLocalityKvEntry")
	proto.RegisterType((*RestoreFileSpec)(nil), "cockroach.sql.distsqlrun.RestoreFileSpec")
	proto.RegisterType((*TableRekey)(nil), "cockroach.sql.distsqlrun.TableRekey")
	proto.RegisterType((*TenantRekey)(nil), "cockroach.sql.distsqlrun.TenantRekey")
	proto.RegisterType((*RestoreSpanEntry)(nil), "cockroach.sql.distsqlrun.RestoreSpanEntry")
	proto.RegisterType((*RestoreDataSpec)(nil), "cockroach.sql.distsqlrun.RestoreDataSpec")
	proto.RegisterMapType((map[uint64]bool)(nil), "cockroach.sql.distsqlrun.RestoreDataSpec.PkIdsEntry")
	proto.RegisterType((*SplitAndScatterSpec)(nil), "cockroach.sql.distsqlrun.SplitAndScatterSpec")
	proto.RegisterType((*SplitAndScatterSpec_RestoreEntryChunk)(nil), "cockroach.sql.distsqlrun.SplitAndScatterSpec.RestoreEntryChunk")
	proto.RegisterType((*ExportSpec)(nil), "cockroach.sql.distsqlrun.ExportSpec")
	proto.RegisterType((*BulkRowWriterSpec)(nil), "cockroach.sql.distsqlrun.BulkRowWriterSpec")
	proto.RegisterType((*IndexBackfillMergerSpec)(nil), "cockroach.sql.distsqlrun.IndexBackfillMergerSpec")
}

func init() {
	proto.RegisterFile("sql/execinfrapb/processors_bulk_io.proto", fileDescriptor_6d46d06b67eadaca)
}

var fileDescriptor_6d46d06b67eadaca = []byte{
	// 2605 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0x5d, 0x6f, 0x1b, 0xc7,
	0xd5, 0xf6, 0x8a, 0x1f, 0x22, 0x0f, 0x45, 0x99, 0x1a, 0xc5, 0x31, 0xa3, 0x24, 0x92, 0x5e, 0xc6,
	0xc9, 0xcb, 0xa4, 0x30, 0x89, 0xd8, 0xa9, 0x11, 0x34, 0x4d, 0x1d, 0x51, 0x92, 0x1d, 0xca, 0x1f,
	0x52, 0x96, 0xb2, 0x03, 0x04, 0x68, 0x17, 0xc3, 0xdd, 0x11, 0x39, 0xe1, 0x72, 0x67, 0x3d, 0x33,
	0xb4, 0xc4, 0xdc, 0x15, 0xfd, 0x03, 0x2d, 0x8a, 0xfe, 0x8c, 0xa2, 0x28, 0xd0, 0xdb, 0xde, 0xe7,
	0xa6, 0x40, 0xae, 0x8a, 0x5c, 0x19, 0xa9, 0x83, 0xfe, 0x81, 0xf6, 0x2e, 0x57, 0xc5, 0xcc, 0xce,
	0x92, 0x4b, 0x89, 0x92, 0x28, 0xc7, 0xb9, 0x91, 0x96, 0x73, 0xce, 0x79, 0xe6, 0xeb, 0x9c, 0xe7,
	0x9c, 0x99, 0x81, 0xaa, 0x78, 0xe2, 0xd7, 0xc9, 0x11, 0x71, 0x69, 0x70, 0xc0, 0x71, 0xd8, 0xae,
	0x87, 0x9c, 0xb9, 0x44, 0x08, 0xc6, 0x85, 0xd3, 0x1e, 0xf8, 0x3d, 0x87, 0xb2, 0x5a, 0xc8, 0x99,
	0x64, 0xa8, 0xec, 0x32, 0xb7, 0xc7, 0x19, 0x76, 0xbb, 0x35, 0xf1, 0xc4, 0xaf, 0x79, 0x54, 0x48,
	0xf1, 0xc4, 0xe7, 0x83, 0x60, 0xe5, 0xd5, 0x2f, 0x59, 0x5b, 0xd4, 0xd5, 0x9f, 0xb0, 0xad, 0xff,
	0x45, 0x16, 0x2b, 0x65, 0xad, 0x1d, 0xb6, 0xeb, 0x94, 0x5d, 0x3f, 0x60, 0xbc, 0x8f, 0x65, 0x2c,
	0x79, 0x4b, 0xf5, 0xea, 0x62, 0x89, 0x7d, 0xd6, 0xa9, 0x7b, 0x44, 0xb8, 0x61, 0xbb, 0x2e, 0x24,
	0x1f, 0xb8, 0x72, 0xc0, 0x89, 0x17, 0x9b, 0x0f, 0x24, 0xf5, 0xeb, 0x5d, 0xdf, 0xad, 0x4b, 0xda,
	0x27, 0x42, 0xe2, 0x7e, 0x68, 0x24, 0xaf, 0x74, 0x58, 0x87, 0xe9, 0xcf, 0xba, 0xfa, 0x32, 0xad,
	0x28, 0xee, 0xce, 0xc3, 0x12, 0x9b, 0xb6, 0xa5, 0xb8, 0x0d, 0x87, 0xd4, 0x34, 0x5d, 0x73, 0x7d,
	0x36, 0xf0, 0xea, 0xfa, 0x6f, 0xd8, 0xae, 0x93, 0x23, 0x49, 0x78, 0x80, 0x7d, 0x47, 0x48, 0xc6,
	0x71, 0x87, 0x44, 0x5a, 0x95, 0xbf, 0x67, 0x61, 0xb1, 0x81, 0xdd, 0xde, 0x01, 0xf5, 0x7d, 0xc2,
	0x5b, 0x21, 0x71, 0xd1, 0x35, 0xc8, 0x7e, 0xc9, 0xda, 0x0e, 0xf5, 0xca, 0xc5, 0x75, 0xab, 0x9a,
	0x6a, 0x14, 0xbf, 0x7e, 0xb6, 0x76, 0xe9, 0xf9, 0xb3, 0xb5, 0xcc, 0x0e, 0x6b, 0x37, 0xb7, 0xec,
	0xcc, 0x97, 0xac, 0xdd, 0xf4, 0xd0, 0x5d, 0x48, 0xcb, 0x61, 0x48, 0xca, 0xd6, 0xba, 0x55, 0x5d,
	0xbc, 0x71, 0xbd, 0x76, 0xda, 0xaa, 0xd5, 0x26, 0xd1, 0x6b, 0xfb, 0xc3, 0x90, 0x34, 0xd2, 0x0a,
	0xd2, 0xd6, 0x00, 0xa8, 0x01, 0x19, 0x89, 0xdb, 0x3e, 0x29, 0xcf, 0xad, 0x5b, 0xd5, 0xc2, 0x8d,
	0x77, 0x8e, 0x21, 0x89, 0x27, 0x7e, 0x1b, 0x0b, 0x52, 0xdb, 0x57, 0x3a, 0x5b, 0x44, 0xb8, 0x9c,
	0x86, 0x92, 0x71, 0x03, 0x11, 0x99, 0xa2, 0x9b, 0x90, 0x11, 0x21, 0x0e, 0x44, 0x19, 0xd6, 0x53,
	0xd5, 0xc2, 0x8d, 0xab, 0x09, 0x0c, 0xb3, 0x30, 0xb5, 0x56, 0x88, 0x83, 0xd8, 0x48, 0xeb, 0xa2,
	0xf7, 0x21, 0xe7, 0x0d, 0x38, 0x96, 0x94, 0x05, 0xe5, 0xb4, 0x9e, 0xe9, 0x15, 0x25, 0xfe, 0xe1,
	0xd9, 0x5a, 0x51, 0x6d, 0x44, 0x6d, 0xcb, 0x08, 0xed, 0x91, 0x1a, 0x7a, 0x0b, 0xc0, 0xed, 0x0e,
	0x82, 0x9e, 0x23, 0xe8, 0x57, 0xa4, 0x9c, 0xd1, 0x46, 0x11, 0x66, 0x5e, 0xb7, 0xb7, 0xe8, 0x57,
	0x04, 0x3d, 0x84, 0xff, 0x1b, 0x84, 0x1e, 0x96, 0xc4, 0x19, 0xeb, 0x3a, 0xb2, 0xcb, 0x89, 0xe8,
	0x32, 0xdf, 0x73, 0xda, 0x43, 0x49, 0x44, 0x79, 0x71, 0xdd, 0xaa, 0xa6, 0x8d, 0xed, 0x9b, 0x91,
	0xfa, 0x66, 0x8c, 0xb0, 0x1f, 0xeb, 0x36, 0x94, 0x2a, 0xda, 0x80, 0xfc, 0x21, 0xa7, 0x92, 0x6c,
	0x88, 0xdd, 0x83, 0xf2, 0xbc, 0x5e, 0xa4, 0x37, 0x13, 0x13, 0x54, 0xde, 0x53, 0xeb, 0xfa, 0x6e,
	0x6d, 0x3f, 0xf6, 0x9e, 0x78, 0x48, 0x23, 0x2b, 0x74, 0x1b, 0x72, 0x9c, 0x60, 0x4f, 0x23, 0xe4,
	0x67, 0x47, 0x18, 0x19, 0x21, 0x01, 0xcb, 0x34, 0xf0, 0xc8, 0x11, 0x11, 0x8e, 0x64, 0x4e, 0xdb,
	0x6c, 0x69, 0x39, 0xb7, 0x9e, 0xaa, 0x16, 0x1b, 0x9b, 0x3f, 0x3c, 0x5b, 0xbb, 0xdd, 0xa1, 0xb2,
	0x3b, 0x68, 0xd7, 0x5c, 0xd6, 0xaf, 0x8f, 0x90, 0xbd, 0xf6, 0xf8, 0xbb, 0x1e, 0xf6, 0x3a, 0xf5,
	0x93, 0xe1, 0x50, 0x6b, 0x2a, 0xd8, 0xe6, 0x96, 0xbd, 0x64, 0xf0, 0xf7, 0x59, 0xec, 0x30, 0xe8,
	0x67, 0xb0, 0x48, 0x03, 0x2a, 0xa9, 0x72, 0xda, 0xd0, 0xa7, 0x52, 0x94, 0x0b, 0xeb, 0x56, 0x35,
	0x63, 0x06, 0x57, 0x34, 0xb2, 0x96, 0x16, 0xa1, 0x8f, 0xa1, 0xac, 0xe7, 0xeb, 0x60, 0xe9, 0xb4,
	0xb1, 0x74, 0xbb, 0xce, 0x28, 0x9a, 0xca, 0x0b, 0xeb, 0x56, 0x35, 0x67, 0xcc, 0xae, 0x44, 0xab,
	0x22, 0x1b, 0x4a, 0x67, 0x34, 0xe1, 0xca, 0x7b, 0x90, 0x56, 0x9e, 0x89, 0x0a, 0x30, 0xdf, 0x0c,
	0x9e, 0x62, 0x9f, 0x7a, 0xa5, 0x4b, 0x08, 0x20, 0xbb, 0xc9, 0xfc, 0x41, 0x3f, 0x28, 0x59, 0x28,
	0x0f, 0x19, 0x3d, 0xd4, 0xd2, 0xdc, 0x4e, 0x3a, 0x97, 0x2a, 0xa5, 0x77, 0xd2, 0xb9, 0x6c, 0x69,
	0xbe, 0xf2, 0x57, 0x0b, 0x0a, 0x3b, 0xac, 0xbd, 0xc7, 0x59, 0x87, 0x13, 0x21, 0xd0, 0x6f, 0x46,
	0xc1, 0x63, 0x69, 0xef, 0xb8, 0x3b, 0x11, 0x3c, 0x3f, 0x3c, 0x5b, 0xbb, 0x35, 0xd3, 0x42, 0x25,
	0x98, 0xa6, 0x36, 0x11, 0x76, 0x55, 0x58, 0x70, 0x59, 0x20, 0x39, 0x6d, 0x0f, 0xb4, 0xe3, 0xaa,
	0xa0, 0x99, 0x33, 0x53, 0x9b, 0x90, 0xa0, 0x32, 0xa4, 0x85, 0xcf, 0x64, 0x39, 0x95, 0x58, 0x33,
	0xdd, 0x52, 0xf9, 0x37, 0x00, 0xb2, 0x09, 0xf6, 0x9a, 0xfd, 0x90, 0x71, 0xb9, 0x85, 0x25, 0x3e,
	0x16, 0xf7, 0xcb, 0x67, 0xc4, 0xfd, 0xc7, 0x90, 0x8d, 0x38, 0xae, 0x9c, 0xd3, 0x8e, 0xb4, 0x36,
	0x25, 0xd6, 0x9a, 0xbb, 0x77, 0xa8, 0x4f, 0xee, 0x68, 0x35, 0xd3, 0xb3, 0x31, 0x42, 0x6f, 0x43,
	0x41, 0xe0, 0x7e, 0xe8, 0x93, 0x28, 0x84, 0xe6, 0x12, 0x83, 0x83, 0x48, 0xa0, 0x63, 0xe8, 0x31,
	0x64, 0x75, 0x64, 0x8b, 0x72, 0x5e, 0x47, 0xf4, 0x87, 0xa7, 0xf3, 0xcb, 0xc9, 0x99, 0x44, 0x5c,
	0x21, 0xb6, 0x03, 0xc9, 0x87, 0x1a, 0xdb, 0xb2, 0x0d, 0x1a, 0xba, 0x0b, 0xa9, 0x01, 0xa7, 0xe5,
	0x79, 0x0d, 0xfa, 0xf3, 0x0b, 0x81, 0x3e, 0xe2, 0x54, 0x23, 0xda, 0x0a, 0x01, 0x7d, 0x01, 0xc0,
	0x89, 0x18, 0xf4, 0x89, 0x13, 0x32, 0x15, 0xcd, 0x0a, 0xef, 0xa3, 0x0b, 0xe1, 0xd9, 0xda, 0x7c,
	0x8f, 0x45, 0xe3, 0xb4, 0xf3, 0x3c, 0xfe, 0x8d, 0xee, 0x42, 0x2e, 0x34, 0xfe, 0x54, 0xce, 0xea,
	0x45, 0x7e, 0xfb, 0x74, 0xe4, 0x84, 0xf3, 0xc5, 0x51, 0x1b, 0x1b, 0xa3, 0xdb, 0xf0, 0x9a, 0xe8,
	0xd1, 0xd0, 0xe9, 0x53, 0x21, 0x68, 0xd0, 0x71, 0x0e, 0x18, 0x27, 0xb4, 0x13, 0x38, 0x3d, 0x32,
	0x54, 0x54, 0x39, 0x0e, 0x8a, 0x57, 0x95, 0xda, 0x83, 0x48, 0xeb, 0x4e, 0xa4, 0x74, 0x8f, 0x0c,
	0x05, 0x7a, 0x0f, 0x8a, 0x87, 0xd8, 0xf7, 0x55, 0x24, 0x3d, 0xc4, 0x01, 0x8b, 0x02, 0x30, 0xa6,
	0xbc, 0x49, 0x11, 0xba, 0x01, 0x4b, 0x8a, 0x2e, 0x08, 0xdf, 0xc3, 0x1c, 0xfb, 0x3e, 0xf1, 0xa9,
	0xe8, 0xeb, 0x0c, 0x12, 0xef, 0xef, 0x49, 0x31, 0x0a, 0x00, 0x06, 0x82, 0x70, 0x47, 0xe7, 0xa2,
	0xf2, 0xe5, 0x75, 0xab, 0x9a, 0x6f, 0xec, 0x1a, 0x12, 0xbe, 0x3b, 0x1b, 0xa3, 0x10, 0x77, 0xc0,
	0xa9, 0x1c, 0xd6, 0x15, 0x4e, 0x80, 0xfb, 0xa4, 0xd6, 0xfa, 0xec, 0xfe, 0x23, 0xf3, 0xbd, 0xa7,
	0x60, 0xed, 0xbc, 0x12, 0xe9, 0x4f, 0xf4, 0x11, 0x64, 0x54, 0xce, 0x11, 0xe5, 0x92, 0xde, 0xb0,
	0xb7, 0x4f, 0xcb, 0x35, 0xc3, 0x30, 0x91, 0x6a, 0xec, 0xc8, 0x06, 0xfd, 0xd6, 0x82, 0xab, 0x2a,
	0xe5, 0x2a, 0x15, 0x27, 0xe4, 0xb4, 0x8f, 0xf9, 0xd0, 0xe1, 0xa4, 0xa3, 0xc2, 0x70, 0x49, 0x0f,
	0xbd, 0x69, 0x86, 0xbe, 0x71, 0x61, 0x32, 0x74, 0xb1, 0x0c, 0xdb, 0x35, 0x5b, 0x83, 0x3d, 0xc4,
	0x7d, 0x62, 0x5f, 0x89, 0x7b, 0xda, 0x8b, 0x3a, 0x8a, 0x44, 0x53, 0x28, 0x11, 0x9d, 0x4a, 0x89,
	0x2b, 0x03, 0x28, 0x44, 0x3e, 0xa7, 0xe3, 0x01, 0x7d, 0x02, 0x69, 0xc5, 0xb9, 0x9a, 0x98, 0x2e,
	0x96, 0x67, 0x2d, 0x5b, 0x5b, 0xa2, 0x6b, 0x00, 0x12, 0xf3, 0x0e, 0x91, 0x9b, 0xcc, 0x17, 0xe5,
	0xb9, 0xf5, 0x54, 0x35, 0x6f, 0xe4, 0x89, 0xf6, 0x15, 0x01, 0x85, 0x44, 0x00, 0xa2, 0x12, 0xa4,
	0x7a, 0x64, 0xa8, 0x7b, 0xcd, 0xdb, 0xea, 0x13, 0x3d, 0x84, 0xcc, 0x53, 0xec, 0x0f, 0xe2, 0x8c,
	0x7f, 0xb1, 0xd8, 0x4e, 0xcc, 0xc8, 0x8e, 0x60, 0x7e, 0x31, 0xf7, 0xa1, 0xb5, 0x72, 0x0b, 0x72,
	0x71, 0x80, 0x26, 0x7b, 0xcc, 0x44, 0x3d, 0xbe, 0x92, 0xec, 0x31, 0x9f, 0xb4, 0xfb, 0x25, 0x2c,
	0x4e, 0x06, 0xe2, 0x79, 0xd6, 0xa9, 0x84, 0xf5, 0x4e, 0x3a, 0x67, 0x25, 0xf2, 0x41, 0xba, 0x94,
	0xd9, 0x49, 0xe7, 0x32, 0xa5, 0xec, 0x4e, 0x3a, 0xb7, 0x50, 0x2a, 0x56, 0xbe, 0xb3, 0xe0, 0x8d,
	0x96, 0xe4, 0x04, 0xf7, 0x9b, 0x41, 0x87, 0x08, 0xc5, 0xca, 0x7b, 0x98, 0x4b, 0xaa, 0x3e, 0x34,
	0xe3, 0xde, 0x82, 0x85, 0x30, 0x6e, 0x88, 0x53, 0x46, 0xbe, 0xb1, 0x6c, 0x78, 0xb7, 0x30, 0x52,
	0x6e, 0x6e, 0xd9, 0x85, 0x91, 0x62, 0xd3, 0x43, 0x37, 0x01, 0x89, 0x41, 0x3b, 0xda, 0x22, 0x65,
	0x2a, 0x59, 0x8f, 0x44, 0xa9, 0x20, 0x1f, 0xc7, 0x5a, 0x52, 0xbe, 0xaf, 0xc4, 0x68, 0x15, 0xe6,
	0xb1, 0xe7, 0x69, 0x52, 0x49, 0x25, 0x34, 0xe3, 0xc6, 0x71, 0x0d, 0x95, 0x9e, 0xbd, 0x86, 0xaa,
	0xfc, 0x21, 0x03, 0x57, 0x8f, 0x4d, 0x71, 0x94, 0x4f, 0xae, 0x43, 0x5e, 0x68, 0x91, 0x9a, 0x5a,
	0x46, 0xd7, 0x3b, 0x25, 0x33, 0xb5, 0x9c, 0xb1, 0xd9, 0xb2, 0x73, 0x91, 0x4a, 0xd3, 0x43, 0x12,
	0x2e, 0x8f, 0x17, 0x43, 0x84, 0xc4, 0x55, 0xe4, 0xa7, 0x46, 0xb2, 0x7d, 0xba, 0x7f, 0x9c, 0xd2,
	0x75, 0x6d, 0x62, 0x99, 0x13, 0x89, 0xe0, 0x92, 0xbd, 0x18, 0x4e, 0x88, 0x50, 0x03, 0x40, 0x48,
	0xcc, 0xa5, 0xae, 0x16, 0x8c, 0x43, 0xce, 0x56, 0x5d, 0x69, 0x33, 0xd5, 0xaa, 0x82, 0xd2, 0x4c,
	0x74, 0xda, 0x02, 0x17, 0x23, 0xd9, 0x86, 0x59, 0xe6, 0x71, 0x96, 0x4d, 0x9f, 0x91, 0x65, 0x7f,
	0x0d, 0x0b, 0x92, 0x04, 0x38, 0x90, 0x0e, 0x27, 0xca, 0x1b, 0xf3, 0xe7, 0xa5, 0x81, 0x7d, 0xad,
	0x6d, 0x2b, 0xe5, 0xb1, 0x03, 0x25, 0x1a, 0xed, 0x82, 0x1c, 0xff, 0x50, 0xd9, 0xcb, 0xed, 0x12,
	0xb7, 0x17, 0x32, 0x1a, 0x48, 0x9d, 0x09, 0x0a, 0x37, 0x3e, 0x38, 0x06, 0xae, 0x0f, 0x38, 0xa6,
	0x04, 0x39, 0xb6, 0xce, 0x9b, 0x23, 0xdb, 0x38, 0x75, 0x8f, 0xd1, 0x56, 0x86, 0xb0, 0x3c, 0x65,
	0xf9, 0xa7, 0xd0, 0xc0, 0xfd, 0x49, 0x1a, 0xb8, 0x35, 0xf3, 0x36, 0x4f, 0xc0, 0x9f, 0x08, 0xc7,
	0xca, 0x9f, 0x32, 0xf0, 0xfa, 0x31, 0x8b, 0x3b, 0x9c, 0x05, 0x92, 0x9a, 0xf3, 0x8d, 0x0d, 0xcb,
	0x5d, 0xda, 0xe9, 0x3a, 0x87, 0x58, 0x12, 0xae, 0xca, 0x45, 0xbd, 0x93, 0x86, 0x16, 0x67, 0xda,
	0xfb, 0x92, 0xb2, 0xff, 0x5c, 0x99, 0x6f, 0xc8, 0x96, 0x32, 0x46, 0x0d, 0x28, 0x4a, 0x8e, 0xdd,
	0x1e, 0xf1, 0x9c, 0x28, 0x88, 0xe6, 0x66, 0x09, 0xa2, 0x05, 0x63, 0xd3, 0xd2, 0xe7, 0x91, 0xbf,
	0x58, 0xf0, 0x9a, 0x09, 0xdb, 0xb6, 0xca, 0xd6, 0xe2, 0x89, 0xef, 0xd0, 0x40, 0x48, 0x1c, 0xb8,
	0x24, 0x8e, 0x05, 0x7b, 0xe6, 0x45, 0x4a, 0x4e, 0xb9, 0xd6, 0x1a, 0xc3, 0xb6, 0x9e, 0xf8, 0xcd,
	0x18, 0x34, 0x0a, 0x8c, 0x35, 0xe3, 0x2e, 0x57, 0x93, 0x5a, 0x9f, 0xdd, 0x1f, 0x69, 0xd9, 0x57,
	0xc5, 0x74, 0xf3, 0x84, 0x2f, 0xa7, 0xce, 0xf0, 0xe5, 0x09, 0x1e, 0x48, 0x9f, 0xcb, 0x03, 0x93,
	0xbe, 0x39, 0xff, 0x32, 0x7d, 0x13, 0xbd, 0x0b, 0xa5, 0xc9, 0x48, 0x25, 0x42, 0x9f, 0x61, 0xf2,
	0xf6, 0xe5, 0x89, 0x28, 0x25, 0x62, 0x65, 0x07, 0xde, 0x38, 0x6b, 0xd5, 0xa6, 0xf8, 0xf3, 0x44,
	0x9a, 0x28, 0x4e, 0xfa, 0x65, 0xa6, 0x94, 0xad, 0xfc, 0x67, 0x3e, 0x3a, 0x6a, 0x0f, 0xc2, 0x29,
	0x25, 0x77, 0xe1, 0x8c, 0x05, 0x1c, 0x31, 0xb3, 0x75, 0x81, 0xd3, 0xed, 0xa7, 0x50, 0xa2, 0x81,
	0xe4, 0xcc, 0x1b, 0xb8, 0x17, 0x73, 0xca, 0xcb, 0x63, 0xb3, 0xc8, 0x2f, 0x6f, 0x42, 0xc1, 0x23,
	0x07, 0x78, 0xe0, 0x4b, 0x47, 0xd5, 0xce, 0x11, 0xb7, 0x21, 0x33, 0x52, 0xd8, 0x8a, 0x44, 0x8f,
	0xec, 0xa6, 0x0d, 0x46, 0xed, 0x11, 0xa7, 0xe8, 0x77, 0x16, 0x2c, 0x0f, 0x38, 0x15, 0x4e, 0x7b,
	0xe8, 0xf8, 0xcc, 0xc5, 0x3e, 0x95, 0x43, 0xa7, 0xf7, 0xd4, 0x24, 0x97, 0x5f, 0x9d, 0x7d, 0x5d,
	0x30, 0x5e, 0x21, 0x55, 0x75, 0x8b, 0xc6, 0xf0, 0xbe, 0x41, 0xb8, 0xf7, 0x34, 0x72, 0xd9, 0x57,
	0x9e, 0x3f, 0x5b, 0x2b, 0x3d, 0xb2, 0x9b, 0x49, 0xd1, 0x63, 0xbb, 0x34, 0x38, 0xa6, 0x8c, 0x6c,
	0x28, 0xf4, 0x9f, 0xba, 0xae, 0x73, 0x40, 0x7d, 0x49, 0xb8, 0x4e, 0x42, 0x8b, 0x13, 0x21, 0x1e,
	0xcf, 0xff, 0xc1, 0xe3, 0xcd, 0xcd, 0x3b, 0x5a, 0x69, 0x3c, 0xb3, 0x71, 0x9b, 0x0d, 0x0a, 0x25,
	0xfa, 0x46, 0x9f, 0x02, 0x90, 0xc0, 0xe5, 0x43, 0x9d, 0x5a, 0x4d, 0x7d, 0x5e, 0x9d, 0x02, 0xa9,
	0x8e, 0x40, 0xdb, 0x23, 0xc5, 0x5d, 0xfd, 0x57, 0xd8, 0x09, 0x5b, 0xb4, 0x0b, 0x4b, 0x6d, 0x3d,
	0x5b, 0x27, 0x91, 0x82, 0x2e, 0x70, 0xc0, 0xbf, 0x1c, 0x59, 0xb7, 0x46, 0x89, 0xe8, 0x1e, 0x98,
	0x26, 0x87, 0x04, 0x5e, 0x04, 0x97, 0x9b, 0x1d, 0xae, 0x18, 0xd9, 0x6e, 0x07, 0x9e, 0x06, 0x7b,
	0x04, 0xd9, 0xb0, 0xe7, 0x50, 0x2f, 0x3e, 0x82, 0xdd, 0x9c, 0x79, 0xcf, 0xf6, 0x7a, 0x4d, 0xcf,
	0x70, 0x4b, 0x5e, 0x39, 0xf3, 0xde, 0xbd, 0xe6, 0x96, 0xb0, 0x33, 0xa1, 0x6a, 0x3e, 0x56, 0xf2,
	0xc3, 0x4f, 0x5d, 0xf2, 0xaf, 0x6c, 0xc2, 0x95, 0xa9, 0x3e, 0x74, 0x5e, 0x00, 0x4f, 0x54, 0x89,
	0x1f, 0x02, 0x8c, 0x27, 0x95, 0xb4, 0x4c, 0x4f, 0xb1, 0xcc, 0x25, 0x2c, 0x2b, 0x43, 0xb8, 0x6c,
	0x13, 0x21, 0x19, 0x27, 0xca, 0x1f, 0x74, 0xd0, 0x7f, 0x02, 0x29, 0x8f, 0x72, 0x93, 0x6f, 0x92,
	0x9e, 0xa3, 0xaf, 0xea, 0x6a, 0xe6, 0xc2, 0xae, 0xb6, 0x6d, 0x2e, 0xec, 0x5a, 0xd1, 0x7d, 0x9d,
	0xd9, 0x24, 0x65, 0xaa, 0x8e, 0xf6, 0x21, 0x96, 0xdd, 0x89, 0x8a, 0x4f, 0xb7, 0x24, 0x4b, 0xd1,
	0xca, 0x03, 0x80, 0xa8, 0x4c, 0xd6, 0x29, 0xff, 0x1a, 0x64, 0x99, 0xef, 0xc5, 0x55, 0x66, 0x71,
	0x4c, 0x35, 0xbb, 0xbe, 0xa7, 0xa8, 0x86, 0xf9, 0x5e, 0xd3, 0x43, 0xaf, 0x41, 0x2e, 0x20, 0x87,
	0x8e, 0x3e, 0x27, 0x28, 0xf4, 0x05, 0x7b, 0x3e, 0x20, 0x87, 0xea, 0x38, 0x50, 0xf9, 0xa3, 0x05,
	0xc9, 0x82, 0x02, 0x6d, 0x4c, 0x00, 0x16, 0x6e, 0xbc, 0x3e, 0x25, 0x06, 0x22, 0xfd, 0xe6, 0xd6,
	0x29, 0xbd, 0x6d, 0x40, 0x56, 0xf5, 0x46, 0x3d, 0x53, 0x02, 0xcc, 0x06, 0xf1, 0x90, 0x1c, 0x2a,
	0x88, 0x80, 0x1c, 0x36, 0xbd, 0xca, 0xdf, 0x2c, 0x28, 0x99, 0x05, 0x56, 0x6c, 0x15, 0x6d, 0xd0,
	0xfb, 0x90, 0x56, 0x84, 0x67, 0x06, 0x76, 0x0e, 0xdf, 0x69, 0x55, 0xb4, 0x0d, 0x99, 0x03, 0xea,
	0x93, 0x98, 0x23, 0xdf, 0x3d, 0xeb, 0x4c, 0x32, 0xb1, 0x9d, 0x31, 0xeb, 0x6a, 0x6b, 0xf4, 0x0e,
	0x14, 0xe2, 0xd3, 0x77, 0xd3, 0x3b, 0x32, 0x69, 0x31, 0xd2, 0x48, 0x0a, 0x2a, 0x7f, 0x4e, 0x8f,
	0xfc, 0x62, 0x4a, 0x32, 0xc8, 0x9e, 0x91, 0x0c, 0xee, 0xc0, 0x02, 0x8f, 0x0c, 0xa3, 0x00, 0xbf,
	0x40, 0xd9, 0x52, 0x30, 0x86, 0x3a, 0xbc, 0x27, 0x69, 0x6c, 0xee, 0x47, 0xd0, 0xd8, 0x03, 0x58,
	0xd0, 0xb7, 0x2b, 0x51, 0xa9, 0xaa, 0x8a, 0x5f, 0xb5, 0x82, 0xd7, 0xce, 0xa8, 0x55, 0x47, 0x5e,
	0x19, 0x0f, 0x4c, 0x8e, 0x5a, 0x04, 0xda, 0x83, 0x62, 0xb2, 0xf4, 0x15, 0xe5, 0xcc, 0xd4, 0xb3,
	0xfa, 0x29, 0xb5, 0x6f, 0x5c, 0x58, 0x8d, 0x9b, 0x04, 0x7a, 0x3c, 0x62, 0xb2, 0x28, 0xfb, 0x7c,
	0x70, 0xee, 0xe6, 0xce, 0x46, 0x65, 0xef, 0x42, 0x51, 0xdf, 0x14, 0x62, 0x49, 0x1c, 0x16, 0xf8,
	0x43, 0x4d, 0xb6, 0xf1, 0x95, 0xca, 0x42, 0x2c, 0xda, 0x0d, 0xfc, 0xe1, 0x8b, 0x13, 0xc8, 0x4e,
	0x3a, 0x37, 0x5f, 0xca, 0x55, 0xfe, 0x91, 0x82, 0x65, 0x7d, 0xaa, 0xdf, 0x08, 0xbc, 0x96, 0x8b,
	0xa5, 0x3c, 0x71, 0x57, 0x7f, 0xf6, 0x69, 0x22, 0xab, 0xaf, 0xa2, 0xe3, 0x0a, 0xe2, 0xf6, 0x19,
	0x55, 0xe4, 0xc9, 0x4e, 0xe2, 0x45, 0xd1, 0x63, 0xd7, 0x97, 0xd4, 0xf1, 0x9d, 0x5e, 0x04, 0x7a,
	0xc2, 0x01, 0xe6, 0x5e, 0xb2, 0x03, 0xa4, 0x7e, 0xac, 0x03, 0x9c, 0xd8, 0xa8, 0xec, 0xa9, 0x1b,
	0xe5, 0xc0, 0xd2, 0x89, 0xe9, 0xa2, 0x1d, 0x98, 0x27, 0x81, 0xe4, 0x94, 0xc4, 0x0b, 0xf8, 0xde,
	0xb9, 0x1e, 0x34, 0x22, 0xa3, 0xf8, 0x98, 0x6d, 0x00, 0x4c, 0x2d, 0xf8, 0xdf, 0x39, 0x80, 0xed,
	0xa3, 0x90, 0x71, 0xa9, 0xb7, 0xf1, 0x1d, 0x55, 0x62, 0x09, 0x49, 0x83, 0xe8, 0x35, 0xc2, 0x4a,
	0xf0, 0x7a, 0x52, 0x80, 0xfe, 0x1f, 0x16, 0x54, 0x92, 0x73, 0x42, 0xbd, 0x39, 0x93, 0x47, 0xfe,
	0x82, 0x4e, 0x7f, 0x91, 0x20, 0x71, 0x4b, 0x9b, 0x7a, 0x91, 0x5b, 0xda, 0xd1, 0x3b, 0x07, 0x67,
	0x87, 0xc2, 0xb8, 0x56, 0xf2, 0x9d, 0xc3, 0x66, 0x87, 0x62, 0xb6, 0xc7, 0x90, 0xc9, 0x74, 0x9f,
	0xfd, 0xc9, 0x6f, 0xf8, 0x5e, 0x87, 0xbc, 0xcb, 0x7c, 0x47, 0xc9, 0x84, 0xbe, 0xe6, 0xcd, 0xdb,
	0x39, 0x97, 0xf9, 0x0f, 0xd5, 0xef, 0xca, 0xe7, 0xb0, 0xd4, 0x18, 0xf8, 0x6a, 0xf4, 0x9f, 0x73,
	0x1a, 0x87, 0xd0, 0xe8, 0xfd, 0xc9, 0x7a, 0xe1, 0xf7, 0xa7, 0xca, 0x3f, 0x53, 0x70, 0x55, 0xbf,
	0x0e, 0xc4, 0x6f, 0x17, 0x0f, 0x08, 0xef, 0xbc, 0x3c, 0x7c, 0x14, 0xc2, 0x92, 0x24, 0xfd, 0x90,
	0x71, 0xcc, 0x87, 0x8e, 0x79, 0x28, 0xd1, 0x61, 0xf6, 0x92, 0x1e, 0x5f, 0x4a, 0x23, 0xf4, 0x66,
	0x04, 0x8e, 0xba, 0x50, 0xc4, 0x9e, 0x47, 0xbc, 0x51, 0x6f, 0xa9, 0x97, 0xd7, 0xdb, 0x82, 0x46,
	0x8e, 0x7b, 0x7a, 0x91, 0x7b, 0x27, 0x55, 0xa7, 0xa8, 0x0f, 0x87, 0x7a, 0x47, 0x3a, 0x3f, 0x64,
	0xec, 0x79, 0xf5, 0xbb, 0xe9, 0x1d, 0xa1, 0x7b, 0xb0, 0xd8, 0x57, 0xab, 0x3f, 0xca, 0x7e, 0x17,
	0xa9, 0x81, 0x8f, 0x99, 0x36, 0xae, 0x7f, 0xfd, 0xaf, 0xd5, 0x4b, 0x5f, 0x3f, 0x5f, 0xb5, 0xbe,
	0x79, 0xbe, 0x6a, 0x7d, 0xfb, 0x7c, 0xd5, 0xfa, 0xee, 0xf9, 0xaa, 0xf5, 0xfb, 0xef, 0x57, 0x2f,
	0x7d, 0xf3, 0xfd, 0xea, 0xa5, 0x6f, 0xbf, 0x5f, 0xbd, 0xf4, 0x45, 0x21, 0xf1, 0xa8, 0xfc, 0xbf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x73, 0xf8, 0xb6, 0x9d, 0x66, 0x1e, 0x00, 0x00,
}

func (m *BackfillerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackfillerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackfillerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.UpdateChunkSizeThresholdBytes))
	i--
	dAtA[i] = 0x70
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x68
	i--
	if m.WriteAtBatchTimestamp {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.InitialSplits))
	i--
	dAtA[i] = 0x58
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size, err := m.ReadAsOf.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.IndexesToBackfill) > 0 {
		for iNdEx := len(m.IndexesToBackfill) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.IndexesToBackfill[iNdEx]))
			i--
			dAtA[i] = 0x40
		}
	}
	{
		size, err := m.WriteAsOf.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkSize))
	i--
	dAtA[i] = 0x28
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Duration))
	i--
	dAtA[i] = 0x20
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *JobProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobProgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobProgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.Slot))
	i--
	dAtA[i] = 0x18
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Contribution))))
	i--
	dAtA[i] = 0x15
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ReadImportDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadImportDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.InitialSplits))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i -= len(m.DatabasePrimaryRegion)
	copy(dAtA[i:], m.DatabasePrimaryRegion)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.DatabasePrimaryRegion)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x7a
	if len(m.ResumePos) > 0 {
		keysForResumePos := make([]int32, 0, len(m.ResumePos))
		for k := range m.ResumePos {
			keysForResumePos = append(keysForResumePos, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForResumePos)
		for iNdEx := len(keysForResumePos) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ResumePos[int32(keysForResumePos[iNdEx])]
			baseI := i
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForResumePos[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ReaderParallelism))
	i--
	dAtA[i] = 0x68
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.WalltimeNanos))
	i--
	dAtA[i] = 0x58
	i--
	if m.SkipMissingForeignKeys {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	if len(m.Tables) > 0 {
		keysForTables := make([]string, 0, len(m.Tables))
		for k := range m.Tables {
			keysForTables = append(keysForTables, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTables)
		for iNdEx := len(keysForTables) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tables[string(keysForTables[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForTables[iNdEx])
			copy(dAtA[i:], keysForTables[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(keysForTables[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.Format.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.Uri) > 0 {
		keysForUri := make([]int32, 0, len(m.Uri))
		for k := range m.Uri {
			keysForUri = append(keysForUri, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForUri)
		for iNdEx := len(keysForUri) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Uri[int32(keysForUri[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForUri[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	{
		size, err := m.Progress.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SampleSize))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}

func (m *ReadImportDataSpec_ImportTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadImportDataSpec_ImportTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadImportDataSpec_ImportTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TargetCols) > 0 {
		for iNdEx := len(m.TargetCols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TargetCols[iNdEx])
			copy(dAtA[i:], m.TargetCols[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.TargetCols[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamIngestionPartitionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionPartitionSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamIngestionPartitionSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.Address)
	copy(dAtA[i:], m.Address)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Address)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.SubscriptionToken)
	copy(dAtA[i:], m.SubscriptionToken)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.SubscriptionToken)))
	i--
	dAtA[i] = 0x12
	i -= len(m.PartitionID)
	copy(dAtA[i:], m.PartitionID)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.PartitionID)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StreamIngestionDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamIngestionDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.TenantRekey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.PartitionSpecs) > 0 {
		keysForPartitionSpecs := make([]string, 0, len(m.PartitionSpecs))
		for k := range m.PartitionSpecs {
			keysForPartitionSpecs = append(keysForPartitionSpecs, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForPartitionSpecs)
		for iNdEx := len(keysForPartitionSpecs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PartitionSpecs[string(keysForPartitionSpecs[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(keysForPartitionSpecs[iNdEx])
			copy(dAtA[i:], keysForPartitionSpecs[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(keysForPartitionSpecs[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.StreamID))
	i--
	dAtA[i] = 0x28
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x20
	i -= len(m.StreamAddress)
	copy(dAtA[i:], m.StreamAddress)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.StreamAddress)))
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *StreamIngestionFrontierSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamIngestionFrontierSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamIngestionFrontierSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StreamAddresses) > 0 {
		for iNdEx := len(m.StreamAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StreamAddresses[iNdEx])
			copy(dAtA[i:], m.StreamAddresses[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.StreamAddresses[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.SubscribingSQLInstances) > 0 {
		keysForSubscribingSQLInstances := make([]string, 0, len(m.SubscribingSQLInstances))
		for k := range m.SubscribingSQLInstances {
			keysForSubscribingSQLInstances = append(keysForSubscribingSQLInstances, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForSubscribingSQLInstances)
		for iNdEx := len(keysForSubscribingSQLInstances) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SubscribingSQLInstances[string(keysForSubscribingSQLInstances[iNdEx])]
			baseI := i
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(keysForSubscribingSQLInstances[iNdEx])
			copy(dAtA[i:], keysForSubscribingSQLInstances[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(keysForSubscribingSQLInstances[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.StreamID))
	i--
	dAtA[i] = 0x20
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x18
	if len(m.TrackedSpans) > 0 {
		for iNdEx := len(m.TrackedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrackedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.HighWaterAtStart.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BackupDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x58
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x52
	if len(m.PKIDs) > 0 {
		keysForPKIDs := make([]uint64, 0, len(m.PKIDs))
		for k := range m.PKIDs {
			keysForPKIDs = append(keysForPKIDs, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForPKIDs)
		for iNdEx := len(keysForPKIDs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PKIDs[uint64(keysForPKIDs[iNdEx])]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForPKIDs[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.BackupEndTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.BackupStartTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.MVCCFilter))
	i--
	dAtA[i] = 0x28
	if len(m.URIsByLocalityKV) > 0 {
		keysForURIsByLocalityKV := make([]string, 0, len(m.URIsByLocalityKV))
		for k := range m.URIsByLocalityKV {
			keysForURIsByLocalityKV = append(keysForURIsByLocalityKV, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForURIsByLocalityKV)
		for iNdEx := len(keysForURIsByLocalityKV) - 1; iNdEx >= 0; iNdEx-- {
			v := m.URIsByLocalityKV[string(keysForURIsByLocalityKV[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForURIsByLocalityKV[iNdEx])
			copy(dAtA[i:], keysForURIsByLocalityKV[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(keysForURIsByLocalityKV[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.DefaultURI)
	copy(dAtA[i:], m.DefaultURI)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.DefaultURI)))
	i--
	dAtA[i] = 0x1a
	if len(m.IntroducedSpans) > 0 {
		for iNdEx := len(m.IntroducedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IntroducedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RestoreFileSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreFileSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreFileSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Dir.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TableRekey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableRekey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableRekey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewDesc != nil {
		i -= len(m.NewDesc)
		copy(dAtA[i:], m.NewDesc)
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.NewDesc)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.OldID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TenantRekey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantRekey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantRekey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NewID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.OldID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RestoreSpanEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreSpanEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreSpanEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ProgressIdx))
	i--
	dAtA[i] = 0x18
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RestoreDataSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreDataSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreDataSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.ValidateOnly {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x30
	if len(m.TenantRekeys) > 0 {
		for iNdEx := len(m.TenantRekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TenantRekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PKIDs) > 0 {
		keysForPKIDs := make([]uint64, 0, len(m.PKIDs))
		for k := range m.PKIDs {
			keysForPKIDs = append(keysForPKIDs, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForPKIDs)
		for iNdEx := len(keysForPKIDs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PKIDs[uint64(keysForPKIDs[iNdEx])]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(keysForPKIDs[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TableRekeys) > 0 {
		for iNdEx := len(m.TableRekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableRekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.RestoreTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SplitAndScatterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitAndScatterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitAndScatterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.ValidateOnly {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x20
	if len(m.TenantRekeys) > 0 {
		for iNdEx := len(m.TenantRekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TenantRekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TableRekeys) > 0 {
		for iNdEx := len(m.TableRekeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableRekeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExportSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColNames) > 0 {
		for iNdEx := len(m.ColNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColNames[iNdEx])
			copy(dAtA[i:], m.ColNames[iNdEx])
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.ColNames[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	i -= len(m.UserProto)
	copy(dAtA[i:], m.UserProto)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.UserProto)))
	i--
	dAtA[i] = 0x32
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkSize))
	i--
	dAtA[i] = 0x28
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.ChunkRows))
	i--
	dAtA[i] = 0x20
	{
		size, err := m.Format.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i -= len(m.NamePattern)
	copy(dAtA[i:], m.NamePattern)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.NamePattern)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Destination)
	copy(dAtA[i:], m.Destination)
	i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(len(m.Destination)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BulkRowWriterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulkRowWriterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BulkRowWriterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexBackfillMergerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexBackfillMergerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexBackfillMergerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MergeTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.SpanIdx) > 0 {
		for iNdEx := len(m.SpanIdx) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.SpanIdx[iNdEx]))
			i--
			dAtA[i] = 0x28
		}
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AddedIndexes) > 0 {
		for iNdEx := len(m.AddedIndexes) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.AddedIndexes[iNdEx]))
			i--
			dAtA[i] = 0x18
		}
	}
	if len(m.TemporaryIndexes) > 0 {
		for iNdEx := len(m.TemporaryIndexes) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(m.TemporaryIndexes[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	{
		size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProcessorsBulkIo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintProcessorsBulkIo(dAtA []byte, offset int, v uint64) int {
	offset -= sovProcessorsBulkIo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BackfillerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.Type))
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.Duration))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkSize))
	l = m.WriteAsOf.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.IndexesToBackfill) > 0 {
		for _, e := range m.IndexesToBackfill {
			n += 1 + sovProcessorsBulkIo(uint64(e))
		}
	}
	l = m.ReadAsOf.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.InitialSplits))
	n += 2
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 1 + sovProcessorsBulkIo(uint64(m.UpdateChunkSizeThresholdBytes))
	return n
}

func (m *JobProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 5
	n += 1 + sovProcessorsBulkIo(uint64(m.Slot))
	return n
}

func (m *ReadImportDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.SampleSize))
	l = m.Progress.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Uri) > 0 {
		for k, v := range m.Uri {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = m.Format.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Tables) > 0 {
		for k, v := range m.Tables {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovProcessorsBulkIo(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	n += 2
	n += 1 + sovProcessorsBulkIo(uint64(m.WalltimeNanos))
	n += 1 + sovProcessorsBulkIo(uint64(m.ReaderParallelism))
	if len(m.ResumePos) > 0 {
		for k, v := range m.ResumePos {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + sovProcessorsBulkIo(uint64(v))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.Size()
			n += 2 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = len(m.DatabasePrimaryRegion)
	n += 2 + l + sovProcessorsBulkIo(uint64(l))
	n += 2 + sovProcessorsBulkIo(uint64(m.InitialSplits))
	n += 2 + sovProcessorsBulkIo(uint64(m.JobID))
	return n
}

func (m *ReadImportDataSpec_ImportTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	if len(m.TargetCols) > 0 {
		for _, s := range m.TargetCols {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *StreamIngestionPartitionSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartitionID)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.SubscriptionToken)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.Address)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *StreamIngestionDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.StreamAddress)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 1 + sovProcessorsBulkIo(uint64(m.StreamID))
	if len(m.PartitionSpecs) > 0 {
		for k, v := range m.PartitionSpecs {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + 1 + l + sovProcessorsBulkIo(uint64(l))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = m.TenantRekey.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Checkpoint.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *StreamIngestionFrontierSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HighWaterAtStart.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.TrackedSpans) > 0 {
		for _, e := range m.TrackedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 1 + sovProcessorsBulkIo(uint64(m.StreamID))
	if len(m.SubscribingSQLInstances) > 0 {
		for k, v := range m.SubscribingSQLInstances {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + 1 + sovProcessorsBulkIo(uint64(v))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.StreamAddresses) > 0 {
		for _, s := range m.StreamAddresses {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *BackupDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.IntroducedSpans) > 0 {
		for _, e := range m.IntroducedSpans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	l = len(m.DefaultURI)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.URIsByLocalityKV) > 0 {
		for k, v := range m.URIsByLocalityKV {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProcessorsBulkIo(uint64(len(k))) + 1 + len(v) + sovProcessorsBulkIo(uint64(len(v)))
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.MVCCFilter))
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	l = m.BackupStartTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.BackupEndTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.PKIDs) > 0 {
		for k, v := range m.PKIDs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	return n
}

func (m *RestoreFileSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Dir.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.Path)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *TableRekey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsBulkIo(uint64(m.OldID))
	if m.NewDesc != nil {
		l = len(m.NewDesc)
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	return n
}

func (m *TenantRekey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OldID.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.NewID.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *RestoreSpanEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.ProgressIdx))
	return n
}

func (m *RestoreDataSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RestoreTime.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovProcessorsBulkIo(uint64(l))
	}
	if len(m.TableRekeys) > 0 {
		for _, e := range m.TableRekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.PKIDs) > 0 {
		for k, v := range m.PKIDs {
			_ = k
			_ = v
			mapEntrySize := 1 + sovProcessorsBulkIo(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovProcessorsBulkIo(uint64(mapEntrySize))
		}
	}
	if len(m.TenantRekeys) > 0 {
		for _, e := range m.TenantRekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 2
	return n
}

func (m *SplitAndScatterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.TableRekeys) > 0 {
		for _, e := range m.TableRekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.TenantRekeys) > 0 {
		for _, e := range m.TenantRekeys {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	n += 1 + sovProcessorsBulkIo(uint64(m.JobID))
	n += 2
	return n
}

func (m *SplitAndScatterSpec_RestoreEntryChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *ExportSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = len(m.NamePattern)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	l = m.Format.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkRows))
	n += 1 + sovProcessorsBulkIo(uint64(m.ChunkSize))
	l = len(m.UserProto)
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.ColNames) > 0 {
		for _, s := range m.ColNames {
			l = len(s)
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	return n
}

func (m *BulkRowWriterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func (m *IndexBackfillMergerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Table.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	if len(m.TemporaryIndexes) > 0 {
		for _, e := range m.TemporaryIndexes {
			n += 1 + sovProcessorsBulkIo(uint64(e))
		}
	}
	if len(m.AddedIndexes) > 0 {
		for _, e := range m.AddedIndexes {
			n += 1 + sovProcessorsBulkIo(uint64(e))
		}
	}
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovProcessorsBulkIo(uint64(l))
		}
	}
	if len(m.SpanIdx) > 0 {
		for _, e := range m.SpanIdx {
			n += 1 + sovProcessorsBulkIo(uint64(e))
		}
	}
	l = m.MergeTimestamp.Size()
	n += 1 + l + sovProcessorsBulkIo(uint64(l))
	return n
}

func sovProcessorsBulkIo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProcessorsBulkIo(x uint64) (n int) {
	return sovProcessorsBulkIo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackfillerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackfillerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackfillerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BackfillerSpec_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteAsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WriteAsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IndexesToBackfill = append(m.IndexesToBackfill, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IndexesToBackfill) == 0 {
					m.IndexesToBackfill = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IndexesToBackfill = append(m.IndexesToBackfill, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexesToBackfill", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadAsOf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReadAsOf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialSplits", wireType)
			}
			m.InitialSplits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialSplits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteAtBatchTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WriteAtBatchTimestamp = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateChunkSizeThresholdBytes", wireType)
			}
			m.UpdateChunkSizeThresholdBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateChunkSizeThresholdBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contribution", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Contribution = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadImportDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadImportDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Progress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uri == nil {
				m.Uri = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uri[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tables == nil {
				m.Tables = make(map[string]*ReadImportDataSpec_ImportTable)
			}
			var mapkey string
			var mapvalue *ReadImportDataSpec_ImportTable
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ReadImportDataSpec_ImportTable{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tables[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMissingForeignKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMissingForeignKeys = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalltimeNanos", wireType)
			}
			m.WalltimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalltimeNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderParallelism", wireType)
			}
			m.ReaderParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReaderParallelism |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumePos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumePos == nil {
				m.ResumePos = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResumePos[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &descpb.TypeDescriptor{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabasePrimaryRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabasePrimaryRegion = github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialSplits", wireType)
			}
			m.InitialSplits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialSplits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadImportDataSpec_ImportTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &descpb.TableDescriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetCols = append(m.TargetCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionPartitionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionPartitionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionPartitionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionSpecs == nil {
				m.PartitionSpecs = make(map[string]StreamIngestionPartitionSpec)
			}
			var mapkey string
			mapvalue := &StreamIngestionPartitionSpec{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StreamIngestionPartitionSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PartitionSpecs[mapkey] = *mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantRekey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TenantRekey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamIngestionFrontierSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamIngestionFrontierSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamIngestionFrontierSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWaterAtStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HighWaterAtStart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackedSpans = append(m.TrackedSpans, roachpb.Span{})
			if err := m.TrackedSpans[len(m.TrackedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamID", wireType)
			}
			m.StreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscribingSQLInstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubscribingSQLInstances == nil {
				m.SubscribingSQLInstances = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubscribingSQLInstances[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamAddresses = append(m.StreamAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntroducedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntroducedSpans = append(m.IntroducedSpans, roachpb.Span{})
			if err := m.IntroducedSpans[len(m.IntroducedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIsByLocalityKV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URIsByLocalityKV == nil {
				m.URIsByLocalityKV = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.URIsByLocalityKV[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCFilter", wireType)
			}
			m.MVCCFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MVCCFilter |= roachpb.MVCCFilter(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackupStartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackupEndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PKIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PKIDs == nil {
				m.PKIDs = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PKIDs[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreFileSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreFileSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreFileSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dir.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableRekey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRekey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRekey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldID", wireType)
			}
			m.OldID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDesc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDesc = append(m.NewDesc[:0], dAtA[iNdEx:postIndex]...)
			if m.NewDesc == nil {
				m.NewDesc = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantRekey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantRekey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantRekey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OldID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreSpanEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreSpanEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreSpanEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, RestoreFileSpec{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressIdx", wireType)
			}
			m.ProgressIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProgressIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreDataSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreDataSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreDataSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RestoreTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &roachpb.FileEncryptionOptions{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableRekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableRekeys = append(m.TableRekeys, TableRekey{})
			if err := m.TableRekeys[len(m.TableRekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PKIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PKIDs == nil {
				m.PKIDs = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProcessorsBulkIo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PKIDs[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantRekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantRekeys = append(m.TenantRekeys, TenantRekey{})
			if err := m.TenantRekeys[len(m.TenantRekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidateOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitAndScatterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitAndScatterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitAndScatterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, SplitAndScatterSpec_RestoreEntryChunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableRekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableRekeys = append(m.TableRekeys, TableRekey{})
			if err := m.TableRekeys[len(m.TableRekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantRekeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantRekeys = append(m.TenantRekeys, TenantRekey{})
			if err := m.TenantRekeys[len(m.TenantRekeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidateOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitAndScatterSpec_RestoreEntryChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreEntryChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreEntryChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, RestoreSpanEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamePattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamePattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Format.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkRows", wireType)
			}
			m.ChunkRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColNames = append(m.ColNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulkRowWriterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulkRowWriterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulkRowWriterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexBackfillMergerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexBackfillMergerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexBackfillMergerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TemporaryIndexes = append(m.TemporaryIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TemporaryIndexes) == 0 {
					m.TemporaryIndexes = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TemporaryIndexes = append(m.TemporaryIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryIndexes", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddedIndexes = append(m.AddedIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AddedIndexes) == 0 {
					m.AddedIndexes = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.IndexID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddedIndexes = append(m.AddedIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedIndexes", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, roachpb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SpanIdx = append(m.SpanIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsBulkIo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsBulkIo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SpanIdx) == 0 {
					m.SpanIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsBulkIo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SpanIdx = append(m.SpanIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanIdx", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MergeTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsBulkIo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsBulkIo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsBulkIo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsBulkIo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsBulkIo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsBulkIo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProcessorsBulkIo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProcessorsBulkIo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProcessorsBulkIo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsBulkIo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProcessorsBulkIo = fmt.Errorf("proto: unexpected end of group")
)
