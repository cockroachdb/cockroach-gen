// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/sessiondatapb/session_data.proto

package sessiondatapb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_security_username "github.com/cockroachdb/cockroach/pkg/security/username"
	lex "github.com/cockroachdb/cockroach/pkg/sql/lex"
	duration "github.com/cockroachdb/cockroach/pkg/util/duration"
	pgdate "github.com/cockroachdb/cockroach/pkg/util/timeutil/pgdate"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VectorizeExecMode controls if an when the Executor executes queries using
// the columnar execution engine.
type VectorizeExecMode int32

const (
	// VectorizeUnset means the VectorizeExecMode wasn't explicitly set. Having
	// the first enum value as zero is required by proto3. This is mapped to
	// VectorizeOn.
	VectorizeUnset VectorizeExecMode = 0
	// VectorizeOn means that any supported queries will be run using the
	// columnar execution.
	VectorizeOn VectorizeExecMode = 2
	// VectorizeExperimentalAlways means that we attempt to vectorize all
	// queries; unsupported queries will fail. Mostly used for testing.
	VectorizeExperimentalAlways VectorizeExecMode = 3
	// VectorizeOff means that columnar execution is disabled.
	VectorizeOff VectorizeExecMode = 4
)

var VectorizeExecMode_name = map[int32]string{
	0: "unset",
	2: "on",
	3: "experimental_always",
	4: "off",
}

var VectorizeExecMode_value = map[string]int32{
	"unset":               0,
	"on":                  2,
	"experimental_always": 3,
	"off":                 4,
}

func (VectorizeExecMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9fa1c5a4e61eec38, []int{0}
}

// SessionData contains session parameters that are easily serializable and are
// required to be propagated to the remote nodes for the correct execution of
// DistSQL flows.
type SessionData struct {
	// Database indicates the "current" database for the purpose of resolving
	// names.
	Database string `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	// ApplicationName is the name of the application running the current
	// session. This can be used for logging and per-application statistics.
	ApplicationName string `protobuf:"bytes,2,opt,name=application_name,json=applicationName,proto3" json:"application_name,omitempty"`
	// User is the name of the user logged into the session.
	UserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,3,opt,name=user_proto,json=userProto,proto3,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"user_proto,omitempty"`
	// DataConversion gives access to the data conversion configuration.
	DataConversionConfig DataConversionConfig `protobuf:"bytes,4,opt,name=data_conversion_config,json=dataConversionConfig,proto3" json:"data_conversion_config"`
	// VectorizeMode indicates which kinds of queries to use vectorized execution
	// engine for.
	VectorizeMode VectorizeExecMode `protobuf:"varint,5,opt,name=vectorize_mode,json=vectorizeMode,proto3,enum=cockroach.sql.sessiondatapb.VectorizeExecMode" json:"vectorize_mode,omitempty"`
	// TestingVectorizeInjectPanics indicates whether random panics are injected
	// into the vectorized flow execution. The goal of such behavior is making
	// sure that errors that are propagated as panics in the vectorized engine
	// are caught in all scenarios.
	TestingVectorizeInjectPanics bool `protobuf:"varint,6,opt,name=testing_vectorize_inject_panics,json=testingVectorizeInjectPanics,proto3" json:"testing_vectorize_inject_panics,omitempty"`
	// DefaultIntSize specifies the size in bits or bytes (preferred) of how a
	// "naked" INT type should be parsed.
	DefaultIntSize int32 `protobuf:"varint,7,opt,name=default_int_size,json=defaultIntSize,proto3" json:"default_int_size,omitempty"`
	// The name of the location according to whose current timezone we're going to
	// parse timestamps. Used to initialize sessiondata.SessionData.Location on
	// the remote nodes.
	//
	// Note that the current serialization of the time.Location objects as
	// strings has many drawbacks which could lead to unstable computation on the
	// remote nodes. See #36864 and
	// https://github.com/cockroachdb/cockroach/pull/55377#issuecomment-707794695
	// for more details.
	Location string `protobuf:"bytes,8,opt,name=location,proto3" json:"location,omitempty"`
	// SearchPath is a list of namespaces to search builtins in. Used to
	// initialize sessiondata.SessionData.SearchPath on the remote nodes.
	SearchPath          []string `protobuf:"bytes,9,rep,name=search_path,json=searchPath,proto3" json:"search_path,omitempty"`
	TemporarySchemaName string   `protobuf:"bytes,10,opt,name=temporary_schema_name,json=temporarySchemaName,proto3" json:"temporary_schema_name,omitempty"`
	// SeqState gives access to the SQL sequences that have been manipulated by
	// the session.
	SeqState SequenceState `protobuf:"bytes,11,opt,name=seq_state,json=seqState,proto3" json:"seq_state"`
	// WorkMemLimit determines how much RAM (in bytes) a single operation of a
	// single query can use before it has to spill to disk.
	WorkMemLimit int64 `protobuf:"varint,12,opt,name=WorkMemLimit,proto3" json:"WorkMemLimit,omitempty"`
	// LockTimeout is the maximum amount of time that a query will wait while
	// attempting to acquire a lock on a key or while blocking on an existing
	// lock in order to perform a non-locking read on a key.
	LockTimeout time.Duration `protobuf:"bytes,15,opt,name=lock_timeout,json=lockTimeout,proto3,stdduration" json:"lock_timeout"`
	// Internal is true if this query came from InternalExecutor or an internal
	// planner.
	Internal bool `protobuf:"varint,16,opt,name=internal,proto3" json:"internal,omitempty"`
	// OnUpdateRehomeRowEnabled controls whether the ON UPDATE rehome_row()
	// will actually trigger on row updates.
	OnUpdateRehomeRowEnabled bool `protobuf:"varint,17,opt,name=on_update_rehome_row_enabled,json=onUpdateRehomeRowEnabled,proto3" json:"on_update_rehome_row_enabled,omitempty"`
	// JoinReaderOrderingStrategyBatchSize is the size limit on the input rows to
	// the joinReader processor (when ordering is required to be maintained) to
	// construct a single lookup KV batch.
	JoinReaderOrderingStrategyBatchSize int64 `protobuf:"varint,18,opt,name=join_reader_ordering_strategy_batch_size,json=joinReaderOrderingStrategyBatchSize,proto3" json:"join_reader_ordering_strategy_batch_size,omitempty"`
	// ParallelizeMultiKeyLookupJoinsEnabled is true when the join reader should
	// parallelize lookup batches under all circumstances. Enabling this will
	// increase the speed of lookup joins when each input row might get multiple
	// looked up rows at the cost of increased memory usage.
	ParallelizeMultiKeyLookupJoinsEnabled bool `protobuf:"varint,19,opt,name=parallelize_multi_key_lookup_joins_enabled,json=parallelizeMultiKeyLookupJoinsEnabled,proto3" json:"parallelize_multi_key_lookup_joins_enabled,omitempty"`
	// TrigramSimilarityThreshold configures the value that's used to compare
	// trigram similarities to in order to evaluate the string % string overload.
	TrigramSimilarityThreshold float64 `protobuf:"fixed64,20,opt,name=trigram_similarity_threshold,json=trigramSimilarityThreshold,proto3" json:"trigram_similarity_threshold,omitempty"`
	// Troubleshooting mode determines whether we refuse to do additional work
	// with the query (i.e. collect & emit telemetry data). Troubleshooting mode
	// is disabled by default.
	TroubleshootingMode bool `protobuf:"varint,21,opt,name=troubleshooting_mode,json=troubleshootingMode,proto3" json:"troubleshooting_mode,omitempty"`
	// JoinReaderNoOrderingStrategyBatchSize is the size limit on the input rows
	// to the joinReader processor (when ordering is **not** required to be
	// maintained) to construct a single lookup KV batch.
	JoinReaderNoOrderingStrategyBatchSize int64 `protobuf:"varint,22,opt,name=join_reader_no_ordering_strategy_batch_size,json=joinReaderNoOrderingStrategyBatchSize,proto3" json:"join_reader_no_ordering_strategy_batch_size,omitempty"`
	// JoinReaderIndexJoinStrategyBatchSize is the size limit on the input rows
	// to the joinReader processor (when performing index joins) to construct a
	// single lookup KV batch.
	JoinReaderIndexJoinStrategyBatchSize int64 `protobuf:"varint,23,opt,name=join_reader_index_join_strategy_batch_size,json=joinReaderIndexJoinStrategyBatchSize,proto3" json:"join_reader_index_join_strategy_batch_size,omitempty"`
	// IndexJoinStreamerBatchSize is the size limit on the input rows to the
	// ColIndexJoin operator (when it is using the Streamer API) to construct a
	// single lookup KV batch.
	IndexJoinStreamerBatchSize int64 `protobuf:"varint,24,opt,name=index_join_streamer_batch_size,json=indexJoinStreamerBatchSize,proto3" json:"index_join_streamer_batch_size,omitempty"`
	// StreamerAlwaysMaintainOrdering indicates that the SQL users of the Streamer
	// should always ask it to maintain the ordering, even when it might not be
	// strictly necessary for the query.
	//
	// This session variable is introduced as a possible workaround in case we
	// have more bugs like #113013.
	StreamerAlwaysMaintainOrdering bool `protobuf:"varint,27,opt,name=streamer_always_maintain_ordering,json=streamerAlwaysMaintainOrdering,proto3" json:"streamer_always_maintain_ordering,omitempty"`
}

func (m *SessionData) Reset()         { *m = SessionData{} }
func (m *SessionData) String() string { return proto.CompactTextString(m) }
func (*SessionData) ProtoMessage()    {}
func (*SessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa1c5a4e61eec38, []int{0}
}
func (m *SessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionData.Merge(m, src)
}
func (m *SessionData) XXX_Size() int {
	return m.Size()
}
func (m *SessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionData.DiscardUnknown(m)
}

var xxx_messageInfo_SessionData proto.InternalMessageInfo

// DataConversionConfig contains the parameters that influence the output
// of certain data types as strings or bytes.
type DataConversionConfig struct {
	// BytesEncodeFormat indicates how to encode byte arrays when converting to
	// string.
	BytesEncodeFormat lex.BytesEncodeFormat `protobuf:"varint,1,opt,name=bytes_encode_format,json=bytesEncodeFormat,proto3,enum=cockroach.sql.sessiondatapb.BytesEncodeFormat" json:"bytes_encode_format,omitempty"`
	// ExtraFloatDigits indicates the number of digits beyond the standard number
	// to use for float conversions.This must be set to a value between -15 and
	// 3, inclusive.
	ExtraFloatDigits int32 `protobuf:"varint,2,opt,name=extra_float_digits,json=extraFloatDigits,proto3" json:"extra_float_digits,omitempty"`
	// IntervalStyle indicates the style to parse and display intervals as.
	IntervalStyle duration.IntervalStyle `protobuf:"varint,3,opt,name=interval_style,json=intervalStyle,proto3,enum=cockroach.util.duration.IntervalStyle" json:"interval_style,omitempty"`
	// DateStyle indicates the style to parse and display dates as.
	DateStyle pgdate.DateStyle `protobuf:"bytes,4,opt,name=date_style,json=dateStyle,proto3" json:"date_style"`
}

func (m *DataConversionConfig) Reset()         { *m = DataConversionConfig{} }
func (m *DataConversionConfig) String() string { return proto.CompactTextString(m) }
func (*DataConversionConfig) ProtoMessage()    {}
func (*DataConversionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa1c5a4e61eec38, []int{1}
}
func (m *DataConversionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataConversionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataConversionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataConversionConfig.Merge(m, src)
}
func (m *DataConversionConfig) XXX_Size() int {
	return m.Size()
}
func (m *DataConversionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DataConversionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DataConversionConfig proto.InternalMessageInfo

// SequenceState is used to marshall the sessiondata.SequenceState struct.
type SequenceState struct {
	Seqs []*SequenceState_Seq `protobuf:"bytes,1,rep,name=seqs,proto3" json:"seqs,omitempty"`
	// last_seq_incremented is the id of the last sequence incremented by the
	// session. This field is filled in iff seqs is not empty.
	LastSeqIncremented uint32 `protobuf:"varint,2,opt,name=last_seq_incremented,json=lastSeqIncremented,proto3" json:"last_seq_incremented,omitempty"`
}

func (m *SequenceState) Reset()         { *m = SequenceState{} }
func (m *SequenceState) String() string { return proto.CompactTextString(m) }
func (*SequenceState) ProtoMessage()    {}
func (*SequenceState) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa1c5a4e61eec38, []int{2}
}
func (m *SequenceState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceState.Merge(m, src)
}
func (m *SequenceState) XXX_Size() int {
	return m.Size()
}
func (m *SequenceState) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceState.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceState proto.InternalMessageInfo

// Seq represents the last value of one sequence modified by the session.
type SequenceState_Seq struct {
	SeqID     uint32 `protobuf:"varint,1,opt,name=seq_id,json=seqId,proto3" json:"seq_id,omitempty"`
	LatestVal int64  `protobuf:"varint,2,opt,name=latest_val,json=latestVal,proto3" json:"latest_val,omitempty"`
}

func (m *SequenceState_Seq) Reset()         { *m = SequenceState_Seq{} }
func (m *SequenceState_Seq) String() string { return proto.CompactTextString(m) }
func (*SequenceState_Seq) ProtoMessage()    {}
func (*SequenceState_Seq) Descriptor() ([]byte, []int) {
	return fileDescriptor_9fa1c5a4e61eec38, []int{2, 0}
}
func (m *SequenceState_Seq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceState_Seq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceState_Seq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceState_Seq.Merge(m, src)
}
func (m *SequenceState_Seq) XXX_Size() int {
	return m.Size()
}
func (m *SequenceState_Seq) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceState_Seq.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceState_Seq proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.sessiondatapb.VectorizeExecMode", VectorizeExecMode_name, VectorizeExecMode_value)
	proto.RegisterType((*SessionData)(nil), "cockroach.sql.sessiondatapb.SessionData")
	proto.RegisterType((*DataConversionConfig)(nil), "cockroach.sql.sessiondatapb.DataConversionConfig")
	proto.RegisterType((*SequenceState)(nil), "cockroach.sql.sessiondatapb.SequenceState")
	proto.RegisterType((*SequenceState_Seq)(nil), "cockroach.sql.sessiondatapb.SequenceState.Seq")
}

func init() {
	proto.RegisterFile("sql/sessiondatapb/session_data.proto", fileDescriptor_9fa1c5a4e61eec38)
}

var fileDescriptor_9fa1c5a4e61eec38 = []byte{
	// 1295 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x55, 0xcf, 0x72, 0x13, 0x47,
	0x13, 0xd7, 0x5a, 0x36, 0x9f, 0x34, 0xb2, 0x65, 0x31, 0x36, 0xb0, 0x08, 0x23, 0x0b, 0x7f, 0x90,
	0x12, 0x4e, 0x4a, 0x0a, 0xce, 0x25, 0xa7, 0x54, 0x22, 0x6c, 0xa7, 0x04, 0x18, 0xc8, 0x0a, 0x93,
	0x84, 0x43, 0xa6, 0x46, 0xbb, 0x2d, 0x69, 0xf0, 0xec, 0x8e, 0x34, 0x33, 0x32, 0x16, 0x4f, 0x90,
	0xf2, 0x29, 0xc7, 0x5c, 0x7c, 0x4a, 0x0e, 0x39, 0xe6, 0x1d, 0x72, 0xe1, 0x92, 0x2a, 0x8e, 0x9c,
	0x48, 0x62, 0x1e, 0x22, 0x55, 0x39, 0xa5, 0x66, 0xb4, 0x5a, 0xc9, 0x86, 0x98, 0xd3, 0x4e, 0x77,
	0xff, 0xfa, 0x37, 0xbd, 0xfd, 0x67, 0x1a, 0x5d, 0x57, 0x7d, 0x5e, 0x53, 0xa0, 0x14, 0x13, 0x51,
	0x40, 0x35, 0xed, 0xb5, 0xc6, 0x12, 0x31, 0x62, 0xb5, 0x27, 0x85, 0x16, 0xf8, 0x8a, 0x2f, 0xfc,
	0x3d, 0x29, 0xa8, 0xdf, 0xad, 0xaa, 0x3e, 0xaf, 0x9e, 0xc0, 0x17, 0x97, 0x0d, 0x05, 0x87, 0x83,
	0x1a, 0x44, 0xbe, 0x08, 0x60, 0xe4, 0x52, 0x5c, 0x19, 0x68, 0xc6, 0x6b, 0xc1, 0x40, 0x52, 0xcd,
	0x44, 0x94, 0x1c, 0x62, 0xeb, 0x35, 0x6b, 0xd5, 0x2c, 0x04, 0x7b, 0xe8, 0x75, 0x02, 0xaa, 0x21,
	0xfe, 0xc4, 0x90, 0xe5, 0x8e, 0xe8, 0x08, 0x7b, 0xac, 0x99, 0x53, 0xac, 0x2d, 0x75, 0x84, 0xe8,
	0x70, 0xa8, 0x59, 0xa9, 0x35, 0x68, 0x9f, 0x22, 0x5e, 0xfb, 0x3b, 0x87, 0x72, 0xcd, 0x51, 0x78,
	0x9b, 0x54, 0x53, 0x5c, 0x44, 0x19, 0x13, 0x66, 0x8b, 0x2a, 0x70, 0x9d, 0xb2, 0x53, 0xc9, 0x7a,
	0x89, 0x8c, 0x6f, 0xa2, 0x02, 0xed, 0xf5, 0x38, 0xf3, 0x2d, 0x01, 0x89, 0x68, 0x08, 0xee, 0x8c,
	0xc5, 0x2c, 0x4e, 0xe9, 0xef, 0xd3, 0x10, 0xf0, 0x53, 0x84, 0x06, 0x0a, 0x24, 0xb1, 0x97, 0xb8,
	0x69, 0x03, 0xaa, 0xdf, 0xfd, 0xe7, 0xf5, 0xea, 0x97, 0x1d, 0xa6, 0xbb, 0x83, 0x56, 0xd5, 0x17,
	0x61, 0x2d, 0xc9, 0x51, 0xd0, 0x9a, 0x9c, 0x6b, 0xbd, 0xbd, 0x4e, 0x4d, 0x81, 0x3f, 0x90, 0x4c,
	0x0f, 0x6b, 0x86, 0xc3, 0x5c, 0x53, 0x6d, 0x7e, 0x75, 0x6f, 0x37, 0x3e, 0x3f, 0x34, 0x94, 0x5e,
	0xd6, 0x98, 0xec, 0x11, 0x87, 0xe8, 0xa2, 0x09, 0x91, 0xf8, 0x22, 0xda, 0x07, 0x69, 0x4b, 0xe1,
	0x8b, 0xa8, 0xcd, 0x3a, 0xee, 0x6c, 0xd9, 0xa9, 0xe4, 0x36, 0x6e, 0x55, 0xcf, 0xa8, 0x46, 0xd5,
	0xfc, 0xf5, 0xed, 0xc4, 0xf3, 0xb6, 0x75, 0xac, 0xcf, 0xbe, 0x78, 0xbd, 0x9a, 0xf2, 0x96, 0x83,
	0x77, 0xd8, 0xf0, 0x2e, 0xca, 0xef, 0x83, 0xaf, 0x85, 0x64, 0xcf, 0x81, 0x84, 0x22, 0x00, 0x77,
	0xae, 0xec, 0x54, 0xf2, 0x1b, 0xd5, 0x33, 0xaf, 0x79, 0x3c, 0x76, 0xd9, 0x3a, 0x00, 0x7f, 0x47,
	0x04, 0xe0, 0x2d, 0x24, 0x2c, 0x46, 0xc4, 0x5b, 0x68, 0x55, 0x83, 0xd2, 0x2c, 0xea, 0x90, 0x09,
	0x3d, 0x8b, 0x9e, 0x82, 0xaf, 0x49, 0x8f, 0x46, 0xcc, 0x57, 0xee, 0xb9, 0xb2, 0x53, 0xc9, 0x78,
	0x2b, 0x31, 0x2c, 0x61, 0x6c, 0x58, 0xd0, 0x43, 0x8b, 0xc1, 0x15, 0x54, 0x08, 0xa0, 0x4d, 0x07,
	0x5c, 0x13, 0x16, 0x69, 0xa2, 0xd8, 0x73, 0x70, 0xff, 0x57, 0x76, 0x2a, 0x73, 0x5e, 0x3e, 0xd6,
	0x37, 0x22, 0xdd, 0x64, 0xcf, 0xc1, 0x54, 0x9a, 0x8b, 0x51, 0xc9, 0xdc, 0xcc, 0xa8, 0xd2, 0x63,
	0x19, 0xaf, 0xa2, 0x9c, 0x02, 0x2a, 0xfd, 0x2e, 0xe9, 0x51, 0xdd, 0x75, 0xb3, 0xe5, 0x74, 0x25,
	0xeb, 0xa1, 0x91, 0xea, 0x21, 0xd5, 0x5d, 0xbc, 0x81, 0x2e, 0x68, 0x08, 0x7b, 0x42, 0x52, 0x39,
	0x24, 0xca, 0xef, 0x42, 0x48, 0x47, 0xfd, 0x80, 0x2c, 0xd3, 0x52, 0x62, 0x6c, 0x5a, 0x9b, 0xed,
	0x89, 0x1d, 0x94, 0x55, 0xd0, 0x27, 0x4a, 0x53, 0x0d, 0x6e, 0xce, 0x96, 0x66, 0xfd, 0xcc, 0x9c,
	0x35, 0xa1, 0x3f, 0x80, 0xc8, 0x87, 0xa6, 0xf1, 0x88, 0x6b, 0x92, 0x51, 0xd0, 0xb7, 0x32, 0x5e,
	0x43, 0xf3, 0x5f, 0x0b, 0xb9, 0xb7, 0x03, 0xe1, 0x3d, 0x16, 0x32, 0xed, 0xce, 0x97, 0x9d, 0x4a,
	0xda, 0x3b, 0xa1, 0xc3, 0xdb, 0x68, 0x9e, 0x0b, 0x7f, 0x8f, 0x98, 0xc1, 0x11, 0x03, 0xed, 0x2e,
	0xda, 0x5b, 0x2f, 0x57, 0x47, 0x43, 0x51, 0x1d, 0x0f, 0x45, 0x75, 0x33, 0x1e, 0x8a, 0x7a, 0xc6,
	0x5c, 0xf2, 0xe3, 0x1f, 0xab, 0x8e, 0x97, 0x33, 0x8e, 0x8f, 0x46, 0x7e, 0x26, 0x57, 0x2c, 0xd2,
	0xa6, 0xff, 0xb8, 0x5b, 0xb0, 0x55, 0x48, 0x64, 0xfc, 0x19, 0x5a, 0x11, 0x11, 0x19, 0xf4, 0xcc,
	0x28, 0x12, 0x09, 0x5d, 0x11, 0x02, 0x91, 0xe2, 0x19, 0x81, 0x88, 0xb6, 0x38, 0x04, 0xee, 0x79,
	0x8b, 0x77, 0x45, 0xb4, 0x6b, 0x21, 0x9e, 0x45, 0x78, 0xe2, 0xd9, 0xd6, 0xc8, 0x8e, 0x77, 0x51,
	0xe5, 0xa9, 0x60, 0x11, 0x91, 0x40, 0x03, 0x90, 0x44, 0xc8, 0x00, 0xa4, 0xe9, 0x02, 0xa5, 0x25,
	0xd5, 0xd0, 0x19, 0x92, 0x16, 0xd5, 0x7e, 0x77, 0x54, 0x49, 0x6c, 0xff, 0xf1, 0xff, 0x06, 0xef,
	0x59, 0xf8, 0x83, 0x18, 0xdd, 0x8c, 0xc1, 0x75, 0x83, 0xb5, 0xe5, 0xfd, 0x16, 0xad, 0xf7, 0xa8,
	0xa4, 0x9c, 0x03, 0xb7, 0x8d, 0x3a, 0xe0, 0x9a, 0x91, 0x3d, 0x18, 0x12, 0x2e, 0xc4, 0xde, 0xa0,
	0x47, 0x0c, 0x87, 0x4a, 0x82, 0x5c, 0xb2, 0x41, 0xde, 0x98, 0xf2, 0xd8, 0x31, 0x0e, 0x77, 0x61,
	0x78, 0xcf, 0xc2, 0xef, 0x18, 0xf4, 0x38, 0xe2, 0xcf, 0xd1, 0x8a, 0x96, 0xac, 0x23, 0x69, 0x48,
	0x14, 0x0b, 0x19, 0xa7, 0x66, 0x56, 0x89, 0xee, 0x4a, 0x50, 0x5d, 0xc1, 0x03, 0x77, 0xb9, 0xec,
	0x54, 0x1c, 0xaf, 0x18, 0x63, 0x9a, 0x09, 0xe4, 0xd1, 0x18, 0x81, 0x6f, 0xa1, 0x65, 0x2d, 0xc5,
	0xa0, 0xc5, 0x8d, 0x2c, 0x6c, 0xd3, 0xdb, 0x49, 0xba, 0x60, 0xc3, 0x58, 0x3a, 0x65, 0xb3, 0xf3,
	0xf1, 0x04, 0x7d, 0x38, 0x9d, 0xa6, 0x48, 0x9c, 0x9d, 0xa9, 0x8b, 0x36, 0x53, 0x37, 0x26, 0x99,
	0xba, 0x2f, 0xfe, 0x3b, 0x57, 0xdf, 0xa0, 0xf5, 0x69, 0x6e, 0x16, 0x05, 0x70, 0x60, 0x13, 0xf4,
	0x4e, 0xea, 0x4b, 0x96, 0xfa, 0xfa, 0x84, 0xba, 0x61, 0xf0, 0x26, 0x43, 0x6f, 0x33, 0xd7, 0x51,
	0xe9, 0x24, 0x1b, 0xd0, 0x10, 0xe4, 0x34, 0x9b, 0x6b, 0xd9, 0x8a, 0x6c, 0x8a, 0xc3, 0x62, 0x26,
	0x1c, 0x0d, 0x74, 0x2d, 0x71, 0xa4, 0xfc, 0x19, 0x1d, 0x2a, 0x12, 0x52, 0x16, 0x69, 0xca, 0xa2,
	0x24, 0x07, 0xee, 0x15, 0x9b, 0xb9, 0xd2, 0x18, 0xf8, 0x85, 0xc5, 0xed, 0xc4, 0xb0, 0xf1, 0x9f,
	0xdf, 0x99, 0xcd, 0x2c, 0x14, 0xf2, 0x77, 0x66, 0x33, 0xf9, 0xc2, 0xe2, 0xda, 0x6f, 0x33, 0x68,
	0xf9, 0x5d, 0x8f, 0x1f, 0xfe, 0x0e, 0x2d, 0xb5, 0x86, 0x1a, 0x4c, 0x73, 0x98, 0xfd, 0x44, 0xda,
	0x42, 0x86, 0x54, 0xdb, 0x6d, 0xf0, 0xbe, 0x57, 0xae, 0x6e, 0xfc, 0xb6, 0xac, 0xdb, 0xb6, 0xf5,
	0xf2, 0xce, 0xb7, 0x4e, 0xab, 0xf0, 0x47, 0x08, 0xc3, 0x81, 0x96, 0x94, 0xb4, 0xb9, 0xa0, 0x9a,
	0x04, 0xac, 0xc3, 0xb4, 0xb2, 0x8b, 0x64, 0xce, 0x2b, 0x58, 0xcb, 0xb6, 0x31, 0x6c, 0x5a, 0x3d,
	0xde, 0x41, 0x79, 0x3b, 0x6a, 0xfb, 0x94, 0x13, 0xa5, 0x87, 0x1c, 0xec, 0x36, 0xc9, 0x6f, 0x7c,
	0x30, 0x15, 0x88, 0xd9, 0x89, 0xd5, 0x64, 0xb1, 0x35, 0x62, 0x78, 0xd3, 0xa0, 0xbd, 0x05, 0x36,
	0x2d, 0xe2, 0xfb, 0x08, 0xd9, 0x41, 0x1d, 0x51, 0x8d, 0x16, 0xc4, 0xcd, 0xd3, 0x54, 0xe3, 0x3d,
	0x5b, 0x8d, 0x17, 0xec, 0x26, 0xd5, 0x60, 0xdd, 0xe3, 0x47, 0x28, 0x1b, 0x8c, 0x15, 0x6b, 0xbf,
	0x3b, 0x68, 0xe1, 0xc4, 0x3b, 0x85, 0xeb, 0x68, 0x56, 0x41, 0x5f, 0xb9, 0x4e, 0x39, 0x5d, 0xc9,
	0xbd, 0x27, 0x5f, 0x27, 0x3c, 0x8d, 0xe4, 0x59, 0x5f, 0xfc, 0x31, 0x5a, 0xe6, 0x54, 0x69, 0x62,
	0xde, 0x4b, 0x16, 0xf9, 0x12, 0x42, 0x88, 0x34, 0x04, 0x36, 0x49, 0x0b, 0x1e, 0x36, 0xb6, 0x26,
	0xf4, 0x1b, 0x13, 0x4b, 0x71, 0x1b, 0xa5, 0x9b, 0xd0, 0xc7, 0x65, 0x74, 0xce, 0xfa, 0x04, 0xb6,
	0x5c, 0x0b, 0xf5, 0xec, 0xf1, 0xeb, 0xd5, 0x39, 0x03, 0xdd, 0xf4, 0xe6, 0x14, 0xf4, 0x1b, 0x01,
	0xbe, 0x8a, 0x10, 0xa7, 0x66, 0x85, 0x90, 0x7d, 0xca, 0x2d, 0x61, 0xda, 0xcb, 0x8e, 0x34, 0x8f,
	0x29, 0x5f, 0xff, 0xd5, 0x41, 0xe7, 0xdf, 0xda, 0x55, 0xf8, 0x2a, 0x9a, 0x1b, 0x44, 0x0a, 0x74,
	0x21, 0x55, 0xc4, 0x87, 0x47, 0xe5, 0x7c, 0x82, 0xd8, 0x35, 0x5a, 0x7c, 0x09, 0xcd, 0x88, 0xa8,
	0x30, 0x53, 0x5c, 0x3c, 0x3c, 0x2a, 0xe7, 0x12, 0xdb, 0x83, 0x08, 0x7f, 0x8a, 0x96, 0xe0, 0xa0,
	0x07, 0x92, 0x99, 0x28, 0x29, 0x8f, 0xdb, 0xb7, 0x90, 0x2e, 0xae, 0x1e, 0x1e, 0x95, 0xaf, 0x4c,
	0xdd, 0x33, 0xc1, 0x8c, 0x3a, 0x17, 0x5f, 0x46, 0x69, 0xd1, 0x6e, 0x17, 0x66, 0x8b, 0x85, 0xc3,
	0xa3, 0xf2, 0xfc, 0x84, 0xb3, 0xdd, 0x2e, 0x66, 0xbe, 0xff, 0xa9, 0x94, 0xfa, 0xe5, 0xe7, 0x52,
	0x6a, 0x6d, 0x36, 0xe3, 0x14, 0x9c, 0x7a, 0xed, 0xc5, 0x5f, 0xa5, 0xd4, 0x8b, 0xe3, 0x92, 0xf3,
	0xf2, 0xb8, 0xe4, 0xbc, 0x3a, 0x2e, 0x39, 0x7f, 0x1e, 0x97, 0x9c, 0x1f, 0xde, 0x94, 0x52, 0x2f,
	0xdf, 0x94, 0x52, 0xaf, 0xde, 0x94, 0x52, 0x4f, 0x16, 0x4e, 0x64, 0xbd, 0x75, 0xce, 0xbe, 0xfb,
	0x9f, 0xfc, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x3d, 0x3c, 0xdc, 0xee, 0xcc, 0x09, 0x00, 0x00,
}

func (m *SessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StreamerAlwaysMaintainOrdering {
		i--
		if m.StreamerAlwaysMaintainOrdering {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.IndexJoinStreamerBatchSize != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.IndexJoinStreamerBatchSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.JoinReaderIndexJoinStrategyBatchSize != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.JoinReaderIndexJoinStrategyBatchSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.JoinReaderNoOrderingStrategyBatchSize != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.JoinReaderNoOrderingStrategyBatchSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.TroubleshootingMode {
		i--
		if m.TroubleshootingMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.TrigramSimilarityThreshold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TrigramSimilarityThreshold))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.ParallelizeMultiKeyLookupJoinsEnabled {
		i--
		if m.ParallelizeMultiKeyLookupJoinsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.JoinReaderOrderingStrategyBatchSize != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.JoinReaderOrderingStrategyBatchSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.OnUpdateRehomeRowEnabled {
		i--
		if m.OnUpdateRehomeRowEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Internal {
		i--
		if m.Internal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	n1, err1 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.LockTimeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.LockTimeout):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintSessionData(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x7a
	if m.WorkMemLimit != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.WorkMemLimit))
		i--
		dAtA[i] = 0x60
	}
	{
		size, err := m.SeqState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSessionData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if len(m.TemporarySchemaName) > 0 {
		i -= len(m.TemporarySchemaName)
		copy(dAtA[i:], m.TemporarySchemaName)
		i = encodeVarintSessionData(dAtA, i, uint64(len(m.TemporarySchemaName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SearchPath) > 0 {
		for iNdEx := len(m.SearchPath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchPath[iNdEx])
			copy(dAtA[i:], m.SearchPath[iNdEx])
			i = encodeVarintSessionData(dAtA, i, uint64(len(m.SearchPath[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintSessionData(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x42
	}
	if m.DefaultIntSize != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.DefaultIntSize))
		i--
		dAtA[i] = 0x38
	}
	if m.TestingVectorizeInjectPanics {
		i--
		if m.TestingVectorizeInjectPanics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.VectorizeMode != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.VectorizeMode))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.DataConversionConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSessionData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.UserProto) > 0 {
		i -= len(m.UserProto)
		copy(dAtA[i:], m.UserProto)
		i = encodeVarintSessionData(dAtA, i, uint64(len(m.UserProto)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ApplicationName) > 0 {
		i -= len(m.ApplicationName)
		copy(dAtA[i:], m.ApplicationName)
		i = encodeVarintSessionData(dAtA, i, uint64(len(m.ApplicationName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintSessionData(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataConversionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataConversionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataConversionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.DateStyle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSessionData(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.IntervalStyle != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.IntervalStyle))
		i--
		dAtA[i] = 0x18
	}
	if m.ExtraFloatDigits != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.ExtraFloatDigits))
		i--
		dAtA[i] = 0x10
	}
	if m.BytesEncodeFormat != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.BytesEncodeFormat))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SequenceState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastSeqIncremented != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.LastSeqIncremented))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Seqs) > 0 {
		for iNdEx := len(m.Seqs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Seqs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSessionData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SequenceState_Seq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceState_Seq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceState_Seq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LatestVal != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.LatestVal))
		i--
		dAtA[i] = 0x10
	}
	if m.SeqID != 0 {
		i = encodeVarintSessionData(dAtA, i, uint64(m.SeqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSessionData(dAtA []byte, offset int, v uint64) int {
	offset -= sovSessionData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovSessionData(uint64(l))
	}
	l = len(m.ApplicationName)
	if l > 0 {
		n += 1 + l + sovSessionData(uint64(l))
	}
	l = len(m.UserProto)
	if l > 0 {
		n += 1 + l + sovSessionData(uint64(l))
	}
	l = m.DataConversionConfig.Size()
	n += 1 + l + sovSessionData(uint64(l))
	if m.VectorizeMode != 0 {
		n += 1 + sovSessionData(uint64(m.VectorizeMode))
	}
	if m.TestingVectorizeInjectPanics {
		n += 2
	}
	if m.DefaultIntSize != 0 {
		n += 1 + sovSessionData(uint64(m.DefaultIntSize))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovSessionData(uint64(l))
	}
	if len(m.SearchPath) > 0 {
		for _, s := range m.SearchPath {
			l = len(s)
			n += 1 + l + sovSessionData(uint64(l))
		}
	}
	l = len(m.TemporarySchemaName)
	if l > 0 {
		n += 1 + l + sovSessionData(uint64(l))
	}
	l = m.SeqState.Size()
	n += 1 + l + sovSessionData(uint64(l))
	if m.WorkMemLimit != 0 {
		n += 1 + sovSessionData(uint64(m.WorkMemLimit))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.LockTimeout)
	n += 1 + l + sovSessionData(uint64(l))
	if m.Internal {
		n += 3
	}
	if m.OnUpdateRehomeRowEnabled {
		n += 3
	}
	if m.JoinReaderOrderingStrategyBatchSize != 0 {
		n += 2 + sovSessionData(uint64(m.JoinReaderOrderingStrategyBatchSize))
	}
	if m.ParallelizeMultiKeyLookupJoinsEnabled {
		n += 3
	}
	if m.TrigramSimilarityThreshold != 0 {
		n += 10
	}
	if m.TroubleshootingMode {
		n += 3
	}
	if m.JoinReaderNoOrderingStrategyBatchSize != 0 {
		n += 2 + sovSessionData(uint64(m.JoinReaderNoOrderingStrategyBatchSize))
	}
	if m.JoinReaderIndexJoinStrategyBatchSize != 0 {
		n += 2 + sovSessionData(uint64(m.JoinReaderIndexJoinStrategyBatchSize))
	}
	if m.IndexJoinStreamerBatchSize != 0 {
		n += 2 + sovSessionData(uint64(m.IndexJoinStreamerBatchSize))
	}
	if m.StreamerAlwaysMaintainOrdering {
		n += 3
	}
	return n
}

func (m *DataConversionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesEncodeFormat != 0 {
		n += 1 + sovSessionData(uint64(m.BytesEncodeFormat))
	}
	if m.ExtraFloatDigits != 0 {
		n += 1 + sovSessionData(uint64(m.ExtraFloatDigits))
	}
	if m.IntervalStyle != 0 {
		n += 1 + sovSessionData(uint64(m.IntervalStyle))
	}
	l = m.DateStyle.Size()
	n += 1 + l + sovSessionData(uint64(l))
	return n
}

func (m *SequenceState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Seqs) > 0 {
		for _, e := range m.Seqs {
			l = e.Size()
			n += 1 + l + sovSessionData(uint64(l))
		}
	}
	if m.LastSeqIncremented != 0 {
		n += 1 + sovSessionData(uint64(m.LastSeqIncremented))
	}
	return n
}

func (m *SequenceState_Seq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeqID != 0 {
		n += 1 + sovSessionData(uint64(m.SeqID))
	}
	if m.LatestVal != 0 {
		n += 1 + sovSessionData(uint64(m.LatestVal))
	}
	return n
}

func sovSessionData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSessionData(x uint64) (n int) {
	return sovSessionData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataConversionConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DataConversionConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VectorizeMode", wireType)
			}
			m.VectorizeMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VectorizeMode |= VectorizeExecMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingVectorizeInjectPanics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestingVectorizeInjectPanics = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultIntSize", wireType)
			}
			m.DefaultIntSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultIntSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchPath = append(m.SearchPath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporarySchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TemporarySchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SeqState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkMemLimit", wireType)
			}
			m.WorkMemLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkMemLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.LockTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdateRehomeRowEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnUpdateRehomeRowEnabled = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinReaderOrderingStrategyBatchSize", wireType)
			}
			m.JoinReaderOrderingStrategyBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinReaderOrderingStrategyBatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelizeMultiKeyLookupJoinsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ParallelizeMultiKeyLookupJoinsEnabled = bool(v != 0)
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrigramSimilarityThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TrigramSimilarityThreshold = float64(math.Float64frombits(v))
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TroubleshootingMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TroubleshootingMode = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinReaderNoOrderingStrategyBatchSize", wireType)
			}
			m.JoinReaderNoOrderingStrategyBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinReaderNoOrderingStrategyBatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinReaderIndexJoinStrategyBatchSize", wireType)
			}
			m.JoinReaderIndexJoinStrategyBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinReaderIndexJoinStrategyBatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexJoinStreamerBatchSize", wireType)
			}
			m.IndexJoinStreamerBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexJoinStreamerBatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamerAlwaysMaintainOrdering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StreamerAlwaysMaintainOrdering = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataConversionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataConversionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataConversionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesEncodeFormat", wireType)
			}
			m.BytesEncodeFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesEncodeFormat |= lex.BytesEncodeFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraFloatDigits", wireType)
			}
			m.ExtraFloatDigits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtraFloatDigits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalStyle", wireType)
			}
			m.IntervalStyle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalStyle |= duration.IntervalStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStyle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DateStyle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seqs = append(m.Seqs, &SequenceState_Seq{})
			if err := m.Seqs[len(m.Seqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeqIncremented", wireType)
			}
			m.LastSeqIncremented = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSeqIncremented |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceState_Seq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Seq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Seq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqID", wireType)
			}
			m.SeqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestVal", wireType)
			}
			m.LatestVal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestVal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSessionData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSessionData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSessionData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSessionData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSessionData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSessionData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSessionData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSessionData = fmt.Errorf("proto: unexpected end of group")
)
