// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/sessiondatapb/local_only_session_data.proto

package sessiondatapb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_security_username "github.com/cockroachdb/cockroach/pkg/security/username"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// LocalOnlySessionData contains the serializable components of session
// parameters that only influence execution on the gateway nodes.
type LocalOnlySessionData struct {
	// SaveTablesPrefix indicates that a table should be created with the
	// given prefix for the output of each subexpression in a query. If
	// SaveTablesPrefix is empty, no tables are created.
	SaveTablesPrefix string `protobuf:"bytes,1,opt,name=save_tables_prefix,json=saveTablesPrefix,proto3" json:"save_tables_prefix,omitempty"`
	// OptimizerFKCascadesLimit is the maximum number of cascading operations that
	// are run for a single query.
	OptimizerFKCascadesLimit int64 `protobuf:"varint,2,opt,name=optimizer_fk_cascades_limit,json=optimizerFkCascadesLimit,proto3" json:"optimizer_fk_cascades_limit,omitempty"`
	// StmtTimeout is the duration a query is permitted to run before it is
	// canceled by the session. If set to 0, there is no timeout.
	StmtTimeout time.Duration `protobuf:"varint,3,opt,name=stmt_timeout,json=stmtTimeout,proto3,casttype=time.Duration" json:"stmt_timeout,omitempty"`
	// IdleInSessionTimeout is the duration a session is permitted to idle before
	// the session is canceled. If set to 0, there is no timeout.
	IdleInSessionTimeout time.Duration `protobuf:"varint,4,opt,name=idle_in_session_timeout,json=idleInSessionTimeout,proto3,casttype=time.Duration" json:"idle_in_session_timeout,omitempty"`
	// IdleInTransactionSessionTimeout is the duration a session is permitted to
	// idle in a transaction before the session is canceled.
	// If set to 0, there is no timeout.
	IdleInTransactionSessionTimeout time.Duration `protobuf:"varint,5,opt,name=idle_in_transaction_session_timeout,json=idleInTransactionSessionTimeout,proto3,casttype=time.Duration" json:"idle_in_transaction_session_timeout,omitempty"`
	// NoticeDisplaySeverity indicates the level of Severity to send notices for the given
	// session. This should ideally be of type pgnotice.DisplaySeverity, but cannot be done
	// due to a circular dependency.
	NoticeDisplaySeverity uint32 `protobuf:"varint,6,opt,name=notice_display_severity,json=noticeDisplaySeverity,proto3" json:"notice_display_severity,omitempty"`
	// ReorderJoinsLimit indicates the number of joins at which the optimizer should
	// stop attempting to reorder.
	ReorderJoinsLimit int64 `protobuf:"varint,7,opt,name=reorder_joins_limit,json=reorderJoinsLimit,proto3" json:"reorder_joins_limit,omitempty"`
	// DefaultTxnPriority indicates the default priority of newly created
	// transactions.
	// NOTE: we'd prefer to use tree.UserPriority here, but doing so would
	// introduce a package dependency cycle.
	DefaultTxnPriority int64 `protobuf:"varint,8,opt,name=default_txn_priority,json=defaultTxnPriority,proto3" json:"default_txn_priority,omitempty"`
	// DefaultTxnReadOnly indicates the default read-only status of newly
	// created transactions.
	DefaultTxnReadOnly bool `protobuf:"varint,9,opt,name=default_txn_read_only,json=defaultTxnReadOnly,proto3" json:"default_txn_read_only,omitempty"`
	// DefaultTxnUseFollowerReads indicates whether transactions should be
	// created by default using an AS OF SYSTEM TIME clause far enough in the
	// past to facilitate reads against followers. If true, transactions will
	// also default to being read-only.
	DefaultTxnUseFollowerReads bool `protobuf:"varint,10,opt,name=default_txn_use_follower_reads,json=defaultTxnUseFollowerReads,proto3" json:"default_txn_use_follower_reads,omitempty"`
	// PartiallyDistributedPlansDisabled indicates whether the partially
	// distributed plans produced by distSQLSpecExecFactory are disabled. It
	// should be set to 'true' only in tests that verify that the old and the
	// new factories return exactly the same physical plans.
	// TODO(yuzefovich): remove it when deleting old sql.execFactory.
	PartiallyDistributedPlansDisabled bool `protobuf:"varint,11,opt,name=partially_distributed_plans_disabled,json=partiallyDistributedPlansDisabled,proto3" json:"partially_distributed_plans_disabled,omitempty"`
	// OptimizerUseHistograms indicates whether we should use histograms for
	// cardinality estimation in the optimizer.
	OptimizerUseHistograms bool `protobuf:"varint,12,opt,name=optimizer_use_histograms,json=optimizerUseHistograms,proto3" json:"optimizer_use_histograms,omitempty"`
	// OptimizerUseMultiColStats indicates whether we should use multi-column
	// statistics for cardinality estimation in the optimizer.
	OptimizerUseMultiColStats bool `protobuf:"varint,13,opt,name=optimizer_use_multi_col_stats,json=optimizerUseMultiColStats,proto3" json:"optimizer_use_multi_col_stats,omitempty"`
	// LocalityOptimizedSearch indicates that the optimizer will try to plan scans
	// and lookup joins in which local nodes (i.e., nodes in the gateway region)
	// are searched for matching rows before remote nodes, in the hope that the
	// execution engine can avoid visiting remote nodes.
	LocalityOptimizedSearch bool `protobuf:"varint,14,opt,name=locality_optimized_search,json=localityOptimizedSearch,proto3" json:"locality_optimized_search,omitempty"`
	// SafeUpdates causes errors when the client
	// sends syntax that may have unwanted side effects.
	SafeUpdates bool `protobuf:"varint,15,opt,name=safe_updates,json=safeUpdates,proto3" json:"safe_updates,omitempty"`
	// PreferLookupJoinsForFKs causes foreign key operations to prefer lookup
	// joins.
	PreferLookupJoinsForFKs bool `protobuf:"varint,16,opt,name=prefer_lookup_joins_for_fks,json=preferLookupJoinsForFks,proto3" json:"prefer_lookup_joins_for_fks,omitempty"`
	// ZigzagJoinEnabled indicates whether the optimizer should try and plan a
	// zigzag join.
	ZigzagJoinEnabled bool `protobuf:"varint,17,opt,name=zigzag_join_enabled,json=zigzagJoinEnabled,proto3" json:"zigzag_join_enabled,omitempty"`
	// RequireExplicitPrimaryKeys indicates whether CREATE TABLE statements should
	// error out if no primary key is provided.
	RequireExplicitPrimaryKeys bool `protobuf:"varint,18,opt,name=require_explicit_primary_keys,json=requireExplicitPrimaryKeys,proto3" json:"require_explicit_primary_keys,omitempty"`
	// ForceSavepointRestart overrides the default SAVEPOINT behavior
	// for compatibility with certain ORMs. When this flag is set,
	// the savepoint name will no longer be compared against the magic
	// identifier `cockroach_restart` in order use a restartable
	// transaction.
	ForceSavepointRestart bool `protobuf:"varint,19,opt,name=force_savepoint_restart,json=forceSavepointRestart,proto3" json:"force_savepoint_restart,omitempty"`
	// AllowPrepareAsOptPlan must be set to allow use of
	//
	//	PREPARE name AS OPT PLAN '...'
	AllowPrepareAsOptPlan bool `protobuf:"varint,20,opt,name=allow_prepare_as_opt_plan,json=allowPrepareAsOptPlan,proto3" json:"allow_prepare_as_opt_plan,omitempty"`
	// TempTablesEnabled indicates whether temporary tables can be created or not.
	TempTablesEnabled bool `protobuf:"varint,21,opt,name=temp_tables_enabled,json=tempTablesEnabled,proto3" json:"temp_tables_enabled,omitempty"`
	// ImplicitPartitioningEnabled indicates whether implicit column partitioning
	// can be created.
	ImplicitColumnPartitioningEnabled bool `protobuf:"varint,22,opt,name=implicit_column_partitioning_enabled,json=implicitColumnPartitioningEnabled,proto3" json:"implicit_column_partitioning_enabled,omitempty"`
	// OverrideMultiRegionZoneConfigEnabled indicates whether zone configurations can be
	// modified for multi-region databases and tables/indexes/partitions.
	OverrideMultiRegionZoneConfigEnabled bool `protobuf:"varint,24,opt,name=override_multi_region_zone_config_enabled,json=overrideMultiRegionZoneConfigEnabled,proto3" json:"override_multi_region_zone_config_enabled,omitempty"`
	// DisallowFullTableScans indicates whether queries that plan full table scans
	// should be rejected.
	DisallowFullTableScans bool `protobuf:"varint,26,opt,name=disallow_full_table_scans,json=disallowFullTableScans,proto3" json:"disallow_full_table_scans,omitempty"`
	// ImplicitSelectForUpdate is true if FOR UPDATE locking may be used during
	// the row-fetch phase of mutation statements.
	ImplicitSelectForUpdate bool `protobuf:"varint,27,opt,name=implicit_select_for_update,json=implicitSelectForUpdate,proto3" json:"implicit_select_for_update,omitempty"`
	// InsertFastPath is true if the fast path for insert (with VALUES input) may
	// be used.
	InsertFastPath bool `protobuf:"varint,28,opt,name=insert_fast_path,json=insertFastPath,proto3" json:"insert_fast_path,omitempty"`
	// AlterColumnTypeGeneralEnabled is true if ALTER TABLE ... ALTER COLUMN ...
	// TYPE x may be used for general conversions requiring online schema change/
	AlterColumnTypeGeneralEnabled bool `protobuf:"varint,29,opt,name=alter_column_type_general_enabled,json=alterColumnTypeGeneralEnabled,proto3" json:"alter_column_type_general_enabled,omitempty"`
	// SynchronousCommit is a dummy setting for the synchronous_commit var.
	SynchronousCommit bool `protobuf:"varint,30,opt,name=synchronous_commit,json=synchronousCommit,proto3" json:"synchronous_commit,omitempty"`
	// EnableSeqScan is a dummy setting for the enable_seqscan var.
	EnableSeqScan bool `protobuf:"varint,31,opt,name=enable_seq_scan,json=enableSeqScan,proto3" json:"enable_seq_scan,omitempty"`
	// EnableUniqueWithoutIndexConstraints indicates whether creating unique
	// constraints without an index is allowed.
	// TODO(rytaft): remove this once unique without index constraints are fully
	// supported.
	EnableUniqueWithoutIndexConstraints bool `protobuf:"varint,33,opt,name=enable_unique_without_index_constraints,json=enableUniqueWithoutIndexConstraints,proto3" json:"enable_unique_without_index_constraints,omitempty"`
	// StubCatalogTablesEnabled allows queries against virtual
	// tables that are not yet implemented.
	StubCatalogTablesEnabled bool `protobuf:"varint,34,opt,name=stub_catalog_tables_enabled,json=stubCatalogTablesEnabled,proto3" json:"stub_catalog_tables_enabled,omitempty"`
	// ExperimentalComputedColumnRewrites allows automatic rewriting of computed
	// column expressions in CREATE TABLE and ALTER TABLE statements. See the
	// experimentalComputedColumnRewrites cluster setting for a description of the
	// format.
	ExperimentalComputedColumnRewrites string `protobuf:"bytes,35,opt,name=experimental_computed_column_rewrites,json=experimentalComputedColumnRewrites,proto3" json:"experimental_computed_column_rewrites,omitempty"`
	// EnableStreamReplication indicates whether to allow setting up a replication
	// stream.
	EnableStreamReplication bool `protobuf:"varint,37,opt,name=enable_stream_replication,json=enableStreamReplication,proto3" json:"enable_stream_replication,omitempty"`
	// ResultsBufferSize specifies the size at which the pgwire results buffer
	// will self-flush.
	ResultsBufferSize int64 `protobuf:"varint,38,opt,name=results_buffer_size,json=resultsBufferSize,proto3" json:"results_buffer_size,omitempty"`
	// PropagateInputOrdering indicates that when planning a subquery or CTE, the
	// inner ordering should be propagated to the outer scope if the outer scope
	// is unordered. PropagateInputOrdering is currently experimental.
	PropagateInputOrdering bool `protobuf:"varint,39,opt,name=propagate_input_ordering,json=propagateInputOrdering,proto3" json:"propagate_input_ordering,omitempty"`
	// ExperimentalDistSQLPlanningMode indicates whether the experimental
	// DistSQL planning driven by the optimizer is enabled.
	ExperimentalDistSQLPlanningMode ExperimentalDistSQLPlanningMode `protobuf:"varint,40,opt,name=experimental_distsql_planning_mode,json=experimentalDistsqlPlanningMode,proto3,casttype=ExperimentalDistSQLPlanningMode" json:"experimental_distsql_planning_mode,omitempty"`
	// DistSQLMode indicates whether to run queries using the distributed
	// execution engine.
	DistSQLMode DistSQLExecMode `protobuf:"varint,41,opt,name=dist_sql_mode,json=distSqlMode,proto3,casttype=DistSQLExecMode" json:"dist_sql_mode,omitempty"`
	// SerialNormalizationMode indicates how to handle the SERIAL pseudo-type.
	SerialNormalizationMode SerialNormalizationMode `protobuf:"varint,42,opt,name=serial_normalization_mode,json=serialNormalizationMode,proto3,casttype=SerialNormalizationMode" json:"serial_normalization_mode,omitempty"`
	// NewSchemaChangerMode indicates whether to use the new schema changer.
	NewSchemaChangerMode NewSchemaChangerMode `protobuf:"varint,43,opt,name=new_schema_changer_mode,json=newSchemaChangerMode,proto3,casttype=NewSchemaChangerMode" json:"new_schema_changer_mode,omitempty"`
	// SequenceCache stores sequence values which have been cached using the
	// CACHE sequence option.
	SequenceCache SequenceCache `protobuf:"bytes,44,rep,name=sequence_cache,json=sequenceCache,proto3,casttype=SequenceCache" json:"sequence_cache,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// PlacementEnabled indicates whether PLACEMENT can be used or not.
	PlacementEnabled bool `protobuf:"varint,45,opt,name=placement_enabled,json=placementEnabled,proto3" json:"placement_enabled,omitempty"`
	// SessionUserProto is the name of the user which has performed a SET ROLE
	// command. In other words, it is the name of the user which originally
	// established the connection before SET ROLE was first performed.
	// This is only populated when SET ROLE is used, otherwise the session_user
	// is the same as the UserProto in SessionData.
	// Postgres allows the SessionUser to be changed with SET SESSION AUTHORIZATION
	// but CockroachDB doesn't allow that at the time of this writing.
	SessionUserProto github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto `protobuf:"bytes,46,opt,name=session_user_proto,json=sessionUserProto,proto3,casttype=github.com/cockroachdb/cockroach/pkg/security/username.SQLUsernameProto" json:"session_user_proto,omitempty"`
	// TxnRowsWrittenLog is the threshold for the number of rows written by a SQL
	// transaction which - once exceeded - will trigger a logging event to SQL_PERF
	// (or SQL_INTERNAL_PERF for internal transactions); 0 means disabled.
	TxnRowsWrittenLog int64 `protobuf:"varint,47,opt,name=txn_rows_written_log,json=txnRowsWrittenLog,proto3" json:"txn_rows_written_log,omitempty"`
	// TxnRowsWrittenErr is the limit for the number of rows written by a SQL
	// transaction which - once exceeded - will fail the transaction (or will
	// trigger a logging event to SQL_INTERNAL_PERF for internal transactions); 0
	// means disabled.
	TxnRowsWrittenErr int64 `protobuf:"varint,48,opt,name=txn_rows_written_err,json=txnRowsWrittenErr,proto3" json:"txn_rows_written_err,omitempty"`
	// TxnRowsReadLog is the threshold for the number of rows read by a SQL
	// transaction which - once exceeded - will trigger a logging event to SQL_PERF
	// (or SQL_INTERNAL_PERF for internal transactions); 0 means disabled.
	TxnRowsReadLog int64 `protobuf:"varint,49,opt,name=txn_rows_read_log,json=txnRowsReadLog,proto3" json:"txn_rows_read_log,omitempty"`
	// TxnRowsReadErr is the limit for the number of rows read by a SQL
	// transaction which - once exceeded - will fail the transaction (or will
	// trigger a logging event to SQL_INTERNAL_PERF for internal transactions); 0
	// means disabled.
	TxnRowsReadErr int64 `protobuf:"varint,50,opt,name=txn_rows_read_err,json=txnRowsReadErr,proto3" json:"txn_rows_read_err,omitempty"`
	// AutoRehomingEnabled indicates whether or not REGIONAL BY ROW tables should
	// have a rehoming ON UPDATE clause added to them.
	AutoRehomingEnabled bool `protobuf:"varint,51,opt,name=auto_rehoming_enabled,json=autoRehomingEnabled,proto3" json:"auto_rehoming_enabled,omitempty"`
	// IsSuperuser returns whether the user is a "superuser", which is defined
	// to be a user with an admin role.
	IsSuperuser bool `protobuf:"varint,52,opt,name=is_superuser,json=isSuperuser,proto3" json:"is_superuser,omitempty"`
	// LargeFullScanRows is the estimated row count at which a full scan is
	// considered large, and worthy of logging and/or disabling depending on other
	// settings.
	LargeFullScanRows float64 `protobuf:"fixed64,53,opt,name=large_full_scan_rows,json=largeFullScanRows,proto3" json:"large_full_scan_rows,omitempty"`
	// InjectRetryErrorsEnabled causes statements inside an explicit
	// transaction to return a transaction retry error. It is intended for
	// developers to test their app's retry logic.
	InjectRetryErrorsEnabled bool `protobuf:"varint,54,opt,name=inject_retry_errors_enabled,json=injectRetryErrorsEnabled,proto3" json:"inject_retry_errors_enabled,omitempty"`
	// NullOrderedLast controls whether NULL is ordered last. We default to
	// NULLS FIRST for ascending order by default, whereas postgres defaults
	// to NULLS LAST.
	NullOrderedLast bool `protobuf:"varint,55,opt,name=null_ordered_last,json=nullOrderedLast,proto3" json:"null_ordered_last,omitempty"`
	// DisablePlanGists indicates whether we should disable automatic gists.
	DisablePlanGists bool `protobuf:"varint,56,opt,name=disable_plan_gists,json=disablePlanGists,proto3" json:"disable_plan_gists,omitempty"`
	// CustomOptions contains a map of all custom session settings.
	// These session variables have at least one period in their name.
	CustomOptions map[string]string `protobuf:"bytes,57,rep,name=custom_options,json=customOptions,proto3" json:"custom_options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// IndexRecommendationsEnabled controls whether or not we display index
	// recommendations below the plan in EXPLAIN.
	IndexRecommendationsEnabled bool `protobuf:"varint,58,opt,name=index_recommendations_enabled,json=indexRecommendationsEnabled,proto3" json:"index_recommendations_enabled,omitempty"`
	// AvoidBuffering indicates that the returned data should not be
	// buffered by conn executor.  This is currently used by replication primitives
	// to ensure the data is flushed to the consumer immediately.
	AvoidBuffering bool `protobuf:"varint,59,opt,name=avoid_buffering,json=avoidBuffering,proto3" json:"avoid_buffering,omitempty"`
	// CheckFunctionBodies indicates whether functions are validated during
	// creation.
	CheckFunctionBodies bool `protobuf:"varint,60,opt,name=check_function_bodies,json=checkFunctionBodies,proto3" json:"check_function_bodies,omitempty"`
	// CostScansWithDefaultColSize is true when the optimizer should cost scans
	// and joins using the same default number of bytes per column instead of
	// column sizes from the AvgSize table statistic.
	CostScansWithDefaultColSize bool `protobuf:"varint,61,opt,name=cost_scans_with_default_col_size,json=costScansWithDefaultColSize,proto3" json:"cost_scans_with_default_col_size,omitempty"`
	// DefaultTxnQualityOfService indicates the default QoSLevel/WorkPriority of
	// newly created transactions.
	DefaultTxnQualityOfService QoSLevel `protobuf:"varint,62,opt,name=default_txn_quality_of_service,json=defaultTxnQualityOfService,proto3,casttype=QoSLevel" json:"default_txn_quality_of_service,omitempty"`
	// OptSplitScanLimit indicates the maximum number of UNION ALL statements a
	// Scan may be split into during query optimization to avoid a sort.
	OptSplitScanLimit int32 `protobuf:"varint,63,opt,name=opt_split_scan_limit,json=optSplitScanLimit,proto3" json:"opt_split_scan_limit,omitempty"`
	// EnableSuperRegions is true when super region functionality is enabled.
	EnableSuperRegions bool `protobuf:"varint,64,opt,name=enable_super_regions,json=enableSuperRegions,proto3" json:"enable_super_regions,omitempty"`
	// OverrideAlterPrimaryRegionInSuperRegion is true when the user is allowed
	// to modify a primary region that is part of a super region.
	OverrideAlterPrimaryRegionInSuperRegion bool `protobuf:"varint,65,opt,name=override_alter_primary_region_in_super_region,json=overrideAlterPrimaryRegionInSuperRegion,proto3" json:"override_alter_primary_region_in_super_region,omitempty"`
	// EnableImplicitTransactionForBatchStatements configures the handling of
	// multiple statements in a single query. If enabled, then an implicit
	// transaction is used when multiple statements are sent in a single query.
	// Setting this to false is a divergence from the pgwire protocol, but
	// matches the behavior of CockroachDB v21.2 and earlier.
	EnableImplicitTransactionForBatchStatements bool `protobuf:"varint,66,opt,name=enable_implicit_transaction_for_batch_statements,json=enableImplicitTransactionForBatchStatements,proto3" json:"enable_implicit_transaction_for_batch_statements,omitempty"`
	// ExpectAndIgnoreNotVisibleColumnsInCopy changes behaviour for COPY t FROM ...
	// (with no column name specifiers) to expect and ignore not visible column
	// fields.
	ExpectAndIgnoreNotVisibleColumnsInCopy bool `protobuf:"varint,67,opt,name=expect_and_ignore_not_visible_columns_in_copy,json=expectAndIgnoreNotVisibleColumnsInCopy,proto3" json:"expect_and_ignore_not_visible_columns_in_copy,omitempty"`
	// MultipleModificationsOfTable allows statements containing multiple INSERT
	// ON CONFLICT, UPSERT, UPDATE, or DELETE subqueries modifying the same table,
	// at the risk of data corruption if the same row is modified multiple times.
	MultipleModificationsOfTable bool `protobuf:"varint,68,opt,name=multiple_modifications_of_table,json=multipleModificationsOfTable,proto3" json:"multiple_modifications_of_table,omitempty"`
	// ShowPrimaryKeyConstraintOnNotVisibleColumns controls whether SHOW
	// CONSTRAINTS and pg_catalog.pg_constraint will include primary key
	// constraints that only include hidden columns.
	ShowPrimaryKeyConstraintOnNotVisibleColumns bool `protobuf:"varint,69,opt,name=show_primary_key_constraint_on_not_visible_columns,json=showPrimaryKeyConstraintOnNotVisibleColumns,proto3" json:"show_primary_key_constraint_on_not_visible_columns,omitempty"`
	// TestingOptimizerRandomSeed is non-zero when we are testing the optimizer by
	// randomly perturbing costs or disabling rules. This will initialize a rng
	// seeded to the given integer. This should only be used in test scenarios and
	// is very much a non-production setting.
	TestingOptimizerRandomSeed int64 `protobuf:"varint,70,opt,name=testing_optimizer_random_seed,json=testingOptimizerRandomSeed,proto3" json:"testing_optimizer_random_seed,omitempty"`
	// UnconstrainedNonCoveringIndexScanEnabled controls whether unconstrained
	// non-covering index scan access paths are explored by the optimizer.
	UnconstrainedNonCoveringIndexScanEnabled bool `protobuf:"varint,71,opt,name=unconstrained_non_covering_index_scan_enabled,json=unconstrainedNonCoveringIndexScanEnabled,proto3" json:"unconstrained_non_covering_index_scan_enabled,omitempty"`
	// TestingOptimizerCostPerturbation is non-zero when the coster should
	// randomly perturb costs to produce a non-optimal query plan. This should
	// only be used in test scenarios and is very much a non-production setting.
	TestingOptimizerCostPerturbation float64 `protobuf:"fixed64,72,opt,name=testing_optimizer_cost_perturbation,json=testingOptimizerCostPerturbation,proto3" json:"testing_optimizer_cost_perturbation,omitempty"`
	// TestingOptimizerDisableRuleProbability is non-zero when the optimizer
	// should randomly disable every non-essential transformation rule with the
	// given probability. This should only be used in test scenarios and is very
	// much a non-production setting.
	TestingOptimizerDisableRuleProbability float64 `protobuf:"fixed64,73,opt,name=testing_optimizer_disable_rule_probability,json=testingOptimizerDisableRuleProbability,proto3" json:"testing_optimizer_disable_rule_probability,omitempty"`
	// OptimizerUseNotVisibleIndexes indicates whether the optimizer can still
	// choose to use visible indexes for query plans.
	OptimizerUseNotVisibleIndexes bool `protobuf:"varint,74,opt,name=optimizer_use_not_visible_indexes,json=optimizerUseNotVisibleIndexes,proto3" json:"optimizer_use_not_visible_indexes,omitempty"`
	// CopyFastPathEnabled controls whether the optimized copy mode is enabled.
	CopyFastPathEnabled bool `protobuf:"varint,75,opt,name=copy_fast_path_enabled,json=copyFastPathEnabled,proto3" json:"copy_fast_path_enabled,omitempty"`
	// disable_hoist_projection_in_join_limitation disables the restrictions
	// placed on projection hoisting during query planning in the optimizer.
	DisableHoistProjectionInJoinLimitation bool `protobuf:"varint,76,opt,name=disable_hoist_projection_in_join_limitation,json=disableHoistProjectionInJoinLimitation,proto3" json:"disable_hoist_projection_in_join_limitation,omitempty"`
	// CopyFromAtomicEnabled controls whether implicit txn copy from operations
	// are atomic or segmented.
	CopyFromAtomicEnabled bool `protobuf:"varint,77,opt,name=copy_from_atomic_enabled,json=copyFromAtomicEnabled,proto3" json:"copy_from_atomic_enabled,omitempty"`
	// EnforceHomeRegion, when true, causes queries which scan rows from multiple
	// regions, or which scan rows from a single home region, but initiated from
	// a gateway region which differs from that home region, to error out.
	EnforceHomeRegion bool `protobuf:"varint,78,opt,name=enforce_home_region,json=enforceHomeRegion,proto3" json:"enforce_home_region,omitempty"`
	// OptimizerUseForecasts indicates whether we should use statistics forecasts
	// for cardinality estimation in the optimizer.
	OptimizerUseForecasts bool `protobuf:"varint,79,opt,name=optimizer_use_forecasts,json=optimizerUseForecasts,proto3" json:"optimizer_use_forecasts,omitempty"`
	// VariableInequalityLookupJoinEnabled indicates whether the optimizer should
	// be allowed to consider lookup joins with inequality conditions, in
	// addition to the other restrictions on when they are planned.
	VariableInequalityLookupJoinEnabled bool `protobuf:"varint,80,opt,name=variable_inequality_lookup_join_enabled,json=variableInequalityLookupJoinEnabled,proto3" json:"variable_inequality_lookup_join_enabled,omitempty"`
	// OptimizerUseImprovedDisjunctionStats, when true, indicates that the
	// optimizer should use improved statistics calculations for disjunctive
	// filters.
	OptimizerUseImprovedDisjunctionStats bool `protobuf:"varint,86,opt,name=optimizer_use_improved_disjunction_stats,json=optimizerUseImprovedDisjunctionStats,proto3" json:"optimizer_use_improved_disjunction_stats,omitempty"`
	// OptimizerUseLimitOrderingForStreamingGroupBy enables the exploration rule
	// which optimizes 'SELECT ... GROUP BY ... ORDER BY ... LIMIT n' queries.
	// The rule uses the required ordering in the limit expression to inform an
	// interesting ordering to require from the input to the group-by expression.
	// This can potentially eliminate a top-k operation.
	OptimizerUseLimitOrderingForStreamingGroupBy bool `protobuf:"varint,88,opt,name=optimizer_use_limit_ordering_for_streaming_group_by,json=optimizerUseLimitOrderingForStreamingGroupBy,proto3" json:"optimizer_use_limit_ordering_for_streaming_group_by,omitempty"`
	// CopyFromRetriesEnabled controls whether retries should be internally
	// attempted for retriable errors.
	CopyFromRetriesEnabled bool `protobuf:"varint,89,opt,name=copy_from_retries_enabled,json=copyFromRetriesEnabled,proto3" json:"copy_from_retries_enabled,omitempty"`
	// DeclareCursorStatementTimeoutEnabled controls whether statement timeouts
	// apply during DECLARE CURSOR.
	DeclareCursorStatementTimeoutEnabled bool `protobuf:"varint,90,opt,name=declare_cursor_statement_timeout_enabled,json=declareCursorStatementTimeoutEnabled,proto3" json:"declare_cursor_statement_timeout_enabled,omitempty"`
	// OptimizerUseImprovedSplitDisjunctionForJoins enables the optimizer to split
	// disjunctions (OR expressions) in more cases in join conditions by building a
	// UNION of two join expressions. If this setting is true, all disjunctions in
	// inner, semi, and anti joins will be split. If false, only disjunctions
	// potentially containing an equijoin condition will be split.
	OptimizerUseImprovedSplitDisjunctionForJoins bool `protobuf:"varint,91,opt,name=optimizer_use_improved_split_disjunction_for_joins,json=optimizerUseImprovedSplitDisjunctionForJoins,proto3" json:"optimizer_use_improved_split_disjunction_for_joins,omitempty"`
	// OptimizerAlwaysUseHistograms, when true, ensures that the optimizer
	// always uses histograms to calculate statistics if available.
	OptimizerAlwaysUseHistograms bool `protobuf:"varint,94,opt,name=optimizer_always_use_histograms,json=optimizerAlwaysUseHistograms,proto3" json:"optimizer_always_use_histograms,omitempty"`
	// PreparedStatementsCacheSize, when not equal to 0, causes the LRU prepared
	// statements in a session to be automatically deallocated when total prepared
	// statement memory usage for that session is more than the cache size.
	// Execution of these deallocated prepared statements will fail until they are
	// prepared again.
	PreparedStatementsCacheSize int64 `protobuf:"varint,97,opt,name=prepared_statements_cache_size,json=preparedStatementsCacheSize,proto3" json:"prepared_statements_cache_size,omitempty"`
	// StreamerEnabled controls whether the Streamer API can be used.
	StreamerEnabled bool `protobuf:"varint,98,opt,name=streamer_enabled,json=streamerEnabled,proto3" json:"streamer_enabled,omitempty"`
	// UnboundedParallelScans, when true, indicates that the TableReader DistSQL
	// processors should parallelize scans across ranges. Note that the
	// parallelization will still be disabled for queries with LIMITs, and it can
	// lead to increased likelihood of OOMs.
	UnboundedParallelScans bool `protobuf:"varint,101,opt,name=unbounded_parallel_scans,json=unboundedParallelScans,proto3" json:"unbounded_parallel_scans,omitempty"`
	// OptimizerHoistUncorrelatedEqualitySubqueries, when true, causes the
	// optimizer to hoist uncorrelated subqueries that are part of an equality
	// expression with a column reference, which can produce more efficient query
	// plans.
	OptimizerHoistUncorrelatedEqualitySubqueries bool `protobuf:"varint,102,opt,name=optimizer_hoist_uncorrelated_equality_subqueries,json=optimizerHoistUncorrelatedEqualitySubqueries,proto3" json:"optimizer_hoist_uncorrelated_equality_subqueries,omitempty"`
}

func (m *LocalOnlySessionData) Reset()         { *m = LocalOnlySessionData{} }
func (m *LocalOnlySessionData) String() string { return proto.CompactTextString(m) }
func (*LocalOnlySessionData) ProtoMessage()    {}
func (*LocalOnlySessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_21ead158cf36da28, []int{0}
}
func (m *LocalOnlySessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalOnlySessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalOnlySessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalOnlySessionData.Merge(m, src)
}
func (m *LocalOnlySessionData) XXX_Size() int {
	return m.Size()
}
func (m *LocalOnlySessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalOnlySessionData.DiscardUnknown(m)
}

var xxx_messageInfo_LocalOnlySessionData proto.InternalMessageInfo

// SequenceCacheEntry is an entry in a SequenceCache.
type SequenceCacheEntry struct {
	// CachedVersion stores the descpb.DescriptorVersion that cached values are associated with.
	// The version is checked to determine if cache needs to be invalidated. The version is stored as
	// a uint32 to prevent an import cycle with the descpb package.
	CachedVersion uint32 `protobuf:"varint,1,opt,name=cached_version,json=cachedVersion,proto3" json:"cached_version,omitempty"`
	// CurrentValue stores the present value of the sequence to be given out.
	CurrentValue int64 `protobuf:"varint,2,opt,name=current_value,json=currentValue,proto3" json:"current_value,omitempty"`
	// Increment stores the amount to Increment the currentVal by each time the
	// currentVal is used. This value corresponds to descpb.TableDescriptor_SequenceOpts.Increment.
	Increment int64 `protobuf:"varint,3,opt,name=increment,proto3" json:"increment,omitempty"`
	// NumValues represents the number of values to cache. The cache is considered
	// to be empty when NumValues is 0.
	NumValues int64 `protobuf:"varint,4,opt,name=num_values,json=numValues,proto3" json:"num_values,omitempty"`
}

func (m *SequenceCacheEntry) Reset()         { *m = SequenceCacheEntry{} }
func (m *SequenceCacheEntry) String() string { return proto.CompactTextString(m) }
func (*SequenceCacheEntry) ProtoMessage()    {}
func (*SequenceCacheEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_21ead158cf36da28, []int{1}
}
func (m *SequenceCacheEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceCacheEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceCacheEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceCacheEntry.Merge(m, src)
}
func (m *SequenceCacheEntry) XXX_Size() int {
	return m.Size()
}
func (m *SequenceCacheEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceCacheEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceCacheEntry proto.InternalMessageInfo

func init() {
	proto.RegisterType((*LocalOnlySessionData)(nil), "cockroach.sql.sessiondatapb.LocalOnlySessionData")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.sql.sessiondatapb.LocalOnlySessionData.CustomOptionsEntry")
	proto.RegisterMapType((SequenceCache)(nil), "cockroach.sql.sessiondatapb.LocalOnlySessionData.SequenceCacheEntry")
	proto.RegisterType((*SequenceCacheEntry)(nil), "cockroach.sql.sessiondatapb.SequenceCacheEntry")
}

func init() {
	proto.RegisterFile("sql/sessiondatapb/local_only_session_data.proto", fileDescriptor_21ead158cf36da28)
}

var fileDescriptor_21ead158cf36da28 = []byte{
	// 2918 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x5f, 0x73, 0x14, 0x37,
	0xb6, 0x67, 0x02, 0xc9, 0x05, 0x81, 0xc1, 0x6e, 0x4c, 0xdc, 0xd8, 0x60, 0x9b, 0xff, 0x26, 0x04,
	0x9b, 0x40, 0x6e, 0x42, 0x92, 0x9b, 0x7b, 0x83, 0xc7, 0x1e, 0x30, 0x18, 0x3c, 0xcc, 0xf0, 0xe7,
	0x86, 0xd4, 0x46, 0xa5, 0xe9, 0xd6, 0xcc, 0x28, 0xee, 0x96, 0xda, 0x92, 0xda, 0xf6, 0xf0, 0xb0,
	0x9f, 0x61, 0xab, 0xf6, 0x71, 0x6b, 0xbf, 0x4f, 0x1e, 0xf3, 0x98, 0x27, 0xd7, 0xae, 0xf3, 0x2d,
	0x78, 0xda, 0x3a, 0x47, 0xea, 0x9e, 0x1e, 0xec, 0x64, 0xab, 0xf6, 0x6d, 0x46, 0xe7, 0x77, 0x7e,
	0x3a, 0x3a, 0x3a, 0x3a, 0x7f, 0x9a, 0x2c, 0x99, 0xad, 0x64, 0xc9, 0x70, 0x63, 0x84, 0x92, 0x31,
	0xb3, 0x2c, 0xeb, 0x2c, 0x25, 0x2a, 0x62, 0x09, 0x55, 0x32, 0x19, 0x50, 0x2f, 0xa0, 0x20, 0x59,
	0xcc, 0xb4, 0xb2, 0x2a, 0x98, 0x89, 0x54, 0xb4, 0xa9, 0x15, 0x8b, 0xfa, 0x8b, 0x66, 0x2b, 0x59,
	0x1c, 0x51, 0x9d, 0x9e, 0xec, 0xa9, 0x9e, 0x42, 0xdc, 0x12, 0xfc, 0x72, 0x2a, 0x97, 0xff, 0x76,
	0x87, 0x4c, 0xae, 0x03, 0xe9, 0x86, 0x4c, 0x06, 0x6d, 0xa7, 0xb0, 0xc2, 0x2c, 0x0b, 0x3e, 0x25,
	0x81, 0x61, 0xdb, 0x9c, 0x5a, 0xd6, 0x49, 0xb8, 0xa1, 0x99, 0xe6, 0x5d, 0xb1, 0x1b, 0xd6, 0xe6,
	0x6b, 0x0b, 0x27, 0x5a, 0xe3, 0x20, 0x79, 0x81, 0x82, 0x26, 0xae, 0x07, 0x3f, 0x90, 0x19, 0x95,
	0x59, 0x91, 0x8a, 0xb7, 0x5c, 0xd3, 0xee, 0x26, 0x8d, 0x98, 0x89, 0x58, 0xcc, 0x0d, 0x4d, 0x44,
	0x2a, 0x6c, 0xf8, 0xc1, 0x7c, 0x6d, 0xe1, 0xe8, 0xf2, 0x85, 0xfd, 0xbd, 0xb9, 0x70, 0xa3, 0x80,
	0x35, 0x9e, 0xd4, 0x3d, 0x68, 0x1d, 0x30, 0xad, 0xb0, 0x24, 0x68, 0x6c, 0x8e, 0x48, 0x82, 0xcf,
	0xc9, 0x29, 0x63, 0x53, 0x4b, 0xad, 0x48, 0xb9, 0xca, 0x6d, 0x78, 0x14, 0xd9, 0x26, 0xde, 0xed,
	0xcd, 0x8d, 0xc1, 0xd2, 0xe2, 0x4a, 0xae, 0x99, 0x15, 0x4a, 0xb6, 0x4e, 0x02, 0xec, 0x85, 0x43,
	0x05, 0x8f, 0xc8, 0x94, 0x88, 0x13, 0x4e, 0x85, 0x2c, 0x5d, 0x55, 0x10, 0x1c, 0xfb, 0x3d, 0x82,
	0x49, 0xd0, 0x58, 0x93, 0xde, 0x0f, 0x05, 0x13, 0x25, 0x57, 0x0a, 0x26, 0xab, 0x99, 0x34, 0x2c,
	0x02, 0xf0, 0x01, 0xd6, 0x0f, 0x7f, 0x8f, 0x75, 0xce, 0xb1, 0xbe, 0x18, 0xea, 0xbe, 0xb7, 0xc1,
	0x17, 0x64, 0x4a, 0x2a, 0x2b, 0x22, 0x4e, 0x63, 0x61, 0xb2, 0x84, 0xc1, 0xe5, 0x6e, 0x73, 0x2d,
	0xec, 0x20, 0xfc, 0x68, 0xbe, 0xb6, 0x30, 0xd6, 0x3a, 0xe7, 0xc4, 0x2b, 0x4e, 0xda, 0xf6, 0xc2,
	0x60, 0x91, 0x9c, 0xd5, 0x5c, 0xe9, 0x98, 0x6b, 0xfa, 0x93, 0x12, 0xb2, 0xf0, 0xf6, 0x7f, 0x81,
	0x21, 0xad, 0x09, 0x2f, 0x7a, 0x0c, 0x12, 0xe7, 0xc8, 0x3b, 0x64, 0x32, 0xe6, 0x5d, 0x96, 0x27,
	0x96, 0xda, 0x5d, 0x49, 0x33, 0x2d, 0x14, 0x6e, 0x72, 0x1c, 0x15, 0x02, 0x2f, 0x7b, 0xb1, 0x2b,
	0x9b, 0x5e, 0x12, 0x7c, 0x46, 0xce, 0x55, 0x35, 0x34, 0x67, 0x31, 0x46, 0x5f, 0x78, 0x62, 0xbe,
	0xb6, 0x70, 0xbc, 0xaa, 0xd2, 0xe2, 0x2c, 0x86, 0x18, 0x0a, 0x96, 0xc9, 0x6c, 0x55, 0x25, 0x37,
	0x9c, 0x76, 0x55, 0x92, 0xa8, 0x1d, 0xae, 0x51, 0xdf, 0x84, 0x04, 0x75, 0xa7, 0x87, 0xba, 0x2f,
	0x0d, 0x6f, 0x78, 0x08, 0xd0, 0x98, 0x60, 0x83, 0x5c, 0xcd, 0x98, 0xb6, 0x82, 0x25, 0xc9, 0x00,
	0x7c, 0x62, 0xb5, 0xe8, 0xe4, 0x96, 0xc7, 0x34, 0x4b, 0x98, 0x34, 0xb0, 0x02, 0xc1, 0x17, 0x87,
	0x27, 0x91, 0xe9, 0x52, 0x89, 0x5d, 0x19, 0x42, 0x9b, 0x80, 0x5c, 0xf1, 0xc0, 0xe0, 0x3e, 0x19,
	0x86, 0x17, 0x9a, 0xd4, 0x17, 0xc6, 0xaa, 0x9e, 0x66, 0xa9, 0x09, 0x4f, 0x21, 0xc9, 0xc7, 0xa5,
	0xfc, 0xa5, 0xe1, 0x8f, 0x4a, 0x69, 0xf0, 0x1d, 0xb9, 0x38, 0xaa, 0x99, 0xe6, 0x89, 0x15, 0x34,
	0x52, 0x09, 0x35, 0x96, 0x59, 0x13, 0x8e, 0xa1, 0xfa, 0xf9, 0xaa, 0xfa, 0x53, 0x80, 0xd4, 0x55,
	0xd2, 0x06, 0x40, 0xf0, 0x35, 0x39, 0x8f, 0xcf, 0x56, 0xd8, 0x01, 0x2d, 0x50, 0x31, 0x35, 0x9c,
	0xe9, 0xa8, 0x1f, 0x9e, 0x46, 0xed, 0xa9, 0x02, 0x50, 0xbc, 0x8e, 0xb8, 0x8d, 0xe2, 0xe0, 0x12,
	0x39, 0x65, 0x58, 0x97, 0xd3, 0x3c, 0x8b, 0x99, 0xe5, 0x26, 0x3c, 0x83, 0xf0, 0x93, 0xb0, 0xf6,
	0xd2, 0x2d, 0x05, 0xdf, 0x93, 0x19, 0x78, 0x9c, 0x5c, 0xd3, 0x44, 0xa9, 0xcd, 0x3c, 0xf3, 0xa1,
	0xd0, 0x55, 0xf0, 0x10, 0x4d, 0x38, 0x0e, 0x1a, 0xcb, 0x33, 0xfb, 0x7b, 0x73, 0x53, 0x4d, 0x84,
	0xad, 0x23, 0x0a, 0xa3, 0xa2, 0xa1, 0x74, 0xe3, 0x89, 0x69, 0x4d, 0x65, 0x87, 0x09, 0x36, 0x0d,
	0xc4, 0xd7, 0x5b, 0xd1, 0x7b, 0xcb, 0x7a, 0xc8, 0x49, 0xb9, 0x74, 0x5e, 0x9f, 0x40, 0x23, 0x26,
	0x9c, 0x08, 0xf0, 0xab, 0x4e, 0x10, 0x3c, 0x20, 0x17, 0x35, 0xdf, 0xca, 0x85, 0xe6, 0x94, 0xef,
	0x66, 0x89, 0x88, 0x84, 0x85, 0x20, 0x4b, 0x99, 0x1e, 0xd0, 0x4d, 0x3e, 0x30, 0x61, 0xe0, 0x6e,
	0xde, 0x83, 0x56, 0x3d, 0xa6, 0xe9, 0x20, 0x4f, 0xf8, 0xc0, 0xc0, 0x53, 0xe8, 0x2a, 0x1d, 0x71,
	0x0a, 0x29, 0x26, 0x53, 0x42, 0x5a, 0xaa, 0xb9, 0xb1, 0x4c, 0xdb, 0xf0, 0x2c, 0x2a, 0x9f, 0x43,
	0x71, 0xbb, 0x90, 0xb6, 0x9c, 0x30, 0xb8, 0x4f, 0xce, 0x33, 0x88, 0x20, 0x48, 0x54, 0x19, 0xd3,
	0x9c, 0x32, 0x03, 0xce, 0xc6, 0x80, 0x09, 0x27, 0x9d, 0x26, 0x02, 0x9a, 0x4e, 0xfe, 0xc0, 0x6c,
	0x64, 0x16, 0x62, 0x04, 0x0e, 0x69, 0x79, 0x9a, 0x15, 0x89, 0xae, 0x38, 0xe4, 0x39, 0x77, 0x48,
	0x10, 0xb9, 0x4c, 0x57, 0x1c, 0x72, 0x83, 0x5c, 0x15, 0xa9, 0x3f, 0x5c, 0xa4, 0x92, 0x3c, 0x95,
	0x14, 0xe3, 0x0f, 0xde, 0xb5, 0x90, 0xbd, 0x92, 0xe0, 0x63, 0x17, 0x9b, 0x05, 0xb6, 0x8e, 0xd0,
	0x66, 0x05, 0x59, 0x10, 0xbe, 0x26, 0x37, 0xd5, 0x36, 0xd7, 0x5a, 0xc4, 0x45, 0x70, 0x69, 0xde,
	0x83, 0xc4, 0xf2, 0x56, 0x49, 0x4e, 0x23, 0x25, 0xbb, 0x62, 0xc8, 0x1a, 0x22, 0xeb, 0xd5, 0x42,
	0x01, 0x23, 0xad, 0x85, 0xf0, 0x37, 0x4a, 0xf2, 0x3a, 0x82, 0x0b, 0xe2, 0xaf, 0xc8, 0x79, 0x78,
	0x29, 0xe8, 0x96, 0x6e, 0x9e, 0x24, 0xee, 0x88, 0xd4, 0x44, 0x4c, 0x9a, 0x70, 0xda, 0x45, 0x7d,
	0x01, 0x68, 0xe4, 0x49, 0x82, 0xe7, 0x6c, 0x83, 0x34, 0xf8, 0x86, 0x4c, 0x97, 0x87, 0x34, 0x3c,
	0xe1, 0x91, 0xc5, 0x80, 0x72, 0x61, 0x18, 0xce, 0xb8, 0xa0, 0x2d, 0x10, 0x6d, 0x04, 0x34, 0x94,
	0x76, 0x21, 0x19, 0x2c, 0x90, 0x71, 0x21, 0x0d, 0xd7, 0x96, 0x76, 0x99, 0xb1, 0x34, 0x63, 0xb6,
	0x1f, 0x5e, 0x40, 0x95, 0xd3, 0x6e, 0xbd, 0xc1, 0x8c, 0x6d, 0x32, 0xdb, 0x0f, 0x1e, 0x91, 0x4b,
	0x2c, 0xb1, 0x5c, 0x17, 0x8e, 0xb4, 0x83, 0x8c, 0xd3, 0x1e, 0x97, 0x5c, 0xb3, 0xa4, 0x3c, 0xf2,
	0x45, 0x54, 0xbd, 0x88, 0x40, 0xe7, 0xc5, 0x17, 0x83, 0x8c, 0x3f, 0x74, 0xa8, 0xe2, 0xac, 0xb7,
	0x49, 0x60, 0x06, 0x32, 0xea, 0x6b, 0x25, 0x55, 0x6e, 0x68, 0xa4, 0x52, 0xc8, 0x84, 0xb3, 0xee,
	0x12, 0x2b, 0x92, 0x3a, 0x0a, 0x82, 0xeb, 0xe4, 0x8c, 0xa3, 0xa7, 0x86, 0x6f, 0xa1, 0x47, 0xc2,
	0x39, 0xc4, 0x8e, 0xb9, 0xe5, 0x36, 0xdf, 0x02, 0x47, 0x04, 0x2f, 0xc8, 0x0d, 0x8f, 0xcb, 0xa5,
	0xd8, 0xca, 0x39, 0xdd, 0x11, 0xb6, 0xaf, 0x72, 0x4b, 0x85, 0x8c, 0xf9, 0x2e, 0x5c, 0x8e, 0xb1,
	0x9a, 0x09, 0x69, 0x4d, 0x78, 0x09, 0xf5, 0xaf, 0x38, 0xf8, 0x4b, 0x44, 0xbf, 0x76, 0xe0, 0x35,
	0xc0, 0xd6, 0x87, 0xd0, 0xe0, 0x5b, 0x32, 0x63, 0x6c, 0xde, 0xa1, 0x11, 0xb3, 0x2c, 0x51, 0xbd,
	0xf7, 0x43, 0xef, 0x32, 0x32, 0x85, 0x00, 0xa9, 0x3b, 0xc4, 0x68, 0x04, 0x3e, 0x27, 0xd7, 0xf8,
	0x6e, 0xc6, 0xb5, 0x48, 0xb9, 0xb4, 0x2c, 0x81, 0xc3, 0x66, 0x98, 0x1d, 0xbd, 0x17, 0x35, 0xdf,
	0xd1, 0x02, 0xb2, 0xc5, 0x15, 0xac, 0xd6, 0x97, 0xab, 0xe0, 0xba, 0xc7, 0x3a, 0x47, 0xb6, 0x3c,
	0x12, 0x72, 0x54, 0xe1, 0x0f, 0xab, 0x39, 0x4b, 0xa9, 0xe6, 0x70, 0xb7, 0x58, 0xbf, 0xc2, 0x6b,
	0xee, 0xba, 0xbd, 0x67, 0x50, 0xde, 0x1a, 0x8a, 0x5d, 0x15, 0x32, 0x79, 0x62, 0x0d, 0xed, 0xe4,
	0x5d, 0x48, 0x44, 0x46, 0xbc, 0xe5, 0xe1, 0xf5, 0xa2, 0x0a, 0xa1, 0x68, 0x19, 0x25, 0x6d, 0xf1,
	0x96, 0x43, 0x2e, 0xce, 0xb4, 0xca, 0x58, 0x8f, 0x59, 0xa8, 0xa9, 0x59, 0x6e, 0x29, 0x16, 0x2a,
	0x21, 0x7b, 0xe1, 0x0d, 0x17, 0x95, 0xa5, 0x7c, 0x0d, 0xc4, 0x1b, 0x5e, 0x1a, 0xfc, 0xb5, 0x46,
	0x46, 0x0e, 0x83, 0xa5, 0xc1, 0x6c, 0x25, 0xf8, 0xca, 0xf1, 0xf1, 0xa5, 0x2a, 0xe6, 0xe1, 0x02,
	0x16, 0xe2, 0xc6, 0xfe, 0xde, 0xdc, 0xdc, 0x6a, 0x05, 0x0d, 0xc5, 0xa1, 0xfd, 0x7c, 0xbd, 0xe9,
	0xb1, 0x4f, 0x55, 0xcc, 0xdf, 0xfd, 0x7b, 0x48, 0x6b, 0x8e, 0xbf, 0x07, 0x30, 0x5b, 0x49, 0x15,
	0x10, 0x34, 0xc8, 0x18, 0xd8, 0x41, 0xc1, 0x10, 0xdc, 0xff, 0x26, 0xee, 0x7f, 0x79, 0x7f, 0x6f,
	0xee, 0xa4, 0x27, 0xf4, 0x7b, 0x9d, 0xf1, 0x7f, 0x57, 0x77, 0x79, 0x84, 0xdc, 0x27, 0x41, 0xb1,
	0xbd, 0x95, 0x20, 0xcf, 0x6b, 0x72, 0xde, 0x70, 0x2d, 0x58, 0x42, 0xa5, 0xd2, 0x29, 0x4b, 0xc4,
	0x5b, 0xf4, 0xaf, 0xe3, 0xfc, 0x04, 0x39, 0x67, 0xde, 0xed, 0xcd, 0x4d, 0xb5, 0x11, 0xf4, 0xac,
	0x8a, 0x41, 0xb2, 0x29, 0x73, 0xb8, 0x20, 0xd8, 0x20, 0x53, 0x92, 0xef, 0x50, 0x13, 0xf5, 0x79,
	0xca, 0x68, 0xd4, 0x67, 0xb2, 0xc7, 0xb5, 0xa3, 0xbd, 0x85, 0xb4, 0xe1, 0xbb, 0xbd, 0xb9, 0xc9,
	0x67, 0x7c, 0xa7, 0x8d, 0x88, 0xba, 0x03, 0x20, 0xe7, 0xa4, 0x3c, 0x64, 0x35, 0xf8, 0x33, 0x39,
	0x6d, 0xf8, 0x56, 0xce, 0x65, 0xc4, 0x69, 0xc4, 0xa2, 0x3e, 0x0f, 0x3f, 0x9d, 0x3f, 0xba, 0x70,
	0xf2, 0xee, 0xca, 0xe2, 0x1f, 0x34, 0xa0, 0x8b, 0x87, 0xb5, 0x99, 0x8b, 0x6d, 0xcf, 0x53, 0x07,
	0x9a, 0x55, 0x69, 0xf5, 0xc0, 0x75, 0x50, 0x23, 0xeb, 0xad, 0x31, 0x53, 0xfd, 0x1b, 0xdc, 0x22,
	0x13, 0x59, 0xc2, 0x22, 0x0e, 0x77, 0x52, 0xbe, 0x9a, 0xdb, 0x18, 0x3a, 0xe3, 0xa5, 0xa0, 0x78,
	0x2d, 0x03, 0x12, 0x14, 0x9d, 0x5a, 0x6e, 0xb8, 0xa6, 0xd8, 0xf7, 0x86, 0x8b, 0xf0, 0x34, 0x96,
	0x9f, 0xbc, 0xdb, 0x9b, 0x7b, 0xd8, 0x13, 0xb6, 0x9f, 0x77, 0x16, 0x23, 0x95, 0x2e, 0x95, 0xe6,
	0xc7, 0x9d, 0xe1, 0xef, 0xa5, 0x6c, 0xb3, 0xb7, 0x64, 0x78, 0x94, 0x43, 0x47, 0xb4, 0x04, 0x1c,
	0x92, 0xa5, 0x7c, 0xb1, 0xfd, 0x7c, 0xfd, 0xa5, 0xff, 0xdd, 0x04, 0xca, 0xd6, 0xb8, 0xdf, 0x06,
	0x56, 0x71, 0x25, 0x58, 0x22, 0x93, 0xd8, 0x35, 0xa9, 0x1d, 0x43, 0xe1, 0xa1, 0x59, 0x2e, 0x69,
	0xa2, 0x7a, 0xe1, 0x92, 0x7b, 0x1a, 0x76, 0x57, 0xb6, 0xd4, 0x8e, 0x79, 0xed, 0x24, 0xeb, 0xaa,
	0x77, 0xa8, 0x02, 0xd7, 0x3a, 0xbc, 0x73, 0x98, 0xc2, 0xaa, 0xd6, 0xc1, 0x4d, 0x32, 0x51, 0x2a,
	0x60, 0x73, 0x06, 0xf4, 0x9f, 0x21, 0xfa, 0xb4, 0x47, 0x43, 0x47, 0x05, 0xdc, 0x07, 0xa0, 0x40,
	0x7c, 0xf7, 0x00, 0x14, 0x58, 0xef, 0x92, 0x73, 0x2c, 0xb7, 0x8a, 0x6a, 0xde, 0x57, 0x69, 0xb5,
	0xa6, 0xdd, 0x43, 0x1f, 0x9f, 0x05, 0x61, 0xcb, 0xcb, 0x0a, 0x37, 0x5f, 0x22, 0xa7, 0x84, 0xa1,
	0x26, 0xcf, 0xb8, 0x06, 0x17, 0x85, 0x9f, 0xbb, 0x4e, 0x45, 0x98, 0x76, 0xb1, 0x04, 0xa7, 0x4b,
	0x98, 0xee, 0x71, 0x57, 0x8c, 0x20, 0xe9, 0xa2, 0x35, 0xe1, 0x7f, 0xcf, 0xd7, 0x16, 0x6a, 0xad,
	0x09, 0x94, 0x41, 0x1d, 0x82, 0xcc, 0x0b, 0xe6, 0x40, 0x9e, 0x14, 0xf2, 0x27, 0x28, 0x3e, 0x9a,
	0x5b, 0x3d, 0x00, 0x8b, 0x95, 0x1e, 0xe6, 0xc9, 0x2f, 0x5c, 0x9e, 0x74, 0x90, 0x16, 0x20, 0x56,
	0x11, 0x50, 0x98, 0xf4, 0x09, 0x99, 0x90, 0xb0, 0x13, 0x66, 0x17, 0x1e, 0xd3, 0x84, 0x19, 0x1b,
	0x7e, 0x89, 0x4a, 0x67, 0x40, 0xb0, 0xe1, 0xd6, 0xd7, 0x99, 0xb1, 0x30, 0xee, 0xf8, 0xae, 0x12,
	0x93, 0x09, 0xed, 0xc1, 0x43, 0x0f, 0xef, 0xbb, 0x98, 0xf2, 0x12, 0x78, 0xf5, 0x0f, 0x61, 0x3d,
	0xd8, 0x24, 0xa7, 0xa3, 0xdc, 0x58, 0x95, 0x62, 0x43, 0xa7, 0xa4, 0x09, 0xbf, 0xfa, 0x4f, 0x1f,
	0x40, 0x1d, 0x79, 0x36, 0x1c, 0x0d, 0x3e, 0x80, 0xd6, 0x58, 0x54, 0x5d, 0x0b, 0x96, 0xc9, 0x45,
	0x57, 0x6d, 0x34, 0x87, 0xb2, 0xc6, 0x81, 0x0e, 0x04, 0xa5, 0x1f, 0xbe, 0x46, 0x2b, 0x67, 0x10,
	0xd4, 0x1a, 0xc5, 0x14, 0xae, 0xb8, 0x41, 0xce, 0xb0, 0x6d, 0x25, 0x62, 0x9f, 0xa1, 0x21, 0xd5,
	0x7e, 0xe3, 0x2a, 0x32, 0x2e, 0x2f, 0x17, 0xab, 0x70, 0xf5, 0x51, 0x9f, 0x47, 0x9b, 0xb4, 0x9b,
	0x4b, 0x37, 0xe6, 0x74, 0x54, 0x2c, 0xb8, 0x09, 0xff, 0xc7, 0x5d, 0x3d, 0x0a, 0x1b, 0x5e, 0xb6,
	0x8c, 0xa2, 0x60, 0x95, 0xcc, 0x47, 0x0a, 0x12, 0x20, 0xb4, 0x0e, 0x58, 0x21, 0x69, 0x31, 0x01,
	0x60, 0x9b, 0x0c, 0xd5, 0xe0, 0x5b, 0x67, 0x23, 0xe0, 0xb0, 0xc3, 0x80, 0xd2, 0xb8, 0xe2, 0x40,
	0xd0, 0x28, 0x43, 0x5d, 0x68, 0x8e, 0x0e, 0x0e, 0x5b, 0xb9, 0x6f, 0x99, 0xbb, 0xd4, 0x70, 0xbd,
	0x2d, 0x22, 0x1e, 0xfe, 0xef, 0x7c, 0x6d, 0xe1, 0xc3, 0xe5, 0x53, 0xef, 0xf6, 0xe6, 0x8e, 0x3f,
	0x57, 0xed, 0x75, 0xbe, 0xcd, 0x93, 0xea, 0x18, 0xf1, 0xdc, 0x69, 0x6c, 0x74, 0xdb, 0x0e, 0x0f,
	0x01, 0x07, 0x3d, 0xa0, 0xc9, 0x12, 0xe1, 0xac, 0xf3, 0x03, 0xd2, 0xff, 0x01, 0x4f, 0x6b, 0x42,
	0x65, 0xb6, 0x0d, 0x22, 0x30, 0xa8, 0x1c, 0x90, 0x8a, 0x32, 0x08, 0x51, 0xeb, 0x1b, 0x31, 0x13,
	0x7e, 0xe7, 0xa6, 0x1d, 0x5f, 0x01, 0x41, 0xe4, 0x7a, 0x2e, 0x13, 0xfc, 0x48, 0x6e, 0x97, 0xcd,
	0x9b, 0x6b, 0x65, 0x8a, 0x86, 0xd7, 0x37, 0x71, 0x30, 0x7e, 0x56, 0xb8, 0xc2, 0x07, 0x48, 0x75,
	0xa3, 0x50, 0x7a, 0x00, 0x3a, 0xbe, 0x01, 0x76, 0x9c, 0x6b, 0xb2, 0xb2, 0x41, 0xc0, 0xc9, 0x1d,
	0x6f, 0x51, 0xd9, 0x8f, 0x55, 0x67, 0x50, 0x68, 0xca, 0x3a, 0xcc, 0x46, 0x7d, 0x1c, 0x46, 0x30,
	0xef, 0x99, 0x70, 0x19, 0xb7, 0xb8, 0xe5, 0xf4, 0xd6, 0xbc, 0x5a, 0x65, 0xfa, 0x6c, 0x28, 0xbd,
	0x0c, 0x3a, 0xed, 0x52, 0x25, 0xf8, 0x13, 0xb9, 0x0d, 0x65, 0x2e, 0xb2, 0x94, 0xc9, 0x98, 0x8a,
	0x9e, 0x54, 0x9a, 0x53, 0xa9, 0x2c, 0xdd, 0x16, 0x46, 0xc0, 0xee, 0xae, 0xb5, 0x30, 0x70, 0x9c,
	0x48, 0x65, 0x83, 0xb0, 0x8e, 0x7b, 0x5c, 0x77, 0x4a, 0x0f, 0x64, 0xbc, 0x86, 0x2a, 0xcf, 0x94,
	0x7d, 0xe5, 0x14, 0x5c, 0x7f, 0x61, 0xd6, 0x64, 0x5d, 0x65, 0x83, 0x60, 0x95, 0xcc, 0x61, 0x67,
	0x9b, 0x25, 0x1c, 0xea, 0x8e, 0xe8, 0xfa, 0xde, 0xc1, 0xc0, 0xed, 0x62, 0xf7, 0x13, 0xae, 0x20,
	0xe1, 0x85, 0x02, 0xf6, 0xb4, 0x8a, 0xda, 0xe8, 0x62, 0x03, 0x14, 0xf4, 0xc8, 0x5d, 0xd3, 0xc7,
	0x1e, 0xbf, 0x9c, 0x29, 0x2a, 0x2d, 0x18, 0x55, 0xf2, 0x30, 0x93, 0xc3, 0x55, 0xe7, 0x0e, 0xd0,
	0x1c, 0x4e, 0x1a, 0xc3, 0x76, 0x6c, 0x43, 0x1e, 0xb0, 0x1a, 0x06, 0x19, 0xcb, 0x8d, 0x85, 0xd4,
	0x37, 0x1c, 0xfe, 0x34, 0x93, 0xb1, 0x4a, 0xa9, 0xe1, 0x3c, 0x0e, 0x1b, 0x98, 0x37, 0xa7, 0x3d,
	0xa8, 0xfc, 0xa6, 0xd1, 0x42, 0x48, 0x9b, 0xf3, 0x38, 0xa0, 0xe4, 0x76, 0x2e, 0x4b, 0xe3, 0x78,
	0x4c, 0xa5, 0x02, 0xd7, 0x6d, 0xe3, 0x33, 0xf3, 0xed, 0x23, 0x86, 0x64, 0xf1, 0x8a, 0x1f, 0xa2,
	0x99, 0x0b, 0x23, 0x4a, 0xcf, 0x94, 0xac, 0x7b, 0x15, 0x6c, 0x22, 0x21, 0x52, 0x8b, 0x27, 0xfd,
	0x94, 0x5c, 0x39, 0x68, 0x23, 0xbe, 0xc3, 0x8c, 0x6b, 0x9b, 0xeb, 0x8e, 0x6b, 0xde, 0x1e, 0x61,
	0x72, 0x9d, 0x7f, 0xdf, 0xd2, 0xba, 0x32, 0xb6, 0x59, 0xc1, 0x05, 0x6f, 0xc8, 0x27, 0x07, 0xe9,
	0x8a, 0x94, 0xa8, 0x73, 0xc8, 0x8b, 0x5a, 0x75, 0x58, 0x47, 0xc0, 0x13, 0x0b, 0xd7, 0x90, 0xf5,
	0xfa, 0xfb, 0xac, 0x7e, 0xde, 0x6e, 0xe5, 0x09, 0xd4, 0xc4, 0x02, 0x0d, 0x6d, 0xfe, 0xe8, 0x0c,
	0x5d, 0xbd, 0x26, 0x74, 0x05, 0x37, 0xe1, 0x63, 0xd7, 0xe6, 0x57, 0xe7, 0xe8, 0xe1, 0xc5, 0xac,
	0x39, 0x50, 0x70, 0x8f, 0x7c, 0x0c, 0xe1, 0x37, 0x1c, 0x2c, 0x4a, 0xf7, 0x3d, 0xf1, 0xf9, 0x49,
	0x65, 0x83, 0x62, 0xbc, 0x28, 0x3c, 0xf5, 0x03, 0xb9, 0x55, 0x1c, 0xa4, 0xaf, 0xa0, 0x53, 0xcb,
	0xb4, 0x82, 0x92, 0xe1, 0x9f, 0x27, 0xce, 0xb6, 0x98, 0x18, 0x9c, 0xc7, 0xd6, 0x5d, 0x68, 0x7b,
	0x95, 0x47, 0xa0, 0xd1, 0x2c, 0x15, 0xd6, 0x24, 0x0c, 0xbc, 0xeb, 0x25, 0x3a, 0xf8, 0x92, 0x84,
	0xce, 0x22, 0xad, 0x52, 0xca, 0xac, 0x4a, 0x45, 0x54, 0xda, 0xf4, 0xd4, 0xcd, 0x9d, 0x68, 0x93,
	0x56, 0xe9, 0x03, 0x94, 0x16, 0x56, 0x2d, 0x92, 0xb3, 0x5c, 0xba, 0x59, 0xb7, 0xaf, 0x52, 0x5e,
	0xe4, 0x87, 0x67, 0x6e, 0x64, 0xf1, 0xa2, 0x47, 0x2a, 0xe5, 0x3e, 0x13, 0x7c, 0x41, 0xa6, 0x46,
	0x9d, 0xd8, 0x55, 0x9a, 0x47, 0x0c, 0xca, 0xd4, 0x86, 0xdb, 0xa7, 0xea, 0xba, 0x46, 0x21, 0x84,
	0x11, 0x66, 0x9b, 0x69, 0xe1, 0x72, 0x88, 0xe4, 0x45, 0x5a, 0xad, 0x7c, 0x2c, 0x28, 0xed, 0x6d,
	0xba, 0x11, 0xa6, 0x80, 0xaf, 0x95, 0xe8, 0xe1, 0xa7, 0x81, 0xc2, 0xfa, 0x57, 0x64, 0x61, 0xd4,
	0x1a, 0x91, 0x66, 0x5a, 0x6d, 0xf3, 0x18, 0x62, 0xe6, 0xa7, 0xa2, 0x76, 0xb8, 0x2f, 0x24, 0xaf,
	0xfc, 0xcc, 0x5a, 0x31, 0x6f, 0xcd, 0xa3, 0x57, 0x86, 0x60, 0xf7, 0xb1, 0x44, 0x90, 0x7b, 0xa3,
	0xbc, 0x78, 0x31, 0xe5, 0x80, 0x80, 0x09, 0xcf, 0x8d, 0x28, 0xf0, 0xaf, 0xa7, 0x55, 0x9e, 0xd1,
	0xce, 0x20, 0xfc, 0x7f, 0xdc, 0xe2, 0xd3, 0xea, 0x16, 0x78, 0x47, 0xc5, 0xe8, 0xd0, 0x50, 0xba,
	0x5d, 0x68, 0x3d, 0x04, 0xa5, 0xe5, 0x01, 0x8c, 0xc7, 0xc3, 0x9b, 0x83, 0x06, 0x43, 0x54, 0x66,
	0xb0, 0xef, 0xdd, 0x20, 0x52, 0x5c, 0x5d, 0xcb, 0x89, 0x2b, 0xa7, 0x8f, 0x79, 0x94, 0x30, 0xcd,
	0x69, 0x94, 0x6b, 0x83, 0x36, 0xf9, 0x5c, 0x5a, 0x7c, 0x0e, 0x2c, 0x99, 0xde, 0xb8, 0xd3, 0x7b,
	0x7c, 0x1d, 0xe1, 0x65, 0xe6, 0xf5, 0x5f, 0x00, 0x0b, 0xde, 0x3e, 0xb9, 0xfb, 0x3b, 0x5e, 0x75,
	0x35, 0xac, 0xea, 0x5b, 0xf0, 0x04, 0x7e, 0xea, 0x09, 0x7f, 0x38, 0x78, 0xf8, 0xc2, 0xbf, 0x58,
	0xdf, 0x2a, 0x4e, 0x6e, 0x28, 0xf7, 0x3d, 0x10, 0x32, 0xf2, 0x70, 0x27, 0x96, 0xec, 0xb0, 0x81,
	0x79, 0xff, 0xbb, 0xd8, 0x8f, 0x2e, 0x23, 0x97, 0xb0, 0x07, 0x88, 0x1a, 0xfd, 0x3a, 0x56, 0x27,
	0xb3, 0xfe, 0x83, 0x4b, 0x5c, 0xa9, 0x40, 0x6e, 0x28, 0x70, 0x85, 0x9f, 0x61, 0xa6, 0x9c, 0x29,
	0x50, 0xc3, 0x9a, 0x83, 0xad, 0x3c, 0x16, 0xfe, 0x9b, 0x64, 0xdc, 0x5d, 0x29, 0xd7, 0xa5, 0xd7,
	0x3a, 0xae, 0x4d, 0x2b, 0xd6, 0x0b, 0x07, 0xdd, 0x27, 0x61, 0x2e, 0x3b, 0x2a, 0x97, 0x31, 0x8f,
	0x69, 0xc6, 0x34, 0x4b, 0x12, 0x9e, 0xf8, 0x2f, 0x1a, 0xdc, 0x5d, 0x59, 0x29, 0x6f, 0x7a, 0xb1,
	0xfb, 0xa2, 0xd1, 0x25, 0x77, 0x86, 0x07, 0x76, 0x69, 0x00, 0x52, 0xad, 0xd6, 0x3c, 0x61, 0x30,
	0x3b, 0x97, 0x0f, 0xc3, 0xe4, 0x9d, 0xad, 0x9c, 0xc3, 0x6d, 0x87, 0xdd, 0xf7, 0x1c, 0x8b, 0xb9,
	0xe0, 0x65, 0x45, 0x6b, 0xd5, 0x2b, 0xb5, 0x4b, 0x9d, 0xe9, 0x2d, 0x12, 0x1c, 0x9c, 0x69, 0x82,
	0x71, 0x72, 0x74, 0x93, 0x0f, 0xf0, 0xf3, 0xf9, 0x58, 0x0b, 0x7e, 0x06, 0xab, 0xe4, 0xc3, 0x6d,
	0x96, 0xe4, 0x1c, 0xbf, 0x8d, 0x9f, 0xbc, 0xbb, 0xf4, 0x87, 0x9d, 0xe3, 0x41, 0xc6, 0x96, 0xd3,
	0xfe, 0xfa, 0x83, 0xfb, 0xb5, 0xe9, 0xef, 0x48, 0x70, 0xb0, 0x8b, 0xac, 0x6e, 0x79, 0xc2, 0x6d,
	0x39, 0x59, 0xdd, 0xf2, 0x44, 0x85, 0xe1, 0xf1, 0xb1, 0xe3, 0x53, 0xe3, 0xe1, 0xe3, 0x63, 0xc7,
	0xcf, 0x8f, 0x4f, 0x3f, 0x3e, 0x76, 0x7c, 0x7e, 0xfc, 0xd2, 0xe3, 0x63, 0xc7, 0xaf, 0x8e, 0x5f,
	0xbb, 0xfc, 0xf7, 0xda, 0xa1, 0xa7, 0xb9, 0x46, 0x4e, 0xe3, 0x0d, 0xc7, 0x74, 0x9b, 0x6b, 0x30,
	0xd3, 0x1f, 0x6c, 0xcc, 0xad, 0xbe, 0x72, 0x8b, 0xc1, 0x15, 0x32, 0x16, 0xe5, 0x5a, 0xc3, 0xa3,
	0x18, 0xee, 0x7b, 0xb4, 0x75, 0xca, 0x2f, 0xbe, 0x82, 0xb5, 0xe0, 0x02, 0x39, 0x21, 0x64, 0xa4,
	0x31, 0x26, 0xdc, 0x97, 0xfd, 0xd6, 0x70, 0x21, 0xb8, 0x48, 0x88, 0xcc, 0x53, 0xa7, 0x6e, 0xdc,
	0x77, 0xfb, 0xd6, 0x09, 0x99, 0xa7, 0xa8, 0x6b, 0x96, 0x97, 0x7e, 0xfe, 0xe7, 0xec, 0x91, 0x9f,
	0xf7, 0x67, 0x6b, 0xbf, 0xec, 0xcf, 0xd6, 0x7e, 0xdd, 0x9f, 0xad, 0xfd, 0x63, 0x7f, 0xb6, 0xf6,
	0x97, 0xdf, 0x66, 0x8f, 0xfc, 0xf2, 0xdb, 0xec, 0x91, 0x5f, 0x7f, 0x9b, 0x3d, 0xf2, 0x66, 0x6c,
	0xc4, 0x91, 0x9d, 0x8f, 0x70, 0xfa, 0xbb, 0xf7, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd3, 0xa1,
	0xc6, 0xdc, 0x5b, 0x19, 0x00, 0x00,
}

func (m *LocalOnlySessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalOnlySessionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalOnlySessionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptimizerHoistUncorrelatedEqualitySubqueries {
		i--
		if m.OptimizerHoistUncorrelatedEqualitySubqueries {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.UnboundedParallelScans {
		i--
		if m.UnboundedParallelScans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.StreamerEnabled {
		i--
		if m.StreamerEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x90
	}
	if m.PreparedStatementsCacheSize != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.PreparedStatementsCacheSize))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x88
	}
	if m.OptimizerAlwaysUseHistograms {
		i--
		if m.OptimizerAlwaysUseHistograms {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xf0
	}
	if m.OptimizerUseImprovedSplitDisjunctionForJoins {
		i--
		if m.OptimizerUseImprovedSplitDisjunctionForJoins {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd8
	}
	if m.DeclareCursorStatementTimeoutEnabled {
		i--
		if m.DeclareCursorStatementTimeoutEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.CopyFromRetriesEnabled {
		i--
		if m.CopyFromRetriesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc8
	}
	if m.OptimizerUseLimitOrderingForStreamingGroupBy {
		i--
		if m.OptimizerUseLimitOrderingForStreamingGroupBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc0
	}
	if m.OptimizerUseImprovedDisjunctionStats {
		i--
		if m.OptimizerUseImprovedDisjunctionStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb0
	}
	if m.VariableInequalityLookupJoinEnabled {
		i--
		if m.VariableInequalityLookupJoinEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if m.OptimizerUseForecasts {
		i--
		if m.OptimizerUseForecasts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf8
	}
	if m.EnforceHomeRegion {
		i--
		if m.EnforceHomeRegion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf0
	}
	if m.CopyFromAtomicEnabled {
		i--
		if m.CopyFromAtomicEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe8
	}
	if m.DisableHoistProjectionInJoinLimitation {
		i--
		if m.DisableHoistProjectionInJoinLimitation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe0
	}
	if m.CopyFastPathEnabled {
		i--
		if m.CopyFastPathEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd8
	}
	if m.OptimizerUseNotVisibleIndexes {
		i--
		if m.OptimizerUseNotVisibleIndexes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd0
	}
	if m.TestingOptimizerDisableRuleProbability != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestingOptimizerDisableRuleProbability))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc9
	}
	if m.TestingOptimizerCostPerturbation != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestingOptimizerCostPerturbation))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc1
	}
	if m.UnconstrainedNonCoveringIndexScanEnabled {
		i--
		if m.UnconstrainedNonCoveringIndexScanEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb8
	}
	if m.TestingOptimizerRandomSeed != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TestingOptimizerRandomSeed))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb0
	}
	if m.ShowPrimaryKeyConstraintOnNotVisibleColumns {
		i--
		if m.ShowPrimaryKeyConstraintOnNotVisibleColumns {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa8
	}
	if m.MultipleModificationsOfTable {
		i--
		if m.MultipleModificationsOfTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa0
	}
	if m.ExpectAndIgnoreNotVisibleColumnsInCopy {
		i--
		if m.ExpectAndIgnoreNotVisibleColumnsInCopy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x98
	}
	if m.EnableImplicitTransactionForBatchStatements {
		i--
		if m.EnableImplicitTransactionForBatchStatements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x90
	}
	if m.OverrideAlterPrimaryRegionInSuperRegion {
		i--
		if m.OverrideAlterPrimaryRegionInSuperRegion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.EnableSuperRegions {
		i--
		if m.EnableSuperRegions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x80
	}
	if m.OptSplitScanLimit != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.OptSplitScanLimit))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if m.DefaultTxnQualityOfService != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DefaultTxnQualityOfService))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf0
	}
	if m.CostScansWithDefaultColSize {
		i--
		if m.CostScansWithDefaultColSize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.CheckFunctionBodies {
		i--
		if m.CheckFunctionBodies {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.AvoidBuffering {
		i--
		if m.AvoidBuffering {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.IndexRecommendationsEnabled {
		i--
		if m.IndexRecommendationsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if len(m.CustomOptions) > 0 {
		keysForCustomOptions := make([]string, 0, len(m.CustomOptions))
		for k := range m.CustomOptions {
			keysForCustomOptions = append(keysForCustomOptions, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForCustomOptions)
		for iNdEx := len(keysForCustomOptions) - 1; iNdEx >= 0; iNdEx-- {
			v := m.CustomOptions[string(keysForCustomOptions[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForCustomOptions[iNdEx])
			copy(dAtA[i:], keysForCustomOptions[iNdEx])
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(keysForCustomOptions[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xca
		}
	}
	if m.DisablePlanGists {
		i--
		if m.DisablePlanGists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.NullOrderedLast {
		i--
		if m.NullOrderedLast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.InjectRetryErrorsEnabled {
		i--
		if m.InjectRetryErrorsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.LargeFullScanRows != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LargeFullScanRows))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa9
	}
	if m.IsSuperuser {
		i--
		if m.IsSuperuser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.AutoRehomingEnabled {
		i--
		if m.AutoRehomingEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.TxnRowsReadErr != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsReadErr))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.TxnRowsReadLog != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsReadLog))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.TxnRowsWrittenErr != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsWrittenErr))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.TxnRowsWrittenLog != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.TxnRowsWrittenLog))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if len(m.SessionUserProto) > 0 {
		i -= len(m.SessionUserProto)
		copy(dAtA[i:], m.SessionUserProto)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.SessionUserProto)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.PlacementEnabled {
		i--
		if m.PlacementEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if len(m.SequenceCache) > 0 {
		keysForSequenceCache := make([]uint32, 0, len(m.SequenceCache))
		for k := range m.SequenceCache {
			keysForSequenceCache = append(keysForSequenceCache, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForSequenceCache)
		for iNdEx := len(keysForSequenceCache) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SequenceCache[uint32(keysForSequenceCache[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(keysForSequenceCache[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xe2
		}
	}
	if m.NewSchemaChangerMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.NewSchemaChangerMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.SerialNormalizationMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.SerialNormalizationMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.DistSQLMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DistSQLMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.ExperimentalDistSQLPlanningMode != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ExperimentalDistSQLPlanningMode))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.PropagateInputOrdering {
		i--
		if m.PropagateInputOrdering {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.ResultsBufferSize != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ResultsBufferSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.EnableStreamReplication {
		i--
		if m.EnableStreamReplication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if len(m.ExperimentalComputedColumnRewrites) > 0 {
		i -= len(m.ExperimentalComputedColumnRewrites)
		copy(dAtA[i:], m.ExperimentalComputedColumnRewrites)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.ExperimentalComputedColumnRewrites)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.StubCatalogTablesEnabled {
		i--
		if m.StubCatalogTablesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.EnableUniqueWithoutIndexConstraints {
		i--
		if m.EnableUniqueWithoutIndexConstraints {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.EnableSeqScan {
		i--
		if m.EnableSeqScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.SynchronousCommit {
		i--
		if m.SynchronousCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.AlterColumnTypeGeneralEnabled {
		i--
		if m.AlterColumnTypeGeneralEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.InsertFastPath {
		i--
		if m.InsertFastPath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.ImplicitSelectForUpdate {
		i--
		if m.ImplicitSelectForUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.DisallowFullTableScans {
		i--
		if m.DisallowFullTableScans {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.OverrideMultiRegionZoneConfigEnabled {
		i--
		if m.OverrideMultiRegionZoneConfigEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.ImplicitColumnPartitioningEnabled {
		i--
		if m.ImplicitColumnPartitioningEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.TempTablesEnabled {
		i--
		if m.TempTablesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AllowPrepareAsOptPlan {
		i--
		if m.AllowPrepareAsOptPlan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ForceSavepointRestart {
		i--
		if m.ForceSavepointRestart {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.RequireExplicitPrimaryKeys {
		i--
		if m.RequireExplicitPrimaryKeys {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ZigzagJoinEnabled {
		i--
		if m.ZigzagJoinEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.PreferLookupJoinsForFKs {
		i--
		if m.PreferLookupJoinsForFKs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SafeUpdates {
		i--
		if m.SafeUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.LocalityOptimizedSearch {
		i--
		if m.LocalityOptimizedSearch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.OptimizerUseMultiColStats {
		i--
		if m.OptimizerUseMultiColStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.OptimizerUseHistograms {
		i--
		if m.OptimizerUseHistograms {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.PartiallyDistributedPlansDisabled {
		i--
		if m.PartiallyDistributedPlansDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.DefaultTxnUseFollowerReads {
		i--
		if m.DefaultTxnUseFollowerReads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.DefaultTxnReadOnly {
		i--
		if m.DefaultTxnReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DefaultTxnPriority != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.DefaultTxnPriority))
		i--
		dAtA[i] = 0x40
	}
	if m.ReorderJoinsLimit != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.ReorderJoinsLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.NoticeDisplaySeverity != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.NoticeDisplaySeverity))
		i--
		dAtA[i] = 0x30
	}
	if m.IdleInTransactionSessionTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.IdleInTransactionSessionTimeout))
		i--
		dAtA[i] = 0x28
	}
	if m.IdleInSessionTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.IdleInSessionTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.StmtTimeout != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.StmtTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.OptimizerFKCascadesLimit != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.OptimizerFKCascadesLimit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SaveTablesPrefix) > 0 {
		i -= len(m.SaveTablesPrefix)
		copy(dAtA[i:], m.SaveTablesPrefix)
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(len(m.SaveTablesPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SequenceCacheEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceCacheEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceCacheEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumValues != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.NumValues))
		i--
		dAtA[i] = 0x20
	}
	if m.Increment != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.Increment))
		i--
		dAtA[i] = 0x18
	}
	if m.CurrentValue != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.CurrentValue))
		i--
		dAtA[i] = 0x10
	}
	if m.CachedVersion != 0 {
		i = encodeVarintLocalOnlySessionData(dAtA, i, uint64(m.CachedVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintLocalOnlySessionData(dAtA []byte, offset int, v uint64) int {
	offset -= sovLocalOnlySessionData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LocalOnlySessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SaveTablesPrefix)
	if l > 0 {
		n += 1 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.OptimizerFKCascadesLimit != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.OptimizerFKCascadesLimit))
	}
	if m.StmtTimeout != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.StmtTimeout))
	}
	if m.IdleInSessionTimeout != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.IdleInSessionTimeout))
	}
	if m.IdleInTransactionSessionTimeout != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.IdleInTransactionSessionTimeout))
	}
	if m.NoticeDisplaySeverity != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.NoticeDisplaySeverity))
	}
	if m.ReorderJoinsLimit != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.ReorderJoinsLimit))
	}
	if m.DefaultTxnPriority != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.DefaultTxnPriority))
	}
	if m.DefaultTxnReadOnly {
		n += 2
	}
	if m.DefaultTxnUseFollowerReads {
		n += 2
	}
	if m.PartiallyDistributedPlansDisabled {
		n += 2
	}
	if m.OptimizerUseHistograms {
		n += 2
	}
	if m.OptimizerUseMultiColStats {
		n += 2
	}
	if m.LocalityOptimizedSearch {
		n += 2
	}
	if m.SafeUpdates {
		n += 2
	}
	if m.PreferLookupJoinsForFKs {
		n += 3
	}
	if m.ZigzagJoinEnabled {
		n += 3
	}
	if m.RequireExplicitPrimaryKeys {
		n += 3
	}
	if m.ForceSavepointRestart {
		n += 3
	}
	if m.AllowPrepareAsOptPlan {
		n += 3
	}
	if m.TempTablesEnabled {
		n += 3
	}
	if m.ImplicitColumnPartitioningEnabled {
		n += 3
	}
	if m.OverrideMultiRegionZoneConfigEnabled {
		n += 3
	}
	if m.DisallowFullTableScans {
		n += 3
	}
	if m.ImplicitSelectForUpdate {
		n += 3
	}
	if m.InsertFastPath {
		n += 3
	}
	if m.AlterColumnTypeGeneralEnabled {
		n += 3
	}
	if m.SynchronousCommit {
		n += 3
	}
	if m.EnableSeqScan {
		n += 3
	}
	if m.EnableUniqueWithoutIndexConstraints {
		n += 3
	}
	if m.StubCatalogTablesEnabled {
		n += 3
	}
	l = len(m.ExperimentalComputedColumnRewrites)
	if l > 0 {
		n += 2 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.EnableStreamReplication {
		n += 3
	}
	if m.ResultsBufferSize != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.ResultsBufferSize))
	}
	if m.PropagateInputOrdering {
		n += 3
	}
	if m.ExperimentalDistSQLPlanningMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.ExperimentalDistSQLPlanningMode))
	}
	if m.DistSQLMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DistSQLMode))
	}
	if m.SerialNormalizationMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.SerialNormalizationMode))
	}
	if m.NewSchemaChangerMode != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.NewSchemaChangerMode))
	}
	if len(m.SequenceCache) > 0 {
		for k, v := range m.SequenceCache {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLocalOnlySessionData(uint64(l))
			}
			mapEntrySize := 1 + sovLocalOnlySessionData(uint64(k)) + l
			n += mapEntrySize + 2 + sovLocalOnlySessionData(uint64(mapEntrySize))
		}
	}
	if m.PlacementEnabled {
		n += 3
	}
	l = len(m.SessionUserProto)
	if l > 0 {
		n += 2 + l + sovLocalOnlySessionData(uint64(l))
	}
	if m.TxnRowsWrittenLog != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsWrittenLog))
	}
	if m.TxnRowsWrittenErr != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsWrittenErr))
	}
	if m.TxnRowsReadLog != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsReadLog))
	}
	if m.TxnRowsReadErr != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TxnRowsReadErr))
	}
	if m.AutoRehomingEnabled {
		n += 3
	}
	if m.IsSuperuser {
		n += 3
	}
	if m.LargeFullScanRows != 0 {
		n += 10
	}
	if m.InjectRetryErrorsEnabled {
		n += 3
	}
	if m.NullOrderedLast {
		n += 3
	}
	if m.DisablePlanGists {
		n += 3
	}
	if len(m.CustomOptions) > 0 {
		for k, v := range m.CustomOptions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLocalOnlySessionData(uint64(len(k))) + 1 + len(v) + sovLocalOnlySessionData(uint64(len(v)))
			n += mapEntrySize + 2 + sovLocalOnlySessionData(uint64(mapEntrySize))
		}
	}
	if m.IndexRecommendationsEnabled {
		n += 3
	}
	if m.AvoidBuffering {
		n += 3
	}
	if m.CheckFunctionBodies {
		n += 3
	}
	if m.CostScansWithDefaultColSize {
		n += 3
	}
	if m.DefaultTxnQualityOfService != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.DefaultTxnQualityOfService))
	}
	if m.OptSplitScanLimit != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.OptSplitScanLimit))
	}
	if m.EnableSuperRegions {
		n += 3
	}
	if m.OverrideAlterPrimaryRegionInSuperRegion {
		n += 3
	}
	if m.EnableImplicitTransactionForBatchStatements {
		n += 3
	}
	if m.ExpectAndIgnoreNotVisibleColumnsInCopy {
		n += 3
	}
	if m.MultipleModificationsOfTable {
		n += 3
	}
	if m.ShowPrimaryKeyConstraintOnNotVisibleColumns {
		n += 3
	}
	if m.TestingOptimizerRandomSeed != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.TestingOptimizerRandomSeed))
	}
	if m.UnconstrainedNonCoveringIndexScanEnabled {
		n += 3
	}
	if m.TestingOptimizerCostPerturbation != 0 {
		n += 10
	}
	if m.TestingOptimizerDisableRuleProbability != 0 {
		n += 10
	}
	if m.OptimizerUseNotVisibleIndexes {
		n += 3
	}
	if m.CopyFastPathEnabled {
		n += 3
	}
	if m.DisableHoistProjectionInJoinLimitation {
		n += 3
	}
	if m.CopyFromAtomicEnabled {
		n += 3
	}
	if m.EnforceHomeRegion {
		n += 3
	}
	if m.OptimizerUseForecasts {
		n += 3
	}
	if m.VariableInequalityLookupJoinEnabled {
		n += 3
	}
	if m.OptimizerUseImprovedDisjunctionStats {
		n += 3
	}
	if m.OptimizerUseLimitOrderingForStreamingGroupBy {
		n += 3
	}
	if m.CopyFromRetriesEnabled {
		n += 3
	}
	if m.DeclareCursorStatementTimeoutEnabled {
		n += 3
	}
	if m.OptimizerUseImprovedSplitDisjunctionForJoins {
		n += 3
	}
	if m.OptimizerAlwaysUseHistograms {
		n += 3
	}
	if m.PreparedStatementsCacheSize != 0 {
		n += 2 + sovLocalOnlySessionData(uint64(m.PreparedStatementsCacheSize))
	}
	if m.StreamerEnabled {
		n += 3
	}
	if m.UnboundedParallelScans {
		n += 3
	}
	if m.OptimizerHoistUncorrelatedEqualitySubqueries {
		n += 3
	}
	return n
}

func (m *SequenceCacheEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CachedVersion != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.CachedVersion))
	}
	if m.CurrentValue != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.CurrentValue))
	}
	if m.Increment != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.Increment))
	}
	if m.NumValues != 0 {
		n += 1 + sovLocalOnlySessionData(uint64(m.NumValues))
	}
	return n
}

func sovLocalOnlySessionData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLocalOnlySessionData(x uint64) (n int) {
	return sovLocalOnlySessionData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LocalOnlySessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalOnlySessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalOnlySessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalOnlySessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaveTablesPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SaveTablesPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerFKCascadesLimit", wireType)
			}
			m.OptimizerFKCascadesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptimizerFKCascadesLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtTimeout", wireType)
			}
			m.StmtTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleInSessionTimeout", wireType)
			}
			m.IdleInSessionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleInSessionTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleInTransactionSessionTimeout", wireType)
			}
			m.IdleInTransactionSessionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleInTransactionSessionTimeout |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoticeDisplaySeverity", wireType)
			}
			m.NoticeDisplaySeverity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoticeDisplaySeverity |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReorderJoinsLimit", wireType)
			}
			m.ReorderJoinsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReorderJoinsLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnPriority", wireType)
			}
			m.DefaultTxnPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTxnPriority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultTxnReadOnly = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnUseFollowerReads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultTxnUseFollowerReads = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiallyDistributedPlansDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PartiallyDistributedPlansDisabled = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseHistograms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseHistograms = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseMultiColStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseMultiColStats = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityOptimizedSearch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalityOptimizedSearch = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SafeUpdates = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferLookupJoinsForFKs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferLookupJoinsForFKs = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZigzagJoinEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZigzagJoinEnabled = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireExplicitPrimaryKeys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireExplicitPrimaryKeys = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceSavepointRestart", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceSavepointRestart = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPrepareAsOptPlan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPrepareAsOptPlan = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempTablesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TempTablesEnabled = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitColumnPartitioningEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitColumnPartitioningEnabled = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideMultiRegionZoneConfigEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideMultiRegionZoneConfigEnabled = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisallowFullTableScans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisallowFullTableScans = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitSelectForUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitSelectForUpdate = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertFastPath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InsertFastPath = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterColumnTypeGeneralEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlterColumnTypeGeneralEnabled = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynchronousCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SynchronousCommit = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSeqScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSeqScan = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableUniqueWithoutIndexConstraints", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableUniqueWithoutIndexConstraints = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StubCatalogTablesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StubCatalogTablesEnabled = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalComputedColumnRewrites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExperimentalComputedColumnRewrites = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStreamReplication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStreamReplication = bool(v != 0)
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultsBufferSize", wireType)
			}
			m.ResultsBufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResultsBufferSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropagateInputOrdering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PropagateInputOrdering = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExperimentalDistSQLPlanningMode", wireType)
			}
			m.ExperimentalDistSQLPlanningMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExperimentalDistSQLPlanningMode |= ExperimentalDistSQLPlanningMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistSQLMode", wireType)
			}
			m.DistSQLMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistSQLMode |= DistSQLExecMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNormalizationMode", wireType)
			}
			m.SerialNormalizationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerialNormalizationMode |= SerialNormalizationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSchemaChangerMode", wireType)
			}
			m.NewSchemaChangerMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSchemaChangerMode |= NewSchemaChangerMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SequenceCache == nil {
				m.SequenceCache = make(SequenceCache)
			}
			var mapkey uint32
			var mapvalue *SequenceCacheEntry
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocalOnlySessionData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SequenceCacheEntry{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SequenceCache[mapkey] = mapvalue
			iNdEx = postIndex
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlacementEnabled = bool(v != 0)
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionUserProto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionUserProto = github_com_cockroachdb_cockroach_pkg_security_username.SQLUsernameProto(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsWrittenLog", wireType)
			}
			m.TxnRowsWrittenLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsWrittenLog |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsWrittenErr", wireType)
			}
			m.TxnRowsWrittenErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsWrittenErr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsReadLog", wireType)
			}
			m.TxnRowsReadLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsReadLog |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRowsReadErr", wireType)
			}
			m.TxnRowsReadErr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRowsReadErr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRehomingEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRehomingEnabled = bool(v != 0)
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuperuser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSuperuser = bool(v != 0)
		case 53:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargeFullScanRows", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LargeFullScanRows = float64(math.Float64frombits(v))
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InjectRetryErrorsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InjectRetryErrorsEnabled = bool(v != 0)
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullOrderedLast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullOrderedLast = bool(v != 0)
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePlanGists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePlanGists = bool(v != 0)
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomOptions == nil {
				m.CustomOptions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLocalOnlySessionData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLocalOnlySessionData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthLocalOnlySessionData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomOptions[mapkey] = mapvalue
			iNdEx = postIndex
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexRecommendationsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IndexRecommendationsEnabled = bool(v != 0)
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvoidBuffering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AvoidBuffering = bool(v != 0)
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFunctionBodies", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckFunctionBodies = bool(v != 0)
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostScansWithDefaultColSize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CostScansWithDefaultColSize = bool(v != 0)
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTxnQualityOfService", wireType)
			}
			m.DefaultTxnQualityOfService = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTxnQualityOfService |= QoSLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptSplitScanLimit", wireType)
			}
			m.OptSplitScanLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptSplitScanLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSuperRegions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSuperRegions = bool(v != 0)
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideAlterPrimaryRegionInSuperRegion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideAlterPrimaryRegionInSuperRegion = bool(v != 0)
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableImplicitTransactionForBatchStatements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableImplicitTransactionForBatchStatements = bool(v != 0)
		case 67:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectAndIgnoreNotVisibleColumnsInCopy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpectAndIgnoreNotVisibleColumnsInCopy = bool(v != 0)
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultipleModificationsOfTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultipleModificationsOfTable = bool(v != 0)
		case 69:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowPrimaryKeyConstraintOnNotVisibleColumns", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowPrimaryKeyConstraintOnNotVisibleColumns = bool(v != 0)
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingOptimizerRandomSeed", wireType)
			}
			m.TestingOptimizerRandomSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestingOptimizerRandomSeed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnconstrainedNonCoveringIndexScanEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnconstrainedNonCoveringIndexScanEnabled = bool(v != 0)
		case 72:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingOptimizerCostPerturbation", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestingOptimizerCostPerturbation = float64(math.Float64frombits(v))
		case 73:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingOptimizerDisableRuleProbability", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestingOptimizerDisableRuleProbability = float64(math.Float64frombits(v))
		case 74:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseNotVisibleIndexes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseNotVisibleIndexes = bool(v != 0)
		case 75:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyFastPathEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyFastPathEnabled = bool(v != 0)
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableHoistProjectionInJoinLimitation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableHoistProjectionInJoinLimitation = bool(v != 0)
		case 77:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyFromAtomicEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyFromAtomicEnabled = bool(v != 0)
		case 78:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforceHomeRegion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnforceHomeRegion = bool(v != 0)
		case 79:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseForecasts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseForecasts = bool(v != 0)
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariableInequalityLookupJoinEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VariableInequalityLookupJoinEnabled = bool(v != 0)
		case 86:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedDisjunctionStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedDisjunctionStats = bool(v != 0)
		case 88:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseLimitOrderingForStreamingGroupBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseLimitOrderingForStreamingGroupBy = bool(v != 0)
		case 89:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyFromRetriesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyFromRetriesEnabled = bool(v != 0)
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeclareCursorStatementTimeoutEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeclareCursorStatementTimeoutEnabled = bool(v != 0)
		case 91:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerUseImprovedSplitDisjunctionForJoins", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerUseImprovedSplitDisjunctionForJoins = bool(v != 0)
		case 94:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerAlwaysUseHistograms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerAlwaysUseHistograms = bool(v != 0)
		case 97:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparedStatementsCacheSize", wireType)
			}
			m.PreparedStatementsCacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparedStatementsCacheSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 98:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamerEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StreamerEnabled = bool(v != 0)
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnboundedParallelScans", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnboundedParallelScans = bool(v != 0)
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerHoistUncorrelatedEqualitySubqueries", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizerHoistUncorrelatedEqualitySubqueries = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceCacheEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLocalOnlySessionData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceCacheEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceCacheEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedVersion", wireType)
			}
			m.CachedVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentValue", wireType)
			}
			m.CurrentValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			m.Increment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Increment |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumValues", wireType)
			}
			m.NumValues = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumValues |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLocalOnlySessionData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLocalOnlySessionData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLocalOnlySessionData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLocalOnlySessionData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLocalOnlySessionData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLocalOnlySessionData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLocalOnlySessionData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLocalOnlySessionData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLocalOnlySessionData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLocalOnlySessionData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLocalOnlySessionData = fmt.Errorf("proto: unexpected end of group")
)
