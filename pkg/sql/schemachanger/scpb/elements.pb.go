// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/schemachanger/scpb/elements.proto

package scpb

import (
	fmt "fmt"
	catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	github_com_cockroachdb_cockroach_pkg_sql_sem_catid "github.com/cockroachdb/cockroach/pkg/sql/sem/catid"
	types "github.com/cockroachdb/cockroach/pkg/sql/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Index_Direction int32

const (
	Index_ASC  Index_Direction = 0
	Index_DESC Index_Direction = 1
)

var Index_Direction_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}

var Index_Direction_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x Index_Direction) String() string {
	return proto.EnumName(Index_Direction_name, int32(x))
}

func (Index_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{6, 0}
}

// ElementProto is the union type of all _elements_, which are the foundation
// of how we model schema changes in the declarative schema changer.
//
// A core design principle is that each element owns its back-references, that
// is to say, it is responsible for updating any back-references in the
// descriptors that it references as part of its lifecycle, i.e. going from
// ABSENT to PUBLIC or vice-versa. As a corollary, back-references are not
// modelled as elements at all, they exist purely as a side-effect. In an ideal
// world, they would be modelled as elements just like everything else, however
// we currently don't have 1:1 relationships between forward and back-references
// in all cases: we do for foreign keys for example, but we don't for type
// references (back-references are modelled as a set in the type descriptor).
//
// Regardless, this principle does have the inherent virtue of keeping the
// element model relatively simple, if at the expense of pushing the complexity
// down to the execution layer in scmutationexec. This trade-off is acceptable
// though: the back-reference update code is quite self-contained and the
// added complexity consists in making these operations work on a best-effort
// basis, i.e. with not many assumptions about whether something is dropped or
// not, etc.
//
// A less strong principle is that each element should remain immutable
// throughout its lifecycle. In practice we sometimes deviate from this for
// elements which have only just had targets defined for them and thus haven't
// yet undergone any status changes. In any case, that kind of hackery is best
// kept at a minimum.
type ElementProto struct {
	// Top-level elements.
	// A.k.a descriptor-elements.
	// These elements own a corresponding descriptor in the catalog.
	Database  *Database  `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Schema    *Schema    `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	View      *View      `protobuf:"bytes,3,opt,name=view,proto3" json:"view,omitempty"`
	Sequence  *Sequence  `protobuf:"bytes,4,opt,name=sequence,proto3" json:"sequence,omitempty"`
	Table     *Table     `protobuf:"bytes,5,opt,name=table,proto3" json:"table,omitempty"`
	EnumType  *EnumType  `protobuf:"bytes,6,opt,name=enum_type,json=enumType,proto3" json:"enum_type,omitempty"`
	AliasType *AliasType `protobuf:"bytes,7,opt,name=alias_type,json=aliasType,proto3" json:"alias_type,omitempty"`
	// Relation elements.
	ColumnFamily                 *ColumnFamily                 `protobuf:"bytes,20,opt,name=column_family,json=columnFamily,proto3" json:"column_family,omitempty" parent:"Table"`
	Column                       *Column                       `protobuf:"bytes,21,opt,name=column,proto3" json:"column,omitempty" parent:"Table, View"`
	PrimaryIndex                 *PrimaryIndex                 `protobuf:"bytes,22,opt,name=primary_index,json=primaryIndex,proto3" json:"primary_index,omitempty" parent:"Table, View"`
	SecondaryIndex               *SecondaryIndex               `protobuf:"bytes,23,opt,name=secondary_index,json=secondaryIndex,proto3" json:"secondary_index,omitempty" parent:"Table, View"`
	TemporaryIndex               *TemporaryIndex               `protobuf:"bytes,24,opt,name=temporary_index,json=temporaryIndex,proto3" json:"temporary_index,omitempty" parent:"Table, View"`
	UniqueWithoutIndexConstraint *UniqueWithoutIndexConstraint `protobuf:"bytes,25,opt,name=unique_without_index_constraint,json=uniqueWithoutIndexConstraint,proto3" json:"unique_without_index_constraint,omitempty" parent:"Table"`
	CheckConstraint              *CheckConstraint              `protobuf:"bytes,26,opt,name=check_constraint,json=checkConstraint,proto3" json:"check_constraint,omitempty" parent:"Table"`
	ForeignKeyConstraint         *ForeignKeyConstraint         `protobuf:"bytes,27,opt,name=foreign_key_constraint,json=foreignKeyConstraint,proto3" json:"foreign_key_constraint,omitempty" parent:"Table"`
	TableComment                 *TableComment                 `protobuf:"bytes,28,opt,name=table_comment,json=tableComment,proto3" json:"table_comment,omitempty" parent:"Table, View, Sequence"`
	RowLevelTTL                  *RowLevelTTL                  `protobuf:"bytes,29,opt,name=row_level_ttl,json=rowLevelTtl,proto3" json:"row_level_ttl,omitempty" parent:"Table"`
	// Multi-region elements.
	LocalityGlobal          *TableLocalityGlobal          `protobuf:"bytes,110,opt,name=locality_global,json=localityGlobal,proto3" json:"locality_global,omitempty" parent:"Table"`
	LocalityPrimaryRegion   *TableLocalityPrimaryRegion   `protobuf:"bytes,111,opt,name=locality_primary_region,json=localityPrimaryRegion,proto3" json:"locality_primary_region,omitempty" parent:"Table"`
	LocalitySecondaryRegion *TableLocalitySecondaryRegion `protobuf:"bytes,112,opt,name=locality_secondary_region,json=localitySecondaryRegion,proto3" json:"locality_secondary_region,omitempty" parent:"Table"`
	LocalityRegionalByRow   *TableLocalityRegionalByRow   `protobuf:"bytes,113,opt,name=locality_regional_by_row,json=localityRegionalByRow,proto3" json:"locality_regional_by_row,omitempty" parent:"Table"`
	// Column elements.
	ColumnName               *ColumnName               `protobuf:"bytes,30,opt,name=column_name,json=columnName,proto3" json:"column_name,omitempty" parent:"Column"`
	ColumnType               *ColumnType               `protobuf:"bytes,31,opt,name=column_type,json=columnType,proto3" json:"column_type,omitempty" parent:"Column"`
	ColumnDefaultExpression  *ColumnDefaultExpression  `protobuf:"bytes,32,opt,name=column_default_expression,json=columnDefaultExpression,proto3" json:"column_default_expression,omitempty" parent:"Column"`
	ColumnOnUpdateExpression *ColumnOnUpdateExpression `protobuf:"bytes,33,opt,name=column_on_update_expression,json=columnOnUpdateExpression,proto3" json:"column_on_update_expression,omitempty" parent:"Column"`
	SequenceOwner            *SequenceOwner            `protobuf:"bytes,34,opt,name=sequence_owner,json=sequenceOwner,proto3" json:"sequence_owner,omitempty" parent:"Column"`
	ColumnComment            *ColumnComment            `protobuf:"bytes,35,opt,name=column_comment,json=columnComment,proto3" json:"column_comment,omitempty" parent:"Column"`
	// Index elements.
	IndexName             *IndexName             `protobuf:"bytes,40,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
	IndexPartitioning     *IndexPartitioning     `protobuf:"bytes,41,opt,name=index_partitioning,json=indexPartitioning,proto3" json:"index_partitioning,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
	SecondaryIndexPartial *SecondaryIndexPartial `protobuf:"bytes,42,opt,name=secondary_index_partial,json=secondaryIndexPartial,proto3" json:"secondary_index_partial,omitempty" parent:"SecondaryIndex"`
	IndexComment          *IndexComment          `protobuf:"bytes,43,opt,name=index_comment,json=indexComment,proto3" json:"index_comment,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
	// Constraint elements.
	ConstraintName    *ConstraintName    `protobuf:"bytes,51,opt,name=constraint_name,json=constraintName,proto3" json:"constraint_name,omitempty" parent:"UniqueWithoutIndexConstraint, CheckConstraint, ForeignKeyConstraint"`
	ConstraintComment *ConstraintComment `protobuf:"bytes,52,opt,name=constraint_comment,json=constraintComment,proto3" json:"constraint_comment,omitempty" parent:"PrimaryIndex, SecondaryIndex, UniqueWithoutIndexConstraint, CheckConstraint, ForeignKeyConstraint"`
	// Common elements.
	Namespace      *Namespace      `protobuf:"bytes,60,opt,name=namespace,proto3" json:"namespace,omitempty" parent:"Table, View, Sequence, Database, Schema, AliasType, EnumType"`
	Owner          *Owner          `protobuf:"bytes,61,opt,name=owner,proto3" json:"owner,omitempty" parent:"Table, View, Sequence, Database, Schema, AliasType, EnumType"`
	UserPrivileges *UserPrivileges `protobuf:"bytes,62,opt,name=user_privileges,json=userPrivileges,proto3" json:"user_privileges,omitempty" parent:"Table, View, Sequence, Database, Schema, AliasType, EnumType"`
	// Database elements.
	DatabaseRegionConfig *DatabaseRegionConfig `protobuf:"bytes,80,opt,name=database_region_config,json=databaseRegionConfig,proto3" json:"database_region_config,omitempty" parent:"Database"`
	DatabaseRoleSetting  *DatabaseRoleSetting  `protobuf:"bytes,81,opt,name=database_role_setting,json=databaseRoleSetting,proto3" json:"database_role_setting,omitempty" parent:"Database"`
	DatabaseComment      *DatabaseComment      `protobuf:"bytes,82,opt,name=database_comment,json=databaseComment,proto3" json:"database_comment,omitempty" parent:"Database"`
	// Schema elements.
	SchemaParent  *SchemaParent  `protobuf:"bytes,90,opt,name=schema_parent,json=schemaParent,proto3" json:"schema_parent,omitempty" parent:"Schema"`
	SchemaComment *SchemaComment `protobuf:"bytes,91,opt,name=schema_comment,json=schemaComment,proto3" json:"schema_comment,omitempty" parent:"Schema"`
	// Object elements.
	ObjectParent *ObjectParent `protobuf:"bytes,100,opt,name=object_parent,json=objectParent,proto3" json:"object_parent,omitempty" parent:"AliasType, EnumType, Table, View, Sequence"`
}

func (m *ElementProto) Reset()         { *m = ElementProto{} }
func (m *ElementProto) String() string { return proto.CompactTextString(m) }
func (*ElementProto) ProtoMessage()    {}
func (*ElementProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{0}
}
func (m *ElementProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElementProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ElementProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElementProto.Merge(m, src)
}
func (m *ElementProto) XXX_Size() int {
	return m.Size()
}
func (m *ElementProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ElementProto.DiscardUnknown(m)
}

var xxx_messageInfo_ElementProto proto.InternalMessageInfo

// TypeT is a wrapper for a types.T which contains its user-defined type ID
// closure, explicitly keeping track of the IDs of all the type descriptors
// which will have a back-reference to the owner of the TypeT.
// For example, a wrapped type.Int will have an empty type ID closure, but
// a wrapped user-defined enum type will have the IDs of the enum type and
// its array alias type in the closure.
type TypeT struct {
	Type          *types.T                                                    `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	ClosedTypeIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,rep,packed,name=closed_type_ids,json=closedTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"closed_type_ids,omitempty"`
}

func (m *TypeT) Reset()         { *m = TypeT{} }
func (m *TypeT) String() string { return proto.CompactTextString(m) }
func (*TypeT) ProtoMessage()    {}
func (*TypeT) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{1}
}
func (m *TypeT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TypeT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeT.Merge(m, src)
}
func (m *TypeT) XXX_Size() int {
	return m.Size()
}
func (m *TypeT) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeT.DiscardUnknown(m)
}

var xxx_messageInfo_TypeT proto.InternalMessageInfo

// Expression is a wrapper for a column or check constraint expression, which,
// much like the TypeT wrapper, tracks its dependent descriptor IDs. Here these
// include also sequence descriptor IDs.
type Expression struct {
	Expr            github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.Expression `protobuf:"bytes,1,opt,name=expr,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.Expression" json:"expr,omitempty"`
	UsesTypeIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,2,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesSequenceIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,3,rep,packed,name=uses_sequence_ids,json=usesSequenceIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_sequence_ids,omitempty"`
}

func (m *Expression) Reset()         { *m = Expression{} }
func (m *Expression) String() string { return proto.CompactTextString(m) }
func (*Expression) ProtoMessage()    {}
func (*Expression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{2}
}
func (m *Expression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Expression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression.Merge(m, src)
}
func (m *Expression) XXX_Size() int {
	return m.Size()
}
func (m *Expression) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression.DiscardUnknown(m)
}

var xxx_messageInfo_Expression proto.InternalMessageInfo

type Column struct {
	TableID                           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID                      `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID                          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID                    `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	IsHidden                          bool                                                                           `protobuf:"varint,3,opt,name=is_hidden,json=isHidden,proto3" json:"is_hidden,omitempty"`
	IsInaccessible                    bool                                                                           `protobuf:"varint,4,opt,name=is_inaccessible,json=isInaccessible,proto3" json:"is_inaccessible,omitempty"`
	GeneratedAsIdentityType           github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.GeneratedAsIdentityType `protobuf:"varint,5,opt,name=generated_as_identity_type,json=generatedAsIdentityType,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.GeneratedAsIdentityType" json:"generated_as_identity_type,omitempty"`
	GeneratedAsIdentitySequenceOption string                                                                         `protobuf:"bytes,6,opt,name=generated_as_identity_sequence_option,json=generatedAsIdentitySequenceOption,proto3" json:"generated_as_identity_sequence_option,omitempty"`
	PgAttributeNum                    uint32                                                                         `protobuf:"varint,7,opt,name=pg_attribute_num,json=pgAttributeNum,proto3" json:"pg_attribute_num,omitempty"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{3}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

// ColumnType needs to be an element distinct from Column although they have a
// 1:1 relationship because their lifecycle is not the same.
// Column transitions through the two-version-invariant status path:
//   PUBLIC -> WRITE_ONLY -> DELETE_ONLY -> ABSENT
// regardless of whether only the column is dropped (meaning ABSENT is reached
// post-commit) or whether the whole table is dropped. We accommodate the
// latter case by having ColumnType reach ABSENT in the pre-commit phase
// independently of its sister column element. This is important, because this
// clears back-references in referenced type descriptors for columns which
// have user-defined types, or reference user-defined types in their compute
// expression.
type ColumnType struct {
	TableID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	FamilyID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID `protobuf:"varint,2,opt,name=family_id,json=familyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.FamilyID" json:"family_id,omitempty"`
	ColumnID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	TypeT       `protobuf:"bytes,4,opt,name=embedded_type_t,json=embeddedTypeT,proto3,embedded=embedded_type_t" json:"embedded_type_t"`
	IsNullable  bool        `protobuf:"varint,5,opt,name=is_nullable,json=isNullable,proto3" json:"is_nullable,omitempty"`
	ComputeExpr *Expression `protobuf:"bytes,6,opt,name=compute_expr,json=computeExpr,proto3" json:"compute_expr,omitempty"`
	IsVirtual   bool        `protobuf:"varint,7,opt,name=is_virtual,json=isVirtual,proto3" json:"is_virtual,omitempty"`
	// Spec fields.
	// These fields only make sense if the element is for PUBLIC -> ABSENT.
	//
	// TODO(postamar): remove this when we can have more expressive rule defs
	//  See the dep rules for how this is used, and why it's not ideal.
	IsRelationBeingDropped bool `protobuf:"varint,10,opt,name=is_relation_being_dropped,json=isRelationBeingDropped,proto3" json:"is_relation_being_dropped,omitempty"`
}

func (m *ColumnType) Reset()         { *m = ColumnType{} }
func (m *ColumnType) String() string { return proto.CompactTextString(m) }
func (*ColumnType) ProtoMessage()    {}
func (*ColumnType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{4}
}
func (m *ColumnType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnType.Merge(m, src)
}
func (m *ColumnType) XXX_Size() int {
	return m.Size()
}
func (m *ColumnType) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnType.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnType proto.InternalMessageInfo

type ColumnFamily struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	FamilyID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID `protobuf:"varint,2,opt,name=family_id,json=familyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.FamilyID" json:"family_id,omitempty"`
	Name     string                                                      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ColumnFamily) Reset()         { *m = ColumnFamily{} }
func (m *ColumnFamily) String() string { return proto.CompactTextString(m) }
func (*ColumnFamily) ProtoMessage()    {}
func (*ColumnFamily) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{5}
}
func (m *ColumnFamily) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnFamily) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnFamily) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnFamily.Merge(m, src)
}
func (m *ColumnFamily) XXX_Size() int {
	return m.Size()
}
func (m *ColumnFamily) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnFamily.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnFamily proto.InternalMessageInfo

// Index is a wrapper for index definition data that gets embedded in both
// PrimaryIndex and SecondaryIndex. These two are not so different, but need
// to be distinguished by type (instead of, say, via a boolean flag in the
// element) to make for sane dependency rules.
type Index struct {
	TableID             github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID             github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID    `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	KeyColumnIDs        []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,rep,packed,name=key_column_ids,json=keyColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"key_column_ids,omitempty"`
	KeyColumnDirections []Index_Direction                                             `protobuf:"varint,4,rep,packed,name=key_column_directions,json=keyColumnDirections,proto3,enum=cockroach.sql.schemachanger.scpb.Index_Direction" json:"key_column_directions,omitempty"`
	KeySuffixColumnIDs  []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,5,rep,packed,name=key_suffix_column_ids,json=keySuffixColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"key_suffix_column_ids,omitempty"`
	StoringColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,6,rep,packed,name=storing_column_ids,json=storingColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"storing_column_ids,omitempty"`
	CompositeColumnIDs  []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,7,rep,packed,name=composite_column_ids,json=compositeColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"composite_column_ids,omitempty"`
	IsUnique            bool                                                          `protobuf:"varint,10,opt,name=is_unique,json=isUnique,proto3" json:"is_unique,omitempty"`
	IsInverted          bool                                                          `protobuf:"varint,11,opt,name=is_inverted,json=isInverted,proto3" json:"is_inverted,omitempty"`
	Sharding            *catpb.ShardedDescriptor                                      `protobuf:"bytes,12,opt,name=sharding,proto3" json:"sharding,omitempty"`
	// Spec fields.
	// These fields only make sense if the element is for ABSENT -> PUBLIC.
	//
	// TODO(postamar): try to get rid of these altogether
	//  Perhaps move these to the target metadata instead?
	IsConcurrently   bool                                                       `protobuf:"varint,20,opt,name=is_concurrently,json=isConcurrently,proto3" json:"is_concurrently,omitempty"`
	SourceIndexID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,21,opt,name=source_index_id,json=sourceIndexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"source_index_id,omitempty"`
	TemporaryIndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,22,opt,name=temporary_index_id,json=temporaryIndexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"temporary_index_id,omitempty"`
}

func (m *Index) Reset()         { *m = Index{} }
func (m *Index) String() string { return proto.CompactTextString(m) }
func (*Index) ProtoMessage()    {}
func (*Index) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{6}
}
func (m *Index) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Index) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Index) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Index.Merge(m, src)
}
func (m *Index) XXX_Size() int {
	return m.Size()
}
func (m *Index) XXX_DiscardUnknown() {
	xxx_messageInfo_Index.DiscardUnknown(m)
}

var xxx_messageInfo_Index proto.InternalMessageInfo

type PrimaryIndex struct {
	Index `protobuf:"bytes,1,opt,name=embedded_index,json=embeddedIndex,proto3,embedded=embedded_index" json:"embedded_index"`
}

func (m *PrimaryIndex) Reset()         { *m = PrimaryIndex{} }
func (m *PrimaryIndex) String() string { return proto.CompactTextString(m) }
func (*PrimaryIndex) ProtoMessage()    {}
func (*PrimaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{7}
}
func (m *PrimaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PrimaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryIndex.Merge(m, src)
}
func (m *PrimaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *PrimaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryIndex proto.InternalMessageInfo

type SecondaryIndex struct {
	Index `protobuf:"bytes,1,opt,name=embedded_index,json=embeddedIndex,proto3,embedded=embedded_index" json:"embedded_index"`
}

func (m *SecondaryIndex) Reset()         { *m = SecondaryIndex{} }
func (m *SecondaryIndex) String() string { return proto.CompactTextString(m) }
func (*SecondaryIndex) ProtoMessage()    {}
func (*SecondaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{8}
}
func (m *SecondaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecondaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondaryIndex.Merge(m, src)
}
func (m *SecondaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *SecondaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_SecondaryIndex proto.InternalMessageInfo

type TemporaryIndex struct {
	Index                    `protobuf:"bytes,1,opt,name=embedded_index,json=embeddedIndex,proto3,embedded=embedded_index" json:"embedded_index"`
	IsUsingSecondaryEncoding bool `protobuf:"varint,2,opt,name=is_using_secondary_encoding,json=isUsingSecondaryEncoding,proto3" json:"is_using_secondary_encoding,omitempty"`
}

func (m *TemporaryIndex) Reset()         { *m = TemporaryIndex{} }
func (m *TemporaryIndex) String() string { return proto.CompactTextString(m) }
func (*TemporaryIndex) ProtoMessage()    {}
func (*TemporaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{9}
}
func (m *TemporaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TemporaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TemporaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemporaryIndex.Merge(m, src)
}
func (m *TemporaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *TemporaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_TemporaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_TemporaryIndex proto.InternalMessageInfo

type SecondaryIndexPartial struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
	// Spec fields.
	// These fields only make sense if the element is for PUBLIC -> ABSENT.
	//
	// TODO(postamar): remove this when we can have more expressive rule defs
	//  See the dep rules for how this is used, and why it's not ideal.
	IsRelationBeingDropped bool `protobuf:"varint,10,opt,name=is_relation_being_dropped,json=isRelationBeingDropped,proto3" json:"is_relation_being_dropped,omitempty"`
}

func (m *SecondaryIndexPartial) Reset()         { *m = SecondaryIndexPartial{} }
func (m *SecondaryIndexPartial) String() string { return proto.CompactTextString(m) }
func (*SecondaryIndexPartial) ProtoMessage()    {}
func (*SecondaryIndexPartial) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{10}
}
func (m *SecondaryIndexPartial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondaryIndexPartial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecondaryIndexPartial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondaryIndexPartial.Merge(m, src)
}
func (m *SecondaryIndexPartial) XXX_Size() int {
	return m.Size()
}
func (m *SecondaryIndexPartial) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondaryIndexPartial.DiscardUnknown(m)
}

var xxx_messageInfo_SecondaryIndexPartial proto.InternalMessageInfo

// SchemaParent models the schema to parent database relationship.
// Every schema has a parent, so there is a 1:1 relationship between
// the Schema and the SchemaParent relationship. This is modeled as a separate
// element because this one owns the updating of the corresponding
// back-reference in the parent database descriptor as part of its lifecycle.
type SchemaParent struct {
	SchemaID         github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	ParentDatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=parent_database_id,json=parentDatabaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"parent_database_id,omitempty"`
}

func (m *SchemaParent) Reset()         { *m = SchemaParent{} }
func (m *SchemaParent) String() string { return proto.CompactTextString(m) }
func (*SchemaParent) ProtoMessage()    {}
func (*SchemaParent) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{11}
}
func (m *SchemaParent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaParent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaParent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaParent.Merge(m, src)
}
func (m *SchemaParent) XXX_Size() int {
	return m.Size()
}
func (m *SchemaParent) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaParent.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaParent proto.InternalMessageInfo

// ObjectParent is like SchemaParent but for objects.
// This is a bit useless since schemas don't maintain a set of back-references
// to their children. Still, it exists as a convenient join relation.
type ObjectParent struct {
	ObjectID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=object_id,json=objectId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"object_id,omitempty"`
	ParentSchemaID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=parent_schema_id,json=parentSchemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"parent_schema_id,omitempty"`
}

func (m *ObjectParent) Reset()         { *m = ObjectParent{} }
func (m *ObjectParent) String() string { return proto.CompactTextString(m) }
func (*ObjectParent) ProtoMessage()    {}
func (*ObjectParent) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{12}
}
func (m *ObjectParent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectParent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectParent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectParent.Merge(m, src)
}
func (m *ObjectParent) XXX_Size() int {
	return m.Size()
}
func (m *ObjectParent) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectParent.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectParent proto.InternalMessageInfo

type Sequence struct {
	SequenceID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	IsTemporary bool                                                      `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
}

func (m *Sequence) Reset()         { *m = Sequence{} }
func (m *Sequence) String() string { return proto.CompactTextString(m) }
func (*Sequence) ProtoMessage()    {}
func (*Sequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{13}
}
func (m *Sequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Sequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sequence.Merge(m, src)
}
func (m *Sequence) XXX_Size() int {
	return m.Size()
}
func (m *Sequence) XXX_DiscardUnknown() {
	xxx_messageInfo_Sequence.DiscardUnknown(m)
}

var xxx_messageInfo_Sequence proto.InternalMessageInfo

type SequenceOwner struct {
	SequenceID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
}

func (m *SequenceOwner) Reset()         { *m = SequenceOwner{} }
func (m *SequenceOwner) String() string { return proto.CompactTextString(m) }
func (*SequenceOwner) ProtoMessage()    {}
func (*SequenceOwner) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{14}
}
func (m *SequenceOwner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceOwner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceOwner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceOwner.Merge(m, src)
}
func (m *SequenceOwner) XXX_Size() int {
	return m.Size()
}
func (m *SequenceOwner) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceOwner.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceOwner proto.InternalMessageInfo

type ColumnDefaultExpression struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *ColumnDefaultExpression) Reset()         { *m = ColumnDefaultExpression{} }
func (m *ColumnDefaultExpression) String() string { return proto.CompactTextString(m) }
func (*ColumnDefaultExpression) ProtoMessage()    {}
func (*ColumnDefaultExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{15}
}
func (m *ColumnDefaultExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnDefaultExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnDefaultExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnDefaultExpression.Merge(m, src)
}
func (m *ColumnDefaultExpression) XXX_Size() int {
	return m.Size()
}
func (m *ColumnDefaultExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnDefaultExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnDefaultExpression proto.InternalMessageInfo

type ColumnOnUpdateExpression struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *ColumnOnUpdateExpression) Reset()         { *m = ColumnOnUpdateExpression{} }
func (m *ColumnOnUpdateExpression) String() string { return proto.CompactTextString(m) }
func (*ColumnOnUpdateExpression) ProtoMessage()    {}
func (*ColumnOnUpdateExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{16}
}
func (m *ColumnOnUpdateExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnOnUpdateExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnOnUpdateExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnOnUpdateExpression.Merge(m, src)
}
func (m *ColumnOnUpdateExpression) XXX_Size() int {
	return m.Size()
}
func (m *ColumnOnUpdateExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnOnUpdateExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnOnUpdateExpression proto.InternalMessageInfo

type View struct {
	ViewID          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=view_id,json=viewId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"view_id,omitempty"`
	UsesTypeIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesRelationIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,rep,packed,name=uses_relation_ids,json=usesRelationIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_relation_ids,omitempty"`
	IsTemporary     bool                                                        `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
	IsMaterialized  bool                                                        `protobuf:"varint,11,opt,name=is_materialized,json=isMaterialized,proto3" json:"is_materialized,omitempty"`
}

func (m *View) Reset()         { *m = View{} }
func (m *View) String() string { return proto.CompactTextString(m) }
func (*View) ProtoMessage()    {}
func (*View) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{17}
}
func (m *View) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *View) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *View) XXX_Merge(src proto.Message) {
	xxx_messageInfo_View.Merge(m, src)
}
func (m *View) XXX_Size() int {
	return m.Size()
}
func (m *View) XXX_DiscardUnknown() {
	xxx_messageInfo_View.DiscardUnknown(m)
}

var xxx_messageInfo_View proto.InternalMessageInfo

type Table struct {
	TableID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IsTemporary bool                                                      `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
}

func (m *Table) Reset()         { *m = Table{} }
func (m *Table) String() string { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()    {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{18}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

type UniqueWithoutIndexConstraint struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
}

func (m *UniqueWithoutIndexConstraint) Reset()         { *m = UniqueWithoutIndexConstraint{} }
func (m *UniqueWithoutIndexConstraint) String() string { return proto.CompactTextString(m) }
func (*UniqueWithoutIndexConstraint) ProtoMessage()    {}
func (*UniqueWithoutIndexConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{19}
}
func (m *UniqueWithoutIndexConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniqueWithoutIndexConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UniqueWithoutIndexConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniqueWithoutIndexConstraint.Merge(m, src)
}
func (m *UniqueWithoutIndexConstraint) XXX_Size() int {
	return m.Size()
}
func (m *UniqueWithoutIndexConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_UniqueWithoutIndexConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_UniqueWithoutIndexConstraint proto.InternalMessageInfo

type CheckConstraint struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	Expression   `protobuf:"bytes,4,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *CheckConstraint) Reset()         { *m = CheckConstraint{} }
func (m *CheckConstraint) String() string { return proto.CompactTextString(m) }
func (*CheckConstraint) ProtoMessage()    {}
func (*CheckConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{20}
}
func (m *CheckConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConstraint.Merge(m, src)
}
func (m *CheckConstraint) XXX_Size() int {
	return m.Size()
}
func (m *CheckConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConstraint proto.InternalMessageInfo

type ForeignKeyConstraint struct {
	TableID             github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs           []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	ReferencedTableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,4,opt,name=referenced_table_id,json=referencedTableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"referenced_table_id,omitempty"`
	ReferencedColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,5,rep,packed,name=referenced_column_ids,json=referencedColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"referenced_column_ids,omitempty"`
}

func (m *ForeignKeyConstraint) Reset()         { *m = ForeignKeyConstraint{} }
func (m *ForeignKeyConstraint) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyConstraint) ProtoMessage()    {}
func (*ForeignKeyConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{21}
}
func (m *ForeignKeyConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForeignKeyConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyConstraint.Merge(m, src)
}
func (m *ForeignKeyConstraint) XXX_Size() int {
	return m.Size()
}
func (m *ForeignKeyConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyConstraint proto.InternalMessageInfo

type EnumType struct {
	TypeID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	ArrayTypeID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=array_type_id,json=arrayTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"array_type_id,omitempty"`
	IsMultiRegion bool                                                      `protobuf:"varint,3,opt,name=is_multi_region,json=isMultiRegion,proto3" json:"is_multi_region,omitempty"`
}

func (m *EnumType) Reset()         { *m = EnumType{} }
func (m *EnumType) String() string { return proto.CompactTextString(m) }
func (*EnumType) ProtoMessage()    {}
func (*EnumType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{22}
}
func (m *EnumType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnumType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnumType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnumType.Merge(m, src)
}
func (m *EnumType) XXX_Size() int {
	return m.Size()
}
func (m *EnumType) XXX_DiscardUnknown() {
	xxx_messageInfo_EnumType.DiscardUnknown(m)
}

var xxx_messageInfo_EnumType proto.InternalMessageInfo

type AliasType struct {
	TypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	TypeT  `protobuf:"bytes,2,opt,name=embedded_type_t,json=embeddedTypeT,proto3,embedded=embedded_type_t" json:"embedded_type_t"`
}

func (m *AliasType) Reset()         { *m = AliasType{} }
func (m *AliasType) String() string { return proto.CompactTextString(m) }
func (*AliasType) ProtoMessage()    {}
func (*AliasType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{23}
}
func (m *AliasType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AliasType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AliasType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AliasType.Merge(m, src)
}
func (m *AliasType) XXX_Size() int {
	return m.Size()
}
func (m *AliasType) XXX_DiscardUnknown() {
	xxx_messageInfo_AliasType.DiscardUnknown(m)
}

var xxx_messageInfo_AliasType proto.InternalMessageInfo

type Schema struct {
	SchemaID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	IsTemporary bool                                                      `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
	IsPublic    bool                                                      `protobuf:"varint,11,opt,name=is_public,json=isPublic,proto3" json:"is_public,omitempty"`
	IsVirtual   bool                                                      `protobuf:"varint,12,opt,name=is_virtual,json=isVirtual,proto3" json:"is_virtual,omitempty"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{24}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

type Database struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
}

func (m *Database) Reset()         { *m = Database{} }
func (m *Database) String() string { return proto.CompactTextString(m) }
func (*Database) ProtoMessage()    {}
func (*Database) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{25}
}
func (m *Database) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Database) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Database) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Database.Merge(m, src)
}
func (m *Database) XXX_Size() int {
	return m.Size()
}
func (m *Database) XXX_DiscardUnknown() {
	xxx_messageInfo_Database.DiscardUnknown(m)
}

var xxx_messageInfo_Database proto.InternalMessageInfo

type Namespace struct {
	DatabaseID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	SchemaID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Name         string                                                    `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Namespace) Reset()         { *m = Namespace{} }
func (m *Namespace) String() string { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()    {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{26}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

type Owner struct {
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Owner        string                                                    `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *Owner) Reset()         { *m = Owner{} }
func (m *Owner) String() string { return proto.CompactTextString(m) }
func (*Owner) ProtoMessage()    {}
func (*Owner) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{27}
}
func (m *Owner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Owner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Owner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Owner.Merge(m, src)
}
func (m *Owner) XXX_Size() int {
	return m.Size()
}
func (m *Owner) XXX_DiscardUnknown() {
	xxx_messageInfo_Owner.DiscardUnknown(m)
}

var xxx_messageInfo_Owner proto.InternalMessageInfo

type UserPrivileges struct {
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	UserName     string                                                    `protobuf:"bytes,2,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	Privileges   uint32                                                    `protobuf:"varint,3,opt,name=privileges,proto3" json:"privileges,omitempty"`
}

func (m *UserPrivileges) Reset()         { *m = UserPrivileges{} }
func (m *UserPrivileges) String() string { return proto.CompactTextString(m) }
func (*UserPrivileges) ProtoMessage()    {}
func (*UserPrivileges) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{28}
}
func (m *UserPrivileges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPrivileges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserPrivileges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPrivileges.Merge(m, src)
}
func (m *UserPrivileges) XXX_Size() int {
	return m.Size()
}
func (m *UserPrivileges) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPrivileges.DiscardUnknown(m)
}

var xxx_messageInfo_UserPrivileges proto.InternalMessageInfo

type TableLocalityGlobal struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TableLocalityGlobal) Reset()         { *m = TableLocalityGlobal{} }
func (m *TableLocalityGlobal) String() string { return proto.CompactTextString(m) }
func (*TableLocalityGlobal) ProtoMessage()    {}
func (*TableLocalityGlobal) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{29}
}
func (m *TableLocalityGlobal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityGlobal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityGlobal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityGlobal.Merge(m, src)
}
func (m *TableLocalityGlobal) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityGlobal) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityGlobal.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityGlobal proto.InternalMessageInfo

type TableLocalityPrimaryRegion struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TableLocalityPrimaryRegion) Reset()         { *m = TableLocalityPrimaryRegion{} }
func (m *TableLocalityPrimaryRegion) String() string { return proto.CompactTextString(m) }
func (*TableLocalityPrimaryRegion) ProtoMessage()    {}
func (*TableLocalityPrimaryRegion) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{30}
}
func (m *TableLocalityPrimaryRegion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityPrimaryRegion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityPrimaryRegion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityPrimaryRegion.Merge(m, src)
}
func (m *TableLocalityPrimaryRegion) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityPrimaryRegion) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityPrimaryRegion.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityPrimaryRegion proto.InternalMessageInfo

type TableLocalitySecondaryRegion struct {
	TableID          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	RegionEnumTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID         `protobuf:"varint,2,opt,name=region_enum_type_id,json=regionEnumTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"region_enum_type_id,omitempty"`
	RegionName       github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName `protobuf:"bytes,3,opt,name=region_name,json=regionName,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.RegionName" json:"region_name,omitempty"`
}

func (m *TableLocalitySecondaryRegion) Reset()         { *m = TableLocalitySecondaryRegion{} }
func (m *TableLocalitySecondaryRegion) String() string { return proto.CompactTextString(m) }
func (*TableLocalitySecondaryRegion) ProtoMessage()    {}
func (*TableLocalitySecondaryRegion) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{31}
}
func (m *TableLocalitySecondaryRegion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalitySecondaryRegion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalitySecondaryRegion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalitySecondaryRegion.Merge(m, src)
}
func (m *TableLocalitySecondaryRegion) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalitySecondaryRegion) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalitySecondaryRegion.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalitySecondaryRegion proto.InternalMessageInfo

type TableLocalityRegionalByRow struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	As      string                                                    `protobuf:"bytes,2,opt,name=as,proto3" json:"as,omitempty"`
}

func (m *TableLocalityRegionalByRow) Reset()         { *m = TableLocalityRegionalByRow{} }
func (m *TableLocalityRegionalByRow) String() string { return proto.CompactTextString(m) }
func (*TableLocalityRegionalByRow) ProtoMessage()    {}
func (*TableLocalityRegionalByRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{32}
}
func (m *TableLocalityRegionalByRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityRegionalByRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityRegionalByRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityRegionalByRow.Merge(m, src)
}
func (m *TableLocalityRegionalByRow) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityRegionalByRow) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityRegionalByRow.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityRegionalByRow proto.InternalMessageInfo

type IndexPartitioning struct {
	TableID                      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID                      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	catpb.PartitioningDescriptor `protobuf:"bytes,3,opt,name=partitioning,proto3,embedded=partitioning" json:"partitioning"`
}

func (m *IndexPartitioning) Reset()         { *m = IndexPartitioning{} }
func (m *IndexPartitioning) String() string { return proto.CompactTextString(m) }
func (*IndexPartitioning) ProtoMessage()    {}
func (*IndexPartitioning) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{33}
}
func (m *IndexPartitioning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexPartitioning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexPartitioning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexPartitioning.Merge(m, src)
}
func (m *IndexPartitioning) XXX_Size() int {
	return m.Size()
}
func (m *IndexPartitioning) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexPartitioning.DiscardUnknown(m)
}

var xxx_messageInfo_IndexPartitioning proto.InternalMessageInfo

type RowLevelTTL struct {
	TableID           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	catpb.RowLevelTTL `protobuf:"bytes,2,opt,name=row_level_ttl,json=rowLevelTtl,proto3,embedded=row_level_ttl" json:"row_level_ttl"`
}

func (m *RowLevelTTL) Reset()         { *m = RowLevelTTL{} }
func (m *RowLevelTTL) String() string { return proto.CompactTextString(m) }
func (*RowLevelTTL) ProtoMessage()    {}
func (*RowLevelTTL) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{34}
}
func (m *RowLevelTTL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowLevelTTL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RowLevelTTL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowLevelTTL.Merge(m, src)
}
func (m *RowLevelTTL) XXX_Size() int {
	return m.Size()
}
func (m *RowLevelTTL) XXX_DiscardUnknown() {
	xxx_messageInfo_RowLevelTTL.DiscardUnknown(m)
}

var xxx_messageInfo_RowLevelTTL proto.InternalMessageInfo

type ColumnName struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Name     string                                                      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ColumnName) Reset()         { *m = ColumnName{} }
func (m *ColumnName) String() string { return proto.CompactTextString(m) }
func (*ColumnName) ProtoMessage()    {}
func (*ColumnName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{35}
}
func (m *ColumnName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnName.Merge(m, src)
}
func (m *ColumnName) XXX_Size() int {
	return m.Size()
}
func (m *ColumnName) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnName.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnName proto.InternalMessageInfo

type IndexName struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Name    string                                                     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *IndexName) Reset()         { *m = IndexName{} }
func (m *IndexName) String() string { return proto.CompactTextString(m) }
func (*IndexName) ProtoMessage()    {}
func (*IndexName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{36}
}
func (m *IndexName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexName.Merge(m, src)
}
func (m *IndexName) XXX_Size() int {
	return m.Size()
}
func (m *IndexName) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexName.DiscardUnknown(m)
}

var xxx_messageInfo_IndexName proto.InternalMessageInfo

type ConstraintName struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	Name         string                                                          `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ConstraintName) Reset()         { *m = ConstraintName{} }
func (m *ConstraintName) String() string { return proto.CompactTextString(m) }
func (*ConstraintName) ProtoMessage()    {}
func (*ConstraintName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{37}
}
func (m *ConstraintName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintName.Merge(m, src)
}
func (m *ConstraintName) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintName) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintName.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintName proto.InternalMessageInfo

type TableComment struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	Comment string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *TableComment) Reset()         { *m = TableComment{} }
func (m *TableComment) String() string { return proto.CompactTextString(m) }
func (*TableComment) ProtoMessage()    {}
func (*TableComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{38}
}
func (m *TableComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableComment.Merge(m, src)
}
func (m *TableComment) XXX_Size() int {
	return m.Size()
}
func (m *TableComment) XXX_DiscardUnknown() {
	xxx_messageInfo_TableComment.DiscardUnknown(m)
}

var xxx_messageInfo_TableComment proto.InternalMessageInfo

type DatabaseComment struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	Comment    string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *DatabaseComment) Reset()         { *m = DatabaseComment{} }
func (m *DatabaseComment) String() string { return proto.CompactTextString(m) }
func (*DatabaseComment) ProtoMessage()    {}
func (*DatabaseComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{39}
}
func (m *DatabaseComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseComment.Merge(m, src)
}
func (m *DatabaseComment) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseComment) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseComment.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseComment proto.InternalMessageInfo

type SchemaComment struct {
	SchemaID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	Comment  string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *SchemaComment) Reset()         { *m = SchemaComment{} }
func (m *SchemaComment) String() string { return proto.CompactTextString(m) }
func (*SchemaComment) ProtoMessage()    {}
func (*SchemaComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{40}
}
func (m *SchemaComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaComment.Merge(m, src)
}
func (m *SchemaComment) XXX_Size() int {
	return m.Size()
}
func (m *SchemaComment) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaComment.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaComment proto.InternalMessageInfo

type IndexComment struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Comment string                                                     `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *IndexComment) Reset()         { *m = IndexComment{} }
func (m *IndexComment) String() string { return proto.CompactTextString(m) }
func (*IndexComment) ProtoMessage()    {}
func (*IndexComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{41}
}
func (m *IndexComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexComment.Merge(m, src)
}
func (m *IndexComment) XXX_Size() int {
	return m.Size()
}
func (m *IndexComment) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexComment.DiscardUnknown(m)
}

var xxx_messageInfo_IndexComment proto.InternalMessageInfo

type ColumnComment struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Comment  string                                                      `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *ColumnComment) Reset()         { *m = ColumnComment{} }
func (m *ColumnComment) String() string { return proto.CompactTextString(m) }
func (*ColumnComment) ProtoMessage()    {}
func (*ColumnComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{42}
}
func (m *ColumnComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnComment.Merge(m, src)
}
func (m *ColumnComment) XXX_Size() int {
	return m.Size()
}
func (m *ColumnComment) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnComment.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnComment proto.InternalMessageInfo

type ConstraintComment struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	Comment      string                                                          `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *ConstraintComment) Reset()         { *m = ConstraintComment{} }
func (m *ConstraintComment) String() string { return proto.CompactTextString(m) }
func (*ConstraintComment) ProtoMessage()    {}
func (*ConstraintComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{43}
}
func (m *ConstraintComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintComment.Merge(m, src)
}
func (m *ConstraintComment) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintComment) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintComment.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintComment proto.InternalMessageInfo

type DatabaseRegionConfig struct {
	DatabaseID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	RegionEnumTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=region_enum_type_id,json=regionEnumTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"region_enum_type_id,omitempty"`
}

func (m *DatabaseRegionConfig) Reset()         { *m = DatabaseRegionConfig{} }
func (m *DatabaseRegionConfig) String() string { return proto.CompactTextString(m) }
func (*DatabaseRegionConfig) ProtoMessage()    {}
func (*DatabaseRegionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{44}
}
func (m *DatabaseRegionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseRegionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseRegionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseRegionConfig.Merge(m, src)
}
func (m *DatabaseRegionConfig) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseRegionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseRegionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseRegionConfig proto.InternalMessageInfo

type DatabaseRoleSetting struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	RoleName   string                                                    `protobuf:"bytes,2,opt,name=role_name,json=roleName,proto3" json:"role_name,omitempty"`
}

func (m *DatabaseRoleSetting) Reset()         { *m = DatabaseRoleSetting{} }
func (m *DatabaseRoleSetting) String() string { return proto.CompactTextString(m) }
func (*DatabaseRoleSetting) ProtoMessage()    {}
func (*DatabaseRoleSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{45}
}
func (m *DatabaseRoleSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseRoleSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseRoleSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseRoleSetting.Merge(m, src)
}
func (m *DatabaseRoleSetting) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseRoleSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseRoleSetting.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseRoleSetting proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.schemachanger.scpb.Index_Direction", Index_Direction_name, Index_Direction_value)
	proto.RegisterType((*ElementProto)(nil), "cockroach.sql.schemachanger.scpb.ElementProto")
	proto.RegisterType((*TypeT)(nil), "cockroach.sql.schemachanger.scpb.TypeT")
	proto.RegisterType((*Expression)(nil), "cockroach.sql.schemachanger.scpb.Expression")
	proto.RegisterType((*Column)(nil), "cockroach.sql.schemachanger.scpb.Column")
	proto.RegisterType((*ColumnType)(nil), "cockroach.sql.schemachanger.scpb.ColumnType")
	proto.RegisterType((*ColumnFamily)(nil), "cockroach.sql.schemachanger.scpb.ColumnFamily")
	proto.RegisterType((*Index)(nil), "cockroach.sql.schemachanger.scpb.Index")
	proto.RegisterType((*PrimaryIndex)(nil), "cockroach.sql.schemachanger.scpb.PrimaryIndex")
	proto.RegisterType((*SecondaryIndex)(nil), "cockroach.sql.schemachanger.scpb.SecondaryIndex")
	proto.RegisterType((*TemporaryIndex)(nil), "cockroach.sql.schemachanger.scpb.TemporaryIndex")
	proto.RegisterType((*SecondaryIndexPartial)(nil), "cockroach.sql.schemachanger.scpb.SecondaryIndexPartial")
	proto.RegisterType((*SchemaParent)(nil), "cockroach.sql.schemachanger.scpb.SchemaParent")
	proto.RegisterType((*ObjectParent)(nil), "cockroach.sql.schemachanger.scpb.ObjectParent")
	proto.RegisterType((*Sequence)(nil), "cockroach.sql.schemachanger.scpb.Sequence")
	proto.RegisterType((*SequenceOwner)(nil), "cockroach.sql.schemachanger.scpb.SequenceOwner")
	proto.RegisterType((*ColumnDefaultExpression)(nil), "cockroach.sql.schemachanger.scpb.ColumnDefaultExpression")
	proto.RegisterType((*ColumnOnUpdateExpression)(nil), "cockroach.sql.schemachanger.scpb.ColumnOnUpdateExpression")
	proto.RegisterType((*View)(nil), "cockroach.sql.schemachanger.scpb.View")
	proto.RegisterType((*Table)(nil), "cockroach.sql.schemachanger.scpb.Table")
	proto.RegisterType((*UniqueWithoutIndexConstraint)(nil), "cockroach.sql.schemachanger.scpb.UniqueWithoutIndexConstraint")
	proto.RegisterType((*CheckConstraint)(nil), "cockroach.sql.schemachanger.scpb.CheckConstraint")
	proto.RegisterType((*ForeignKeyConstraint)(nil), "cockroach.sql.schemachanger.scpb.ForeignKeyConstraint")
	proto.RegisterType((*EnumType)(nil), "cockroach.sql.schemachanger.scpb.EnumType")
	proto.RegisterType((*AliasType)(nil), "cockroach.sql.schemachanger.scpb.AliasType")
	proto.RegisterType((*Schema)(nil), "cockroach.sql.schemachanger.scpb.Schema")
	proto.RegisterType((*Database)(nil), "cockroach.sql.schemachanger.scpb.Database")
	proto.RegisterType((*Namespace)(nil), "cockroach.sql.schemachanger.scpb.Namespace")
	proto.RegisterType((*Owner)(nil), "cockroach.sql.schemachanger.scpb.Owner")
	proto.RegisterType((*UserPrivileges)(nil), "cockroach.sql.schemachanger.scpb.UserPrivileges")
	proto.RegisterType((*TableLocalityGlobal)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityGlobal")
	proto.RegisterType((*TableLocalityPrimaryRegion)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityPrimaryRegion")
	proto.RegisterType((*TableLocalitySecondaryRegion)(nil), "cockroach.sql.schemachanger.scpb.TableLocalitySecondaryRegion")
	proto.RegisterType((*TableLocalityRegionalByRow)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityRegionalByRow")
	proto.RegisterType((*IndexPartitioning)(nil), "cockroach.sql.schemachanger.scpb.IndexPartitioning")
	proto.RegisterType((*RowLevelTTL)(nil), "cockroach.sql.schemachanger.scpb.RowLevelTTL")
	proto.RegisterType((*ColumnName)(nil), "cockroach.sql.schemachanger.scpb.ColumnName")
	proto.RegisterType((*IndexName)(nil), "cockroach.sql.schemachanger.scpb.IndexName")
	proto.RegisterType((*ConstraintName)(nil), "cockroach.sql.schemachanger.scpb.ConstraintName")
	proto.RegisterType((*TableComment)(nil), "cockroach.sql.schemachanger.scpb.TableComment")
	proto.RegisterType((*DatabaseComment)(nil), "cockroach.sql.schemachanger.scpb.DatabaseComment")
	proto.RegisterType((*SchemaComment)(nil), "cockroach.sql.schemachanger.scpb.SchemaComment")
	proto.RegisterType((*IndexComment)(nil), "cockroach.sql.schemachanger.scpb.IndexComment")
	proto.RegisterType((*ColumnComment)(nil), "cockroach.sql.schemachanger.scpb.ColumnComment")
	proto.RegisterType((*ConstraintComment)(nil), "cockroach.sql.schemachanger.scpb.ConstraintComment")
	proto.RegisterType((*DatabaseRegionConfig)(nil), "cockroach.sql.schemachanger.scpb.DatabaseRegionConfig")
	proto.RegisterType((*DatabaseRoleSetting)(nil), "cockroach.sql.schemachanger.scpb.DatabaseRoleSetting")
}

func init() {
	proto.RegisterFile("sql/schemachanger/scpb/elements.proto", fileDescriptor_49b58fafa7b67c5d)
}

var fileDescriptor_49b58fafa7b67c5d = []byte{
	// 3470 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5c, 0x4f, 0x6c, 0x1c, 0x57,
	0x19, 0xcf, 0xac, 0xd7, 0xf6, 0xee, 0xe7, 0xdd, 0xb5, 0xfd, 0x62, 0x27, 0x93, 0x3f, 0xf5, 0x38,
	0x83, 0xda, 0xa6, 0xad, 0xb1, 0x81, 0x00, 0x55, 0x43, 0x5b, 0xc8, 0xda, 0x69, 0xba, 0x6d, 0x9a,
	0xb8, 0xe3, 0x24, 0xd0, 0xf6, 0x30, 0xcc, 0xce, 0x3c, 0xaf, 0xa7, 0x9e, 0x9d, 0xd9, 0xcc, 0x9b,
	0x8d, 0xe3, 0x0a, 0x41, 0x4b, 0x25, 0x0a, 0x55, 0x4b, 0xa9, 0xc4, 0x81, 0x8a, 0x4b, 0x0f, 0x3d,
	0x80, 0x38, 0x70, 0xe3, 0xc0, 0x05, 0xf5, 0x00, 0x8a, 0x10, 0x12, 0x15, 0x17, 0x7a, 0x5a, 0xc1,
	0xf6, 0x44, 0x85, 0x40, 0x18, 0x24, 0x50, 0x4e, 0xe8, 0xbd, 0x37, 0x7f, 0x37, 0x63, 0x7b, 0x12,
	0x6f, 0xb6, 0x92, 0xd5, 0x4b, 0xeb, 0x9d, 0x79, 0xdf, 0xf7, 0xfb, 0xbe, 0x6f, 0xbe, 0xf7, 0xbd,
	0xef, 0xfb, 0xde, 0x7b, 0x81, 0x7b, 0xc9, 0x55, 0x6b, 0x81, 0xe8, 0x6b, 0xb8, 0xa9, 0xe9, 0x6b,
	0x9a, 0xdd, 0xc0, 0xee, 0x02, 0xd1, 0x5b, 0xf5, 0x05, 0x6c, 0xe1, 0x26, 0xb6, 0x3d, 0x32, 0xdf,
	0x72, 0x1d, 0xcf, 0x41, 0xb3, 0xba, 0xa3, 0xaf, 0xbb, 0x8e, 0xa6, 0xaf, 0xcd, 0x93, 0xab, 0xd6,
	0x7c, 0x82, 0x60, 0x9e, 0x12, 0x1c, 0x95, 0x28, 0x23, 0x5d, 0xf3, 0x34, 0xcb, 0x69, 0xd0, 0xff,
	0xb7, 0xea, 0xc1, 0x2f, 0xce, 0xe2, 0xe8, 0x34, 0x1d, 0xe0, 0x6d, 0xb6, 0x30, 0xe1, 0xff, 0xf5,
	0x1f, 0x4f, 0x35, 0x9c, 0x86, 0xc3, 0xfe, 0x5c, 0xa0, 0x7f, 0xf1, 0xa7, 0xf2, 0xaf, 0xee, 0x87,
	0xd2, 0x59, 0x2e, 0xc2, 0x32, 0x13, 0xe0, 0x09, 0x28, 0x18, 0x9a, 0xa7, 0xd5, 0x35, 0x82, 0x45,
	0x61, 0x56, 0x38, 0x39, 0xf6, 0x85, 0x07, 0xe7, 0x77, 0x93, 0x69, 0x7e, 0xc9, 0xa7, 0x50, 0x42,
	0x5a, 0xf4, 0x35, 0x18, 0xe1, 0x03, 0xc5, 0x1c, 0xe3, 0x72, 0x72, 0x77, 0x2e, 0x2b, 0xec, 0x91,
	0xe2, 0xd3, 0xa1, 0xd3, 0x90, 0xbf, 0x66, 0xe2, 0x0d, 0x71, 0x88, 0xd1, 0xdf, 0xb7, 0x3b, 0xfd,
	0x15, 0x13, 0x6f, 0x28, 0x8c, 0x86, 0x6a, 0x41, 0xf0, 0xd5, 0x36, 0xb6, 0x75, 0x2c, 0xe6, 0xb3,
	0x6a, 0xb1, 0xe2, 0x53, 0x28, 0x21, 0x2d, 0x7a, 0x0c, 0x86, 0x3d, 0xad, 0x6e, 0x61, 0x71, 0x98,
	0x31, 0xb9, 0x7f, 0x77, 0x26, 0x97, 0xe8, 0x70, 0x85, 0x53, 0xa1, 0x73, 0x50, 0xc4, 0x76, 0xbb,
	0xa9, 0xd2, 0xef, 0x20, 0x8e, 0x64, 0x95, 0xe3, 0xac, 0xdd, 0x6e, 0x5e, 0xda, 0x6c, 0x61, 0xa5,
	0x80, 0xfd, 0xbf, 0xd0, 0x53, 0x00, 0x9a, 0x65, 0x6a, 0x84, 0x73, 0x1a, 0x65, 0x9c, 0x1e, 0xda,
	0x9d, 0xd3, 0x19, 0x4a, 0xc3, 0x58, 0x15, 0xb5, 0xe0, 0x4f, 0xd4, 0x80, 0xb2, 0xee, 0x58, 0xed,
	0xa6, 0xad, 0xae, 0x6a, 0x4d, 0xd3, 0xda, 0x14, 0xa7, 0x18, 0xbb, 0xf9, 0xdd, 0xd9, 0x2d, 0x32,
	0xb2, 0x27, 0x18, 0x55, 0x15, 0x6d, 0x75, 0xa4, 0x4a, 0x4b, 0x73, 0xb1, 0xed, 0x9d, 0x96, 0x99,
	0xd6, 0xb2, 0x52, 0xd2, 0x63, 0x23, 0xd0, 0xf3, 0x30, 0xc2, 0x7f, 0x8b, 0xd3, 0x59, 0x5d, 0x80,
	0x23, 0x54, 0xc5, 0xad, 0x8e, 0x34, 0x95, 0xe0, 0x3d, 0x37, 0x4b, 0xbf, 0xae, 0xac, 0xf8, 0x1c,
	0x51, 0x13, 0xca, 0x2d, 0xd7, 0x6c, 0x6a, 0xee, 0xa6, 0x6a, 0xda, 0x06, 0xbe, 0x2e, 0x1e, 0xca,
	0xaa, 0xc4, 0x32, 0x27, 0xab, 0x51, 0xaa, 0x1d, 0x80, 0x4a, 0xad, 0xd8, 0x38, 0x44, 0x60, 0x9c,
	0x60, 0xdd, 0xb1, 0x8d, 0x08, 0xf0, 0x30, 0x03, 0xfc, 0x5c, 0x16, 0xb7, 0xf2, 0x09, 0x77, 0x83,
	0xac, 0x90, 0xc4, 0x48, 0x0a, 0xea, 0xe1, 0x66, 0xcb, 0x71, 0x23, 0x50, 0x31, 0x2b, 0xe8, 0xa5,
	0x80, 0x70, 0x57, 0x50, 0x2f, 0x31, 0x12, 0xbd, 0x23, 0x80, 0xd4, 0xb6, 0xcd, 0xab, 0x6d, 0xac,
	0x6e, 0x98, 0xde, 0x9a, 0xd3, 0xf6, 0x38, 0xb4, 0xaa, 0x3b, 0x36, 0xf1, 0x5c, 0xcd, 0xb4, 0x3d,
	0xf1, 0x08, 0x93, 0xe2, 0xf1, 0xdd, 0xa5, 0xb8, 0xcc, 0x18, 0x7d, 0x9d, 0xf3, 0x61, 0xfc, 0x17,
	0x43, 0x2e, 0xa9, 0x0e, 0x74, 0xbc, 0xbd, 0x03, 0x05, 0x6a, 0xc1, 0x84, 0xbe, 0x86, 0xf5, 0xf5,
	0xb8, 0x2c, 0x47, 0x99, 0x2c, 0x9f, 0xcf, 0xe0, 0x5a, 0x94, 0x72, 0x17, 0xf8, 0x71, 0x3d, 0x39,
	0x08, 0xbd, 0x2c, 0xc0, 0xa1, 0x55, 0xc7, 0xc5, 0x66, 0xc3, 0x56, 0xd7, 0xf1, 0x66, 0x1c, 0xf8,
	0x18, 0x03, 0xfe, 0xf2, 0xee, 0xc0, 0x4f, 0x70, 0xfa, 0xa7, 0xf1, 0xe6, 0x2e, 0xe8, 0x53, 0xab,
	0x29, 0x23, 0xd1, 0x06, 0x94, 0x59, 0x30, 0x51, 0x75, 0xa7, 0x49, 0xc3, 0xb4, 0x78, 0x3c, 0xab,
	0xa7, 0x33, 0xb6, 0x8b, 0x9c, 0xaa, 0x2a, 0x6f, 0x75, 0xa4, 0x99, 0x14, 0x0f, 0x98, 0x9b, 0x0d,
	0xc2, 0x9e, 0xac, 0x94, 0xbc, 0x18, 0x05, 0xf2, 0xa0, 0xec, 0x3a, 0x1b, 0xaa, 0x85, 0xaf, 0x61,
	0x4b, 0xf5, 0x3c, 0x4b, 0xbc, 0x87, 0x01, 0x7f, 0x76, 0x77, 0x60, 0xc5, 0xd9, 0x38, 0x4f, 0xa9,
	0x2e, 0x5d, 0x3a, 0x5f, 0x3d, 0xd1, 0xed, 0x48, 0x63, 0xb1, 0x07, 0x29, 0x7a, 0x8f, 0xb9, 0xc1,
	0x6b, 0xcf, 0x42, 0x2e, 0x8c, 0x5b, 0x8e, 0xae, 0x59, 0xa6, 0xb7, 0xa9, 0x36, 0x2c, 0xa7, 0xae,
	0x59, 0xa2, 0xcd, 0x70, 0xbf, 0x94, 0x51, 0xe1, 0xf3, 0x3e, 0xf5, 0x39, 0x46, 0x9c, 0x6a, 0xe8,
	0x8a, 0x95, 0x18, 0x83, 0xbe, 0x2f, 0xc0, 0xe1, 0x10, 0x34, 0x08, 0x2b, 0x2e, 0x6e, 0x98, 0x8e,
	0x2d, 0x3a, 0x0c, 0xfc, 0xd1, 0xdb, 0x04, 0xf7, 0x83, 0x8c, 0xc2, 0x78, 0xa4, 0xca, 0x30, 0x6d,
	0xa5, 0x0d, 0x45, 0x3f, 0x14, 0xe0, 0x48, 0x28, 0x4a, 0x14, 0x72, 0x7c, 0x61, 0x5a, 0x59, 0x27,
	0x5e, 0x42, 0x98, 0x30, 0x00, 0xed, 0x20, 0x4e, 0xa8, 0x7f, 0xcf, 0x60, 0xf4, 0x03, 0x01, 0xc4,
	0x50, 0x20, 0x2e, 0x86, 0x66, 0xa9, 0xf5, 0x4d, 0xd5, 0x75, 0x36, 0xc4, 0xab, 0x77, 0x64, 0x1c,
	0xc5, 0xe7, 0x52, 0xdd, 0x54, 0x9c, 0x8d, 0x9d, 0x8d, 0x93, 0x18, 0x8a, 0xea, 0x30, 0xe6, 0xaf,
	0x5c, 0xb6, 0xd6, 0xc4, 0xe2, 0x0c, 0x43, 0x9f, 0xcb, 0xba, 0xaa, 0x5c, 0xd0, 0x9a, 0xb8, 0x7a,
	0x70, 0xab, 0x23, 0x8d, 0x07, 0x68, 0xfc, 0xb9, 0xac, 0x80, 0x1e, 0x0e, 0x88, 0x61, 0xb0, 0xa5,
	0x56, 0xba, 0x3d, 0x0c, 0xba, 0xc0, 0xee, 0x88, 0xc1, 0x56, 0xe0, 0xd7, 0x05, 0x38, 0xe2, 0x83,
	0x18, 0x78, 0x55, 0x6b, 0x5b, 0x9e, 0x8a, 0xaf, 0xb7, 0x5c, 0x4c, 0x08, 0xfd, 0xc8, 0xb3, 0x0c,
	0xf2, 0x91, 0xac, 0x90, 0x4b, 0x9c, 0xc3, 0xd9, 0x90, 0x41, 0x3a, 0xfe, 0x61, 0x3d, 0x7d, 0x34,
	0xf5, 0xb8, 0x63, 0xbe, 0x30, 0x8e, 0xad, 0xb6, 0x5b, 0x86, 0xe6, 0xe1, 0xb8, 0x38, 0x27, 0x98,
	0x38, 0xa7, 0xb3, 0x8a, 0x73, 0xd1, 0xbe, 0xcc, 0x58, 0xec, 0x26, 0x8f, 0xa8, 0x6f, 0x33, 0x1c,
	0xad, 0x43, 0x25, 0xc8, 0xbf, 0x54, 0x67, 0xc3, 0xc6, 0xae, 0x28, 0x33, 0x11, 0x16, 0xb2, 0x67,
	0x70, 0x17, 0x29, 0x59, 0x3a, 0x6e, 0x99, 0xc4, 0xc7, 0x50, 0x30, 0x5f, 0xf9, 0x20, 0xbc, 0x7e,
	0x26, 0x2b, 0x18, 0xe7, 0x18, 0xc4, 0xd7, 0x74, 0x30, 0x3d, 0x3e, 0x06, 0xb5, 0x01, 0xf8, 0x5a,
	0xca, 0xdc, 0xf7, 0x64, 0xd6, 0x2c, 0x8e, 0x2d, 0x83, 0xcc, 0x7b, 0x1f, 0xd8, 0xea, 0x48, 0xf7,
	0x06, 0x20, 0xf1, 0x44, 0x86, 0x46, 0xf1, 0x78, 0xee, 0x20, 0x2b, 0x45, 0x33, 0xa0, 0x42, 0x6f,
	0x0a, 0x80, 0x38, 0x6e, 0x4b, 0x73, 0x3d, 0xd3, 0x33, 0x1d, 0xdb, 0xb4, 0x1b, 0xe2, 0x03, 0x0c,
	0xff, 0x54, 0x46, 0xfc, 0xe5, 0x18, 0xe9, 0xed, 0xc8, 0x31, 0x69, 0xf6, 0x52, 0xa3, 0x37, 0x04,
	0x38, 0xdc, 0x93, 0x4d, 0x71, 0xc9, 0x34, 0x4b, 0x7c, 0x90, 0x09, 0xf5, 0xf0, 0xed, 0x66, 0x55,
	0xcb, 0x9c, 0xbc, 0x7a, 0x6c, 0xab, 0x23, 0x1d, 0x0e, 0x04, 0xeb, 0x15, 0x65, 0x9a, 0xa4, 0xd1,
	0xa0, 0x6f, 0x43, 0x39, 0xc8, 0x70, 0xb8, 0x07, 0x3c, 0x94, 0x75, 0x81, 0xf5, 0xf3, 0x13, 0xee,
	0x00, 0xb7, 0x61, 0x93, 0x92, 0x19, 0x23, 0x44, 0xbf, 0x10, 0x60, 0x3c, 0xca, 0x2b, 0xb8, 0x6f,
	0x9c, 0xca, 0x9a, 0xe7, 0x45, 0x89, 0x02, 0x73, 0x90, 0xe5, 0xad, 0x8e, 0x74, 0x3e, 0x10, 0x62,
	0xa7, 0xec, 0x6b, 0x6e, 0xb6, 0x27, 0x1f, 0x9a, 0x9b, 0x4d, 0xcb, 0x53, 0x64, 0xa5, 0xa2, 0x27,
	0x10, 0xd0, 0x9f, 0x04, 0x40, 0x31, 0x69, 0x03, 0x9b, 0x7d, 0x31, 0xab, 0x33, 0x45, 0xbc, 0x03,
	0xc3, 0xd9, 0x5b, 0x1d, 0xe9, 0xc5, 0x2c, 0x86, 0x9b, 0x9b, 0xed, 0x8b, 0x46, 0x93, 0x7a, 0xaf,
	0x08, 0xe8, 0xc7, 0x02, 0x14, 0xa9, 0xdd, 0x49, 0x4b, 0xd3, 0xb1, 0xf8, 0x68, 0xd6, 0x89, 0x79,
	0x21, 0x20, 0xa9, 0xd6, 0xb6, 0x3a, 0xd2, 0xd9, 0x1d, 0xb3, 0xab, 0xb9, 0xd9, 0xa0, 0x48, 0x9e,
	0x9b, 0xe5, 0x85, 0xee, 0xdc, 0x6c, 0x58, 0x9e, 0xcd, 0xcd, 0x06, 0x35, 0x9f, 0xac, 0x44, 0x82,
	0xd0, 0xbc, 0x64, 0x98, 0x47, 0xc0, 0xc7, 0xb2, 0x96, 0x9f, 0x3c, 0xf2, 0xf5, 0x51, 0x1c, 0x2e,
	0x00, 0x7a, 0x4f, 0x80, 0xf1, 0x36, 0xc1, 0x2e, 0x4d, 0x8f, 0xae, 0x99, 0x16, 0x6e, 0x60, 0x22,
	0x3e, 0x9e, 0xd5, 0x49, 0x2f, 0x13, 0xec, 0x2e, 0x87, 0x74, 0xfd, 0x94, 0xae, 0xd2, 0x4e, 0xb0,
	0x46, 0xaf, 0x0a, 0x70, 0x28, 0x68, 0x41, 0xf8, 0xd9, 0x0a, 0xcd, 0xd9, 0x57, 0xcd, 0x86, 0xb8,
	0x9c, 0x35, 0x5f, 0x0f, 0x9b, 0x19, 0x8c, 0x7c, 0x91, 0x51, 0x57, 0xa7, 0xb7, 0x3a, 0xd2, 0x64,
	0x20, 0x73, 0x30, 0x42, 0x56, 0xa6, 0x8c, 0x94, 0xc1, 0xb4, 0x6a, 0x98, 0x8e, 0xa4, 0x70, 0x2c,
	0xac, 0x12, 0xec, 0x79, 0x34, 0xe6, 0x3e, 0x9b, 0x35, 0x95, 0x0d, 0x85, 0x70, 0x2c, 0xbc, 0xc2,
	0x89, 0xb7, 0x93, 0xe1, 0xa0, 0x71, 0xeb, 0x58, 0x44, 0x60, 0x22, 0x94, 0x20, 0x98, 0xa3, 0x4a,
	0xd6, 0x52, 0x29, 0xe0, 0x1d, 0xcc, 0xd0, 0x6d, 0x80, 0xc7, 0x8d, 0xe4, 0x38, 0xb4, 0x06, 0x65,
	0xce, 0x4d, 0xe5, 0x83, 0xc5, 0xe7, 0xb3, 0x46, 0x52, 0xfe, 0x91, 0x97, 0x19, 0x55, 0x72, 0x29,
	0xe5, 0x6f, 0x64, 0xa5, 0x44, 0x62, 0x43, 0x58, 0x8e, 0xc0, 0x91, 0x02, 0xe5, 0x5e, 0xc8, 0x9c,
	0x23, 0xb0, 0x47, 0xa9, 0xcb, 0x76, 0x80, 0xe5, 0x6b, 0x11, 0xa8, 0xf5, 0x86, 0x00, 0x65, 0xa7,
	0xfe, 0x22, 0xd6, 0xbd, 0x40, 0x2f, 0x23, 0xab, 0x5e, 0x17, 0x19, 0x99, 0xaf, 0xd7, 0xc3, 0x5b,
	0x1d, 0xe9, 0x54, 0x80, 0x95, 0xe2, 0xce, 0x73, 0xb3, 0xdb, 0xd5, 0x65, 0x4e, 0x8c, 0xcd, 0xe9,
	0xfc, 0x8d, 0x77, 0x25, 0x41, 0xfe, 0xa5, 0x00, 0xc3, 0x94, 0xe8, 0x12, 0x9a, 0x87, 0x3c, 0x4b,
	0x55, 0x79, 0xb7, 0xee, 0x68, 0xaf, 0x50, 0xb8, 0x39, 0xcf, 0xdb, 0x80, 0x97, 0x14, 0x36, 0x0e,
	0x5d, 0x83, 0x71, 0xdd, 0x72, 0x08, 0x36, 0x58, 0x86, 0xab, 0x9a, 0x06, 0x11, 0x73, 0xb3, 0x43,
	0x27, 0xcb, 0xd5, 0x0b, 0xdd, 0x8e, 0x54, 0x5e, 0x64, 0xaf, 0x28, 0xe7, 0xda, 0x12, 0xb9, 0xd9,
	0x91, 0x1e, 0x69, 0x98, 0xde, 0x5a, 0xbb, 0x3e, 0xaf, 0x3b, 0xcd, 0x85, 0x90, 0xb3, 0x51, 0x8f,
	0xfe, 0x5e, 0x68, 0xad, 0x37, 0x16, 0x58, 0x73, 0x13, 0x37, 0x17, 0x74, 0xcd, 0x33, 0x8d, 0xf9,
	0x25, 0x4c, 0xf4, 0xda, 0x92, 0x52, 0xd6, 0x23, 0x5e, 0x06, 0x91, 0xff, 0x9c, 0x03, 0x88, 0xa5,
	0x79, 0xcf, 0x41, 0x9e, 0x66, 0x99, 0x4c, 0xec, 0x62, 0xf5, 0xec, 0xcd, 0x8e, 0x74, 0x26, 0x33,
	0x54, 0xa2, 0xfd, 0x39, 0x1f, 0x31, 0x55, 0x18, 0x4b, 0xd4, 0x82, 0x72, 0x9b, 0x60, 0xd2, 0xab,
	0xdf, 0x79, 0x5a, 0x8a, 0x5e, 0x26, 0x98, 0xf4, 0x45, 0xbb, 0xb1, 0x76, 0xc0, 0xc9, 0x20, 0xe8,
	0x5b, 0x30, 0xc9, 0x10, 0xc3, 0xc4, 0x95, 0xa2, 0x0e, 0x31, 0xd4, 0xe5, 0x6e, 0x47, 0x1a, 0xa7,
	0xa8, 0xc1, 0xf7, 0xdc, 0x33, 0x32, 0x0d, 0xc4, 0x11, 0x37, 0x83, 0xc8, 0xbf, 0xc9, 0xc3, 0x08,
	0x4f, 0x39, 0x91, 0x0e, 0x05, 0xde, 0x2d, 0x30, 0x0d, 0x66, 0xd9, 0x72, 0xf5, 0xc9, 0x6e, 0x47,
	0x1a, 0x65, 0x8e, 0x55, 0x5b, 0xda, 0x1b, 0xee, 0x28, 0xe3, 0x5c, 0x33, 0xd0, 0x1a, 0x14, 0xfd,
	0xa4, 0xd9, 0x34, 0x58, 0x7b, 0xb7, 0x5c, 0x7d, 0xba, 0xdb, 0x91, 0x0a, 0x5c, 0x06, 0x06, 0xf3,
	0x95, 0x3b, 0x80, 0x09, 0xc8, 0x95, 0x02, 0xe7, 0x5e, 0x33, 0xd0, 0x31, 0x28, 0x9a, 0x44, 0x5d,
	0x33, 0x0d, 0x03, 0xdb, 0xac, 0x11, 0x5c, 0x50, 0x0a, 0x26, 0x79, 0x92, 0xfd, 0x46, 0xf7, 0xc3,
	0xb8, 0x49, 0x54, 0xd3, 0xd6, 0x74, 0x9d, 0x7e, 0xfe, 0xba, 0xc5, 0x7b, 0xbd, 0x05, 0xa5, 0x62,
	0x92, 0x5a, 0xec, 0x29, 0x7a, 0x4b, 0x80, 0xa3, 0x0d, 0x6c, 0x63, 0x57, 0xf3, 0xb0, 0xa1, 0x6a,
	0x44, 0x35, 0x0d, 0x6c, 0x7b, 0xb4, 0xa0, 0x65, 0x13, 0x67, 0x98, 0x69, 0xa0, 0xdc, 0xec, 0x48,
	0x17, 0xee, 0xd0, 0x03, 0xcf, 0x05, 0xcc, 0xcf, 0x90, 0x9a, 0xcf, 0x9a, 0x75, 0x5d, 0x0f, 0x37,
	0xd2, 0x5f, 0xa0, 0x65, 0xb8, 0x37, 0x5d, 0xa0, 0xa8, 0xf2, 0x69, 0xd1, 0x74, 0x99, 0x35, 0x8d,
	0x8b, 0xca, 0x89, 0x14, 0x3e, 0x61, 0xad, 0xc3, 0x06, 0xa2, 0x47, 0x61, 0xa2, 0xd5, 0x50, 0x35,
	0xcf, 0x73, 0xcd, 0x7a, 0xdb, 0xc3, 0xaa, 0xdd, 0x6e, 0xb2, 0x3e, 0x71, 0xb9, 0x8a, 0xba, 0x1d,
	0xa9, 0xb2, 0xdc, 0x38, 0x13, 0xbc, 0xba, 0xd0, 0x6e, 0x2a, 0x95, 0x56, 0xe2, 0xb7, 0xfc, 0xf7,
	0x3c, 0x40, 0x54, 0xc1, 0x0e, 0xcc, 0x8b, 0x78, 0x03, 0xba, 0xc7, 0x8b, 0x78, 0xf7, 0xf8, 0x8e,
	0xbd, 0x28, 0x20, 0x57, 0x0a, 0x9c, 0x7b, 0xaf, 0xbf, 0x0e, 0xdd, 0x4d, 0x7f, 0x7d, 0x0e, 0xc6,
	0x71, 0xb3, 0x8e, 0x0d, 0x23, 0x88, 0xae, 0x9e, 0xbf, 0xfd, 0x90, 0x65, 0xe7, 0x80, 0x46, 0xf3,
	0x6a, 0xe1, 0x46, 0x47, 0x3a, 0xf0, 0x41, 0x47, 0x12, 0x94, 0x72, 0xc0, 0x89, 0x87, 0x79, 0x09,
	0xc6, 0x4c, 0xa2, 0xda, 0x6d, 0xcb, 0x0a, 0x37, 0x24, 0x0a, 0x0a, 0x98, 0xe4, 0x82, 0xff, 0x04,
	0x5d, 0x84, 0x92, 0xee, 0x34, 0x5b, 0x6d, 0xbf, 0x7c, 0xf7, 0xf7, 0x1b, 0x32, 0xb4, 0x2e, 0x62,
	0xf1, 0x73, 0xcc, 0xe7, 0x40, 0x1f, 0xa1, 0x7b, 0x00, 0x4c, 0xa2, 0x5e, 0x33, 0x5d, 0xaf, 0xad,
	0x59, 0xcc, 0x99, 0x0a, 0x4a, 0xd1, 0x24, 0x57, 0xf8, 0x03, 0xf4, 0x08, 0x1c, 0x31, 0x89, 0xea,
	0x62, 0x4b, 0xa3, 0x0e, 0xa8, 0xd6, 0xb1, 0x69, 0x37, 0x54, 0xc3, 0x75, 0x5a, 0x2d, 0x6c, 0x88,
	0xc0, 0x46, 0x1f, 0x32, 0x89, 0xe2, 0xbf, 0xaf, 0xd2, 0xd7, 0x4b, 0xfc, 0xad, 0xfc, 0x2f, 0x01,
	0x4a, 0xf1, 0xcd, 0x84, 0xfd, 0xe6, 0x70, 0x08, 0xf2, 0xac, 0x8c, 0x1b, 0x62, 0xb3, 0x97, 0xfd,
	0x2d, 0xff, 0x04, 0x60, 0x98, 0xb7, 0xd8, 0x07, 0xa2, 0xac, 0x01, 0x05, 0x5e, 0xd5, 0x86, 0xba,
	0xd6, 0x28, 0x08, 0x93, 0x80, 0x81, 0x9c, 0xbe, 0x03, 0x10, 0x9f, 0x5a, 0x19, 0x65, 0xac, 0x6b,
	0x06, 0x6a, 0x43, 0x85, 0xb7, 0xc5, 0xfd, 0xd9, 0x15, 0x2c, 0x7a, 0x17, 0xbb, 0x1d, 0xa9, 0xc4,
	0xea, 0x2e, 0x3e, 0x45, 0xc8, 0x5e, 0xa7, 0x58, 0x69, 0x3d, 0x64, 0x66, 0x10, 0x84, 0x61, 0x3a,
	0x06, 0x6b, 0x98, 0x2e, 0xd6, 0xa9, 0x8f, 0x11, 0x31, 0x3f, 0x3b, 0x74, 0xb2, 0x92, 0x25, 0xc5,
	0x65, 0x9a, 0xcc, 0x2f, 0x05, 0x94, 0xca, 0xc1, 0x90, 0x7f, 0xf8, 0x8c, 0xd0, 0xfa, 0x8b, 0xe1,
	0x90, 0xf6, 0xea, 0xaa, 0x79, 0x3d, 0xae, 0xe5, 0x30, 0xd3, 0xf2, 0x72, 0xb7, 0x23, 0xa1, 0xa7,
	0xf1, 0xe6, 0x0a, 0x7b, 0xdf, 0x37, 0x5d, 0xd1, 0x7a, 0x0f, 0x4b, 0x83, 0xa0, 0x57, 0x04, 0x40,
	0xc4, 0x73, 0x5c, 0x3a, 0xc7, 0x62, 0x72, 0x8c, 0x30, 0x39, 0x56, 0xba, 0x1d, 0x69, 0x62, 0x85,
	0xbf, 0xed, 0x9b, 0x14, 0x13, 0x24, 0xc1, 0xd0, 0x20, 0xe8, 0x35, 0x01, 0xa6, 0x68, 0x7c, 0x70,
	0x88, 0xe9, 0xe1, 0xb8, 0x14, 0xa3, 0x91, 0x35, 0x16, 0x83, 0xf7, 0xfd, 0xb3, 0x86, 0xde, 0xc3,
	0xd2, 0x20, 0x7e, 0x5a, 0xc0, 0xf7, 0x8a, 0xfc, 0x50, 0x53, 0x30, 0x09, 0xef, 0x0e, 0xf8, 0x81,
	0xd2, 0xb4, 0xaf, 0x61, 0xd7, 0xc3, 0x86, 0x38, 0x16, 0x04, 0xca, 0x9a, 0xff, 0x04, 0x3d, 0x05,
	0x05, 0xb2, 0xa6, 0xb9, 0x06, 0x2d, 0xc8, 0x4a, 0xa9, 0x99, 0x7c, 0xb0, 0xa1, 0xce, 0x57, 0xf7,
	0x15, 0x3a, 0x18, 0x1b, 0x74, 0x86, 0xb9, 0x66, 0xcb, 0x73, 0x5c, 0x25, 0xa4, 0xf7, 0x73, 0x10,
	0xdd, 0xb1, 0xf5, 0xb6, 0x4b, 0xb3, 0x73, 0x7f, 0x3b, 0x95, 0xe5, 0x20, 0x8b, 0xb1, 0xa7, 0x68,
	0x03, 0xc6, 0x89, 0xd3, 0x76, 0x69, 0x6a, 0x18, 0x4c, 0xcb, 0x69, 0x36, 0x2d, 0xe9, 0x54, 0x29,
	0xaf, 0xb0, 0x57, 0xfd, 0x99, 0x9c, 0x65, 0x12, 0x63, 0x66, 0xd0, 0x62, 0x14, 0xf5, 0x6c, 0x23,
	0x52, 0xf0, 0x43, 0x3c, 0xe9, 0xa1, 0x9e, 0x93, 0xdc, 0x2b, 0xdc, 0x33, 0xfe, 0x44, 0x72, 0x47,
	0xb1, 0x66, 0xc8, 0x33, 0x50, 0x0c, 0x67, 0x15, 0x1a, 0x85, 0xa1, 0x33, 0x2b, 0x8b, 0x13, 0x07,
	0x50, 0x01, 0xf2, 0x4b, 0x67, 0x57, 0x16, 0x27, 0x04, 0x79, 0x0d, 0x4a, 0xf1, 0xbe, 0x0f, 0xfa,
	0x06, 0x54, 0xc2, 0x55, 0x94, 0xef, 0x7b, 0x0a, 0x59, 0x17, 0x51, 0xbe, 0xdd, 0x99, 0xb2, 0x88,
	0xf2, 0xd6, 0xdb, 0x8b, 0x50, 0x49, 0xf6, 0x94, 0xee, 0x22, 0xd6, 0xcf, 0x05, 0xa8, 0x24, 0x4d,
	0x7b, 0xf7, 0xc0, 0xd0, 0x63, 0x70, 0x8c, 0xce, 0x08, 0x42, 0xe3, 0x43, 0xd4, 0x5b, 0xc5, 0xb6,
	0xee, 0x30, 0x37, 0xcf, 0x31, 0x9f, 0x14, 0x4d, 0x72, 0x99, 0x8e, 0x08, 0x4d, 0x70, 0xd6, 0x7f,
	0x2f, 0xdf, 0xcc, 0xc1, 0x74, 0x6a, 0x47, 0x75, 0x3f, 0x2d, 0x56, 0x2f, 0x40, 0x68, 0x34, 0x9e,
	0x21, 0x0d, 0xdd, 0x7e, 0x86, 0x14, 0xfb, 0x02, 0xa5, 0x80, 0x19, 0x4b, 0x96, 0xf6, 0x90, 0x0d,
	0xfd, 0x57, 0x80, 0x52, 0xbc, 0x01, 0x82, 0x56, 0xa1, 0xe8, 0x77, 0x37, 0x42, 0xa3, 0x53, 0x7b,
	0x14, 0xf8, 0xa0, 0xbd, 0x5a, 0xbd, 0xc0, 0x79, 0xd7, 0x0c, 0xf4, 0x1d, 0x40, 0xbc, 0x1d, 0xa1,
	0x86, 0xbd, 0xa2, 0xf0, 0x03, 0x3c, 0x4b, 0x23, 0x03, 0x97, 0x27, 0xe8, 0xf8, 0xec, 0x15, 0x78,
	0xa2, 0x95, 0x64, 0xc7, 0xf3, 0xc0, 0x78, 0x8b, 0x84, 0x6a, 0xee, 0x77, 0x5a, 0x92, 0x9a, 0xf3,
	0x41, 0x7b, 0xd6, 0x9c, 0xf3, 0xae, 0x19, 0x68, 0x13, 0x7c, 0x61, 0xd4, 0xc8, 0xd0, 0xb9, 0x30,
	0x1c, 0x57, 0xb8, 0x34, 0xfd, 0x31, 0xb7, 0xbf, 0xb7, 0xe9, 0x33, 0x33, 0xe4, 0x9f, 0x0a, 0x50,
	0x08, 0x6a, 0x37, 0x64, 0xc1, 0x58, 0xac, 0x65, 0xe0, 0x6b, 0x4c, 0x93, 0x52, 0x88, 0xba, 0x05,
	0x7b, 0x83, 0x07, 0x12, 0x36, 0x0a, 0xd0, 0x09, 0x28, 0x99, 0x44, 0x0d, 0xc3, 0xb3, 0xef, 0x96,
	0x63, 0x26, 0x09, 0xc3, 0x94, 0xfc, 0x87, 0x1c, 0x94, 0x13, 0xbb, 0x68, 0x03, 0x16, 0x31, 0x1e,
	0x6e, 0x72, 0x03, 0xe9, 0x5f, 0xdc, 0xcd, 0x7a, 0x50, 0xfe, 0x6d, 0x0e, 0x0e, 0x6f, 0xb3, 0x4d,
	0xbb, 0xdf, 0x5a, 0x35, 0x77, 0x33, 0xba, 0xca, 0xbf, 0xcb, 0x81, 0xb8, 0xdd, 0xfe, 0xf2, 0xa7,
	0x86, 0xbc, 0x0d, 0x43, 0xbe, 0x37, 0x04, 0xf9, 0x2b, 0x26, 0xde, 0x40, 0xdf, 0x84, 0xd1, 0x6b,
	0x26, 0xde, 0x88, 0x6c, 0x76, 0xae, 0xdb, 0x91, 0x46, 0xe8, 0xab, 0xbd, 0x9a, 0x6c, 0x84, 0xf2,
	0xad, 0x19, 0x9f, 0x60, 0x17, 0x36, 0x5c, 0x85, 0x53, 0xba, 0xb0, 0xc1, 0x0a, 0xdc, 0x9f, 0x2e,
	0x6c, 0xc8, 0xcd, 0x20, 0x19, 0xa2, 0xab, 0x5f, 0x2d, 0x34, 0x35, 0x0f, 0xbb, 0xa6, 0x66, 0x99,
	0x2f, 0x85, 0xe5, 0x49, 0xc5, 0x24, 0xcf, 0xc4, 0x9e, 0xca, 0x6f, 0x09, 0x30, 0xcc, 0xfc, 0x77,
	0x30, 0xce, 0x9d, 0x61, 0x61, 0xf8, 0x38, 0x07, 0xc7, 0x77, 0xda, 0x7e, 0x1d, 0x8c, 0xa0, 0xd7,
	0xa1, 0x1c, 0xdb, 0x7c, 0x0e, 0x67, 0x22, 0x2d, 0x80, 0x4b, 0x91, 0x2c, 0x0c, 0xee, 0xab, 0x77,
	0x34, 0x1b, 0x23, 0x16, 0x4a, 0x29, 0x42, 0xaa, 0x19, 0x68, 0x1d, 0xe0, 0x96, 0x2e, 0x07, 0x75,
	0xe5, 0x62, 0xdf, 0x0a, 0xdd, 0x62, 0x10, 0x01, 0x88, 0xfc, 0xeb, 0x21, 0x18, 0xef, 0xd9, 0xcd,
	0xfe, 0xd4, 0xbe, 0xfd, 0xb3, 0xef, 0xad, 0x21, 0x36, 0xdf, 0xc7, 0x10, 0xfb, 0x9f, 0x3c, 0x4c,
	0xa5, 0x9d, 0x3c, 0xf8, 0xf4, 0x0b, 0xf6, 0xf1, 0x0b, 0x7e, 0x57, 0x80, 0x83, 0x2e, 0x5e, 0xc5,
	0x2e, 0xcd, 0x1b, 0x0d, 0x35, 0xb4, 0x6b, 0x3e, 0x6c, 0x6b, 0x4c, 0x2a, 0xe1, 0xeb, 0xbe, 0x58,
	0x78, 0xd2, 0xed, 0xe1, 0x67, 0xa0, 0xd7, 0x05, 0x98, 0x8e, 0x09, 0x71, 0x4b, 0x7f, 0xf0, 0x4a,
	0xb7, 0x23, 0x1d, 0x8c, 0xc4, 0xe8, 0x9b, 0x1d, 0x62, 0x9a, 0x87, 0x3d, 0x31, 0xf9, 0x7b, 0x39,
	0x28, 0x04, 0x3b, 0xc9, 0x74, 0x75, 0xf7, 0x97, 0xdd, 0xf8, 0xea, 0xce, 0x57, 0xdc, 0x3d, 0xae,
	0xee, 0x1e, 0x5b, 0x6c, 0xe9, 0xea, 0xae, 0xb9, 0xae, 0xb6, 0x19, 0x2c, 0xef, 0xbe, 0x9f, 0xb1,
	0xd5, 0xfd, 0x0c, 0x7d, 0xd1, 0x0f, 0xb0, 0x31, 0x2d, 0xe4, 0x64, 0xa0, 0xfb, 0xf8, 0xe2, 0xd9,
	0xb6, 0x3c, 0x33, 0x38, 0x0f, 0xcb, 0x77, 0x04, 0xcb, 0x26, 0x79, 0x86, 0x3e, 0xe5, 0x67, 0x30,
	0xe4, 0x1b, 0x02, 0x14, 0xc3, 0xdd, 0xf5, 0x01, 0x58, 0x22, 0x65, 0xcf, 0x27, 0xd7, 0x9f, 0x3d,
	0x1f, 0xf9, 0x8f, 0x02, 0x8c, 0xf0, 0xc2, 0x71, 0x60, 0x3d, 0x81, 0x0c, 0x59, 0x0c, 0xef, 0xbe,
	0xb6, 0xda, 0x75, 0xcb, 0xd4, 0xfd, 0xfc, 0xa5, 0x60, 0x92, 0x65, 0xf6, 0xbb, 0x67, 0xd3, 0xa8,
	0xd4, 0xb3, 0x69, 0x24, 0x5f, 0x87, 0x42, 0x50, 0xff, 0xd3, 0xca, 0x32, 0xde, 0x77, 0x88, 0x55,
	0x96, 0xfd, 0xea, 0x38, 0x80, 0x11, 0xf5, 0x1a, 0xfe, 0x96, 0x83, 0x62, 0x78, 0x60, 0x6b, 0xb0,
	0xd8, 0xc9, 0x8f, 0x97, 0xbb, 0x7b, 0x1f, 0xcf, 0x85, 0xb2, 0x11, 0x76, 0xa9, 0xa3, 0xe2, 0xf6,
	0x19, 0x1a, 0xfc, 0xa3, 0xf6, 0xf5, 0x5e, 0xf1, 0x4a, 0x11, 0x46, 0x6c, 0xaf, 0x2b, 0x1f, 0xdb,
	0xeb, 0x7a, 0x5b, 0x80, 0x61, 0xde, 0x3d, 0xb8, 0x45, 0x22, 0xe1, 0xee, 0x4b, 0x34, 0x15, 0x9c,
	0x9a, 0xcb, 0x31, 0x91, 0xf8, 0x0f, 0xf9, 0x7d, 0x01, 0x2a, 0xc9, 0x83, 0x68, 0x9f, 0x88, 0x70,
	0xc7, 0xa0, 0xc8, 0xce, 0xd1, 0x31, 0x9b, 0x71, 0x01, 0x0b, 0xf4, 0x01, 0x3b, 0x5c, 0x39, 0x03,
	0x10, 0x3b, 0x5f, 0xc7, 0x3e, 0x9e, 0x12, 0x7b, 0x22, 0xbf, 0x04, 0x07, 0x53, 0xee, 0x38, 0x0c,
	0x24, 0xb1, 0x90, 0x5f, 0x11, 0xe0, 0xe8, 0xf6, 0x77, 0x1c, 0x06, 0x23, 0xc3, 0x3f, 0x72, 0x70,
	0x7c, 0xa7, 0xab, 0x0d, 0x83, 0x49, 0xb1, 0x5e, 0x66, 0xb9, 0x07, 0x3b, 0x5b, 0x18, 0xde, 0xee,
	0xeb, 0x69, 0x9c, 0x72, 0x71, 0x82, 0xe5, 0x78, 0xcf, 0x8d, 0x53, 0x37, 0xc9, 0x8e, 0x06, 0x94,
	0x31, 0x5f, 0x82, 0x68, 0x9f, 0x79, 0x4f, 0x67, 0xa8, 0xb8, 0xc0, 0xd4, 0x09, 0x15, 0x70, 0xc3,
	0xbf, 0xe9, 0x44, 0x3e, 0xba, 0xfd, 0xdd, 0x8d, 0xc1, 0x98, 0xbb, 0x02, 0x39, 0x8d, 0xf8, 0x53,
	0x25, 0xa7, 0x11, 0xf9, 0xfd, 0x1c, 0x4c, 0xde, 0x72, 0x24, 0x7d, 0x3f, 0xed, 0x53, 0x68, 0x50,
	0x4a, 0x1c, 0xd4, 0x1f, 0x4a, 0x3d, 0x5b, 0x9d, 0xdc, 0xa3, 0x8c, 0xdb, 0x22, 0x0a, 0x5d, 0xf1,
	0x1a, 0x25, 0xce, 0x52, 0xfe, 0xbd, 0x00, 0xf1, 0x4b, 0x59, 0x83, 0xb1, 0xde, 0x95, 0xde, 0x0b,
	0x65, 0xe9, 0x37, 0x83, 0x93, 0x8a, 0xc5, 0xef, 0x92, 0x45, 0xda, 0xc4, 0xaf, 0x8c, 0xc9, 0xff,
	0x14, 0x82, 0xc3, 0x4b, 0x2c, 0x88, 0xee, 0xb3, 0x76, 0x60, 0xda, 0x59, 0x92, 0x8f, 0x05, 0x28,
	0x86, 0xb7, 0x42, 0xf6, 0x93, 0xeb, 0xa7, 0x29, 0xfb, 0x6a, 0x0e, 0x2a, 0xc9, 0x6b, 0x0e, 0xfb,
	0xbd, 0x92, 0x4e, 0x4b, 0xa9, 0xde, 0x14, 0xa0, 0x14, 0xbf, 0xd0, 0x39, 0x18, 0x1b, 0x88, 0x30,
	0x1a, 0x1c, 0xb0, 0xe6, 0x01, 0x38, 0xf8, 0x29, 0xbf, 0x23, 0xc0, 0x78, 0xcf, 0x39, 0xf1, 0x01,
	0x27, 0xd5, 0xdb, 0xcb, 0xf6, 0xb6, 0x00, 0xe5, 0xc4, 0x31, 0xef, 0x81, 0x55, 0x4f, 0xdb, 0xcb,
	0xf4, 0x6f, 0x01, 0x4a, 0xf1, 0xfb, 0x42, 0xfb, 0x69, 0xd6, 0xc6, 0xb4, 0x1e, 0x4a, 0x6a, 0xfd,
	0x3f, 0x01, 0xca, 0x89, 0x7b, 0x72, 0xfb, 0x2d, 0x3a, 0x6f, 0xaf, 0xfa, 0x1b, 0x39, 0x98, 0xbc,
	0xe5, 0xb2, 0xd3, 0x7e, 0x8f, 0x5c, 0xdb, 0x9b, 0xe3, 0xb5, 0x1c, 0x4c, 0xa5, 0xdd, 0xac, 0x19,
	0x70, 0xd0, 0xf8, 0xe4, 0x73, 0x77, 0xf9, 0x5d, 0x01, 0x0e, 0xa6, 0x5c, 0xef, 0x19, 0xb0, 0x21,
	0x8e, 0x41, 0x91, 0xdd, 0x4c, 0x8a, 0xd7, 0xa1, 0xf4, 0x01, 0xbb, 0x46, 0xf8, 0xe0, 0x8d, 0xbf,
	0xce, 0x1c, 0xf8, 0x59, 0x77, 0x46, 0xb8, 0xd1, 0x9d, 0x11, 0x3e, 0xe8, 0xce, 0x08, 0x1f, 0x76,
	0x67, 0x84, 0xbf, 0x74, 0x67, 0x84, 0x1f, 0x7d, 0x34, 0x73, 0xe0, 0x83, 0x8f, 0x66, 0x0e, 0x7c,
	0xf8, 0xd1, 0xcc, 0x81, 0xe7, 0xf3, 0x44, 0x6f, 0xd5, 0xeb, 0x23, 0xec, 0x1f, 0x92, 0x39, 0xf5,
	0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x79, 0xa6, 0x0f, 0x40, 0xe1, 0x46, 0x00, 0x00,
}

func (this *ElementProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto)
	if !ok {
		that2, ok := that.(ElementProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Database.Equal(that1.Database) {
		return false
	}
	if !this.Schema.Equal(that1.Schema) {
		return false
	}
	if !this.View.Equal(that1.View) {
		return false
	}
	if !this.Sequence.Equal(that1.Sequence) {
		return false
	}
	if !this.Table.Equal(that1.Table) {
		return false
	}
	if !this.EnumType.Equal(that1.EnumType) {
		return false
	}
	if !this.AliasType.Equal(that1.AliasType) {
		return false
	}
	if !this.ColumnFamily.Equal(that1.ColumnFamily) {
		return false
	}
	if !this.Column.Equal(that1.Column) {
		return false
	}
	if !this.PrimaryIndex.Equal(that1.PrimaryIndex) {
		return false
	}
	if !this.SecondaryIndex.Equal(that1.SecondaryIndex) {
		return false
	}
	if !this.TemporaryIndex.Equal(that1.TemporaryIndex) {
		return false
	}
	if !this.UniqueWithoutIndexConstraint.Equal(that1.UniqueWithoutIndexConstraint) {
		return false
	}
	if !this.CheckConstraint.Equal(that1.CheckConstraint) {
		return false
	}
	if !this.ForeignKeyConstraint.Equal(that1.ForeignKeyConstraint) {
		return false
	}
	if !this.TableComment.Equal(that1.TableComment) {
		return false
	}
	if !this.RowLevelTTL.Equal(that1.RowLevelTTL) {
		return false
	}
	if !this.LocalityGlobal.Equal(that1.LocalityGlobal) {
		return false
	}
	if !this.LocalityPrimaryRegion.Equal(that1.LocalityPrimaryRegion) {
		return false
	}
	if !this.LocalitySecondaryRegion.Equal(that1.LocalitySecondaryRegion) {
		return false
	}
	if !this.LocalityRegionalByRow.Equal(that1.LocalityRegionalByRow) {
		return false
	}
	if !this.ColumnName.Equal(that1.ColumnName) {
		return false
	}
	if !this.ColumnType.Equal(that1.ColumnType) {
		return false
	}
	if !this.ColumnDefaultExpression.Equal(that1.ColumnDefaultExpression) {
		return false
	}
	if !this.ColumnOnUpdateExpression.Equal(that1.ColumnOnUpdateExpression) {
		return false
	}
	if !this.SequenceOwner.Equal(that1.SequenceOwner) {
		return false
	}
	if !this.ColumnComment.Equal(that1.ColumnComment) {
		return false
	}
	if !this.IndexName.Equal(that1.IndexName) {
		return false
	}
	if !this.IndexPartitioning.Equal(that1.IndexPartitioning) {
		return false
	}
	if !this.SecondaryIndexPartial.Equal(that1.SecondaryIndexPartial) {
		return false
	}
	if !this.IndexComment.Equal(that1.IndexComment) {
		return false
	}
	if !this.ConstraintName.Equal(that1.ConstraintName) {
		return false
	}
	if !this.ConstraintComment.Equal(that1.ConstraintComment) {
		return false
	}
	if !this.Namespace.Equal(that1.Namespace) {
		return false
	}
	if !this.Owner.Equal(that1.Owner) {
		return false
	}
	if !this.UserPrivileges.Equal(that1.UserPrivileges) {
		return false
	}
	if !this.DatabaseRegionConfig.Equal(that1.DatabaseRegionConfig) {
		return false
	}
	if !this.DatabaseRoleSetting.Equal(that1.DatabaseRoleSetting) {
		return false
	}
	if !this.DatabaseComment.Equal(that1.DatabaseComment) {
		return false
	}
	if !this.SchemaParent.Equal(that1.SchemaParent) {
		return false
	}
	if !this.SchemaComment.Equal(that1.SchemaComment) {
		return false
	}
	if !this.ObjectParent.Equal(that1.ObjectParent) {
		return false
	}
	return true
}
func (this *TypeT) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TypeT)
	if !ok {
		that2, ok := that.(TypeT)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	if len(this.ClosedTypeIDs) != len(that1.ClosedTypeIDs) {
		return false
	}
	for i := range this.ClosedTypeIDs {
		if this.ClosedTypeIDs[i] != that1.ClosedTypeIDs[i] {
			return false
		}
	}
	return true
}
func (this *Expression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Expression)
	if !ok {
		that2, ok := that.(Expression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Expr != that1.Expr {
		return false
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesSequenceIDs) != len(that1.UsesSequenceIDs) {
		return false
	}
	for i := range this.UsesSequenceIDs {
		if this.UsesSequenceIDs[i] != that1.UsesSequenceIDs[i] {
			return false
		}
	}
	return true
}
func (this *Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column)
	if !ok {
		that2, ok := that.(Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.IsHidden != that1.IsHidden {
		return false
	}
	if this.IsInaccessible != that1.IsInaccessible {
		return false
	}
	if this.GeneratedAsIdentityType != that1.GeneratedAsIdentityType {
		return false
	}
	if this.GeneratedAsIdentitySequenceOption != that1.GeneratedAsIdentitySequenceOption {
		return false
	}
	if this.PgAttributeNum != that1.PgAttributeNum {
		return false
	}
	return true
}
func (this *ColumnType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnType)
	if !ok {
		that2, ok := that.(ColumnType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.FamilyID != that1.FamilyID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.TypeT.Equal(&that1.TypeT) {
		return false
	}
	if this.IsNullable != that1.IsNullable {
		return false
	}
	if !this.ComputeExpr.Equal(that1.ComputeExpr) {
		return false
	}
	if this.IsVirtual != that1.IsVirtual {
		return false
	}
	if this.IsRelationBeingDropped != that1.IsRelationBeingDropped {
		return false
	}
	return true
}
func (this *ColumnFamily) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnFamily)
	if !ok {
		that2, ok := that.(ColumnFamily)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.FamilyID != that1.FamilyID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Index) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Index)
	if !ok {
		that2, ok := that.(Index)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if len(this.KeyColumnIDs) != len(that1.KeyColumnIDs) {
		return false
	}
	for i := range this.KeyColumnIDs {
		if this.KeyColumnIDs[i] != that1.KeyColumnIDs[i] {
			return false
		}
	}
	if len(this.KeyColumnDirections) != len(that1.KeyColumnDirections) {
		return false
	}
	for i := range this.KeyColumnDirections {
		if this.KeyColumnDirections[i] != that1.KeyColumnDirections[i] {
			return false
		}
	}
	if len(this.KeySuffixColumnIDs) != len(that1.KeySuffixColumnIDs) {
		return false
	}
	for i := range this.KeySuffixColumnIDs {
		if this.KeySuffixColumnIDs[i] != that1.KeySuffixColumnIDs[i] {
			return false
		}
	}
	if len(this.StoringColumnIDs) != len(that1.StoringColumnIDs) {
		return false
	}
	for i := range this.StoringColumnIDs {
		if this.StoringColumnIDs[i] != that1.StoringColumnIDs[i] {
			return false
		}
	}
	if len(this.CompositeColumnIDs) != len(that1.CompositeColumnIDs) {
		return false
	}
	for i := range this.CompositeColumnIDs {
		if this.CompositeColumnIDs[i] != that1.CompositeColumnIDs[i] {
			return false
		}
	}
	if this.IsUnique != that1.IsUnique {
		return false
	}
	if this.IsInverted != that1.IsInverted {
		return false
	}
	if !this.Sharding.Equal(that1.Sharding) {
		return false
	}
	if this.IsConcurrently != that1.IsConcurrently {
		return false
	}
	if this.SourceIndexID != that1.SourceIndexID {
		return false
	}
	if this.TemporaryIndexID != that1.TemporaryIndexID {
		return false
	}
	return true
}
func (this *PrimaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrimaryIndex)
	if !ok {
		that2, ok := that.(PrimaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	return true
}
func (this *SecondaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecondaryIndex)
	if !ok {
		that2, ok := that.(SecondaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	return true
}
func (this *TemporaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TemporaryIndex)
	if !ok {
		that2, ok := that.(TemporaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	if this.IsUsingSecondaryEncoding != that1.IsUsingSecondaryEncoding {
		return false
	}
	return true
}
func (this *SecondaryIndexPartial) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecondaryIndexPartial)
	if !ok {
		that2, ok := that.(SecondaryIndexPartial)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	if this.IsRelationBeingDropped != that1.IsRelationBeingDropped {
		return false
	}
	return true
}
func (this *SchemaParent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaParent)
	if !ok {
		that2, ok := that.(SchemaParent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.ParentDatabaseID != that1.ParentDatabaseID {
		return false
	}
	return true
}
func (this *ObjectParent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectParent)
	if !ok {
		that2, ok := that.(ObjectParent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ObjectID != that1.ObjectID {
		return false
	}
	if this.ParentSchemaID != that1.ParentSchemaID {
		return false
	}
	return true
}
func (this *Sequence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sequence)
	if !ok {
		that2, ok := that.(Sequence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	return true
}
func (this *SequenceOwner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SequenceOwner)
	if !ok {
		that2, ok := that.(SequenceOwner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	return true
}
func (this *ColumnDefaultExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnDefaultExpression)
	if !ok {
		that2, ok := that.(ColumnDefaultExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *ColumnOnUpdateExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnOnUpdateExpression)
	if !ok {
		that2, ok := that.(ColumnOnUpdateExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *View) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*View)
	if !ok {
		that2, ok := that.(View)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ViewID != that1.ViewID {
		return false
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesRelationIDs) != len(that1.UsesRelationIDs) {
		return false
	}
	for i := range this.UsesRelationIDs {
		if this.UsesRelationIDs[i] != that1.UsesRelationIDs[i] {
			return false
		}
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	if this.IsMaterialized != that1.IsMaterialized {
		return false
	}
	return true
}
func (this *Table) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Table)
	if !ok {
		that2, ok := that.(Table)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	return true
}
func (this *UniqueWithoutIndexConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniqueWithoutIndexConstraint)
	if !ok {
		that2, ok := that.(UniqueWithoutIndexConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *CheckConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckConstraint)
	if !ok {
		that2, ok := that.(CheckConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *ForeignKeyConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForeignKeyConstraint)
	if !ok {
		that2, ok := that.(ForeignKeyConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.ReferencedTableID != that1.ReferencedTableID {
		return false
	}
	if len(this.ReferencedColumnIDs) != len(that1.ReferencedColumnIDs) {
		return false
	}
	for i := range this.ReferencedColumnIDs {
		if this.ReferencedColumnIDs[i] != that1.ReferencedColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *EnumType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EnumType)
	if !ok {
		that2, ok := that.(EnumType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if this.ArrayTypeID != that1.ArrayTypeID {
		return false
	}
	if this.IsMultiRegion != that1.IsMultiRegion {
		return false
	}
	return true
}
func (this *AliasType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AliasType)
	if !ok {
		that2, ok := that.(AliasType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if !this.TypeT.Equal(&that1.TypeT) {
		return false
	}
	return true
}
func (this *Schema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schema)
	if !ok {
		that2, ok := that.(Schema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	if this.IsPublic != that1.IsPublic {
		return false
	}
	if this.IsVirtual != that1.IsVirtual {
		return false
	}
	return true
}
func (this *Database) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Database)
	if !ok {
		that2, ok := that.(Database)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	return true
}
func (this *Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Namespace)
	if !ok {
		that2, ok := that.(Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Owner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Owner)
	if !ok {
		that2, ok := that.(Owner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	return true
}
func (this *UserPrivileges) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserPrivileges)
	if !ok {
		that2, ok := that.(UserPrivileges)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if this.Privileges != that1.Privileges {
		return false
	}
	return true
}
func (this *TableLocalityGlobal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityGlobal)
	if !ok {
		that2, ok := that.(TableLocalityGlobal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *TableLocalityPrimaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityPrimaryRegion)
	if !ok {
		that2, ok := that.(TableLocalityPrimaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *TableLocalitySecondaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalitySecondaryRegion)
	if !ok {
		that2, ok := that.(TableLocalitySecondaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.RegionEnumTypeID != that1.RegionEnumTypeID {
		return false
	}
	if this.RegionName != that1.RegionName {
		return false
	}
	return true
}
func (this *TableLocalityRegionalByRow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityRegionalByRow)
	if !ok {
		that2, ok := that.(TableLocalityRegionalByRow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.As != that1.As {
		return false
	}
	return true
}
func (this *IndexPartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexPartitioning)
	if !ok {
		that2, ok := that.(IndexPartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if !this.PartitioningDescriptor.Equal(&that1.PartitioningDescriptor) {
		return false
	}
	return true
}
func (this *RowLevelTTL) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowLevelTTL)
	if !ok {
		that2, ok := that.(RowLevelTTL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.RowLevelTTL.Equal(&that1.RowLevelTTL) {
		return false
	}
	return true
}
func (this *ColumnName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnName)
	if !ok {
		that2, ok := that.(ColumnName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *IndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexName)
	if !ok {
		that2, ok := that.(IndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *ConstraintName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintName)
	if !ok {
		that2, ok := that.(ConstraintName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *TableComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableComment)
	if !ok {
		that2, ok := that.(TableComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *DatabaseComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseComment)
	if !ok {
		that2, ok := that.(DatabaseComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *SchemaComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaComment)
	if !ok {
		that2, ok := that.(SchemaComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *IndexComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexComment)
	if !ok {
		that2, ok := that.(IndexComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *ColumnComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnComment)
	if !ok {
		that2, ok := that.(ColumnComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *ConstraintComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintComment)
	if !ok {
		that2, ok := that.(ConstraintComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *DatabaseRegionConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseRegionConfig)
	if !ok {
		that2, ok := that.(DatabaseRegionConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.RegionEnumTypeID != that1.RegionEnumTypeID {
		return false
	}
	return true
}
func (this *DatabaseRoleSetting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseRoleSetting)
	if !ok {
		that2, ok := that.(DatabaseRoleSetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.RoleName != that1.RoleName {
		return false
	}
	return true
}
func (m *ElementProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElementProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LocalityRegionalByRow != nil {
		{
			size, err := m.LocalityRegionalByRow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x8a
	}
	if m.LocalitySecondaryRegion != nil {
		{
			size, err := m.LocalitySecondaryRegion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x82
	}
	if m.LocalityPrimaryRegion != nil {
		{
			size, err := m.LocalityPrimaryRegion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xfa
	}
	if m.LocalityGlobal != nil {
		{
			size, err := m.LocalityGlobal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf2
	}
	if m.ObjectParent != nil {
		{
			size, err := m.ObjectParent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.SchemaComment != nil {
		{
			size, err := m.SchemaComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xda
	}
	if m.SchemaParent != nil {
		{
			size, err := m.SchemaParent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd2
	}
	if m.DatabaseComment != nil {
		{
			size, err := m.DatabaseComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x92
	}
	if m.DatabaseRoleSetting != nil {
		{
			size, err := m.DatabaseRoleSetting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x8a
	}
	if m.DatabaseRegionConfig != nil {
		{
			size, err := m.DatabaseRegionConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	if m.UserPrivileges != nil {
		{
			size, err := m.UserPrivileges.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf2
	}
	if m.Owner != nil {
		{
			size, err := m.Owner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xea
	}
	if m.Namespace != nil {
		{
			size, err := m.Namespace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if m.ConstraintComment != nil {
		{
			size, err := m.ConstraintComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	if m.ConstraintName != nil {
		{
			size, err := m.ConstraintName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if m.IndexComment != nil {
		{
			size, err := m.IndexComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if m.SecondaryIndexPartial != nil {
		{
			size, err := m.SecondaryIndexPartial.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if m.IndexPartitioning != nil {
		{
			size, err := m.IndexPartitioning.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.IndexName != nil {
		{
			size, err := m.IndexName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.ColumnComment != nil {
		{
			size, err := m.ColumnComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.SequenceOwner != nil {
		{
			size, err := m.SequenceOwner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.ColumnOnUpdateExpression != nil {
		{
			size, err := m.ColumnOnUpdateExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.ColumnDefaultExpression != nil {
		{
			size, err := m.ColumnDefaultExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.ColumnType != nil {
		{
			size, err := m.ColumnType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.ColumnName != nil {
		{
			size, err := m.ColumnName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.RowLevelTTL != nil {
		{
			size, err := m.RowLevelTTL.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.TableComment != nil {
		{
			size, err := m.TableComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.ForeignKeyConstraint != nil {
		{
			size, err := m.ForeignKeyConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.CheckConstraint != nil {
		{
			size, err := m.CheckConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.UniqueWithoutIndexConstraint != nil {
		{
			size, err := m.UniqueWithoutIndexConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.TemporaryIndex != nil {
		{
			size, err := m.TemporaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.SecondaryIndex != nil {
		{
			size, err := m.SecondaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.PrimaryIndex != nil {
		{
			size, err := m.PrimaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Column != nil {
		{
			size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ColumnFamily != nil {
		{
			size, err := m.ColumnFamily.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.AliasType != nil {
		{
			size, err := m.AliasType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.EnumType != nil {
		{
			size, err := m.EnumType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Table != nil {
		{
			size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Sequence != nil {
		{
			size, err := m.Sequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.View != nil {
		{
			size, err := m.View.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Schema != nil {
		{
			size, err := m.Schema.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Database != nil {
		{
			size, err := m.Database.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TypeT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClosedTypeIDs) > 0 {
		dAtA44 := make([]byte, len(m.ClosedTypeIDs)*10)
		var j43 int
		for _, num := range m.ClosedTypeIDs {
			for num >= 1<<7 {
				dAtA44[j43] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j43++
			}
			dAtA44[j43] = uint8(num)
			j43++
		}
		i -= j43
		copy(dAtA[i:], dAtA44[:j43])
		i = encodeVarintElements(dAtA, i, uint64(j43))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsesSequenceIDs) > 0 {
		dAtA47 := make([]byte, len(m.UsesSequenceIDs)*10)
		var j46 int
		for _, num := range m.UsesSequenceIDs {
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		i -= j46
		copy(dAtA[i:], dAtA47[:j46])
		i = encodeVarintElements(dAtA, i, uint64(j46))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UsesTypeIDs) > 0 {
		dAtA49 := make([]byte, len(m.UsesTypeIDs)*10)
		var j48 int
		for _, num := range m.UsesTypeIDs {
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		i -= j48
		copy(dAtA[i:], dAtA49[:j48])
		i = encodeVarintElements(dAtA, i, uint64(j48))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Expr) > 0 {
		i -= len(m.Expr)
		copy(dAtA[i:], m.Expr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Expr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PgAttributeNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PgAttributeNum))
		i--
		dAtA[i] = 0x38
	}
	if len(m.GeneratedAsIdentitySequenceOption) > 0 {
		i -= len(m.GeneratedAsIdentitySequenceOption)
		copy(dAtA[i:], m.GeneratedAsIdentitySequenceOption)
		i = encodeVarintElements(dAtA, i, uint64(len(m.GeneratedAsIdentitySequenceOption)))
		i--
		dAtA[i] = 0x32
	}
	if m.GeneratedAsIdentityType != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.GeneratedAsIdentityType))
		i--
		dAtA[i] = 0x28
	}
	if m.IsInaccessible {
		i--
		if m.IsInaccessible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsHidden {
		i--
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsRelationBeingDropped {
		i--
		if m.IsRelationBeingDropped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.IsVirtual {
		i--
		if m.IsVirtual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ComputeExpr != nil {
		{
			size, err := m.ComputeExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IsNullable {
		i--
		if m.IsNullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.TypeT.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.FamilyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FamilyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnFamily) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnFamily) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnFamily) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FamilyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FamilyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Index) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Index) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TemporaryIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TemporaryIndexID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.SourceIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SourceIndexID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.IsConcurrently {
		i--
		if m.IsConcurrently {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Sharding != nil {
		{
			size, err := m.Sharding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.IsInverted {
		i--
		if m.IsInverted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsUnique {
		i--
		if m.IsUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.CompositeColumnIDs) > 0 {
		dAtA54 := make([]byte, len(m.CompositeColumnIDs)*10)
		var j53 int
		for _, num := range m.CompositeColumnIDs {
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA54[:j53])
		i = encodeVarintElements(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StoringColumnIDs) > 0 {
		dAtA56 := make([]byte, len(m.StoringColumnIDs)*10)
		var j55 int
		for _, num := range m.StoringColumnIDs {
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintElements(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0x32
	}
	if len(m.KeySuffixColumnIDs) > 0 {
		dAtA58 := make([]byte, len(m.KeySuffixColumnIDs)*10)
		var j57 int
		for _, num := range m.KeySuffixColumnIDs {
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		i -= j57
		copy(dAtA[i:], dAtA58[:j57])
		i = encodeVarintElements(dAtA, i, uint64(j57))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyColumnDirections) > 0 {
		dAtA60 := make([]byte, len(m.KeyColumnDirections)*10)
		var j59 int
		for _, num := range m.KeyColumnDirections {
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		i -= j59
		copy(dAtA[i:], dAtA60[:j59])
		i = encodeVarintElements(dAtA, i, uint64(j59))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyColumnIDs) > 0 {
		dAtA62 := make([]byte, len(m.KeyColumnIDs)*10)
		var j61 int
		for _, num := range m.KeyColumnIDs {
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintElements(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SecondaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TemporaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TemporaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TemporaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsUsingSecondaryEncoding {
		i--
		if m.IsUsingSecondaryEncoding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SecondaryIndexPartial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondaryIndexPartial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondaryIndexPartial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsRelationBeingDropped {
		i--
		if m.IsRelationBeingDropped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaParent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaParent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaParent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ParentDatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ParentDatabaseID))
		i--
		dAtA[i] = 0x10
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectParent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectParent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectParent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ParentSchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ParentSchemaID))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SequenceOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x10
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnDefaultExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnDefaultExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnDefaultExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnOnUpdateExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOnUpdateExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnOnUpdateExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *View) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *View) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMaterialized {
		i--
		if m.IsMaterialized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.UsesRelationIDs) > 0 {
		dAtA70 := make([]byte, len(m.UsesRelationIDs)*10)
		var j69 int
		for _, num := range m.UsesRelationIDs {
			for num >= 1<<7 {
				dAtA70[j69] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j69++
			}
			dAtA70[j69] = uint8(num)
			j69++
		}
		i -= j69
		copy(dAtA[i:], dAtA70[:j69])
		i = encodeVarintElements(dAtA, i, uint64(j69))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UsesTypeIDs) > 0 {
		dAtA72 := make([]byte, len(m.UsesTypeIDs)*10)
		var j71 int
		for _, num := range m.UsesTypeIDs {
			for num >= 1<<7 {
				dAtA72[j71] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j71++
			}
			dAtA72[j71] = uint8(num)
			j71++
		}
		i -= j71
		copy(dAtA[i:], dAtA72[:j71])
		i = encodeVarintElements(dAtA, i, uint64(j71))
		i--
		dAtA[i] = 0x12
	}
	if m.ViewID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ViewID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UniqueWithoutIndexConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniqueWithoutIndexConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniqueWithoutIndexConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		dAtA74 := make([]byte, len(m.ColumnIDs)*10)
		var j73 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA74[j73] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j73++
			}
			dAtA74[j73] = uint8(num)
			j73++
		}
		i -= j73
		copy(dAtA[i:], dAtA74[:j73])
		i = encodeVarintElements(dAtA, i, uint64(j73))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ColumnIDs) > 0 {
		dAtA77 := make([]byte, len(m.ColumnIDs)*10)
		var j76 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA77[j76] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j76++
			}
			dAtA77[j76] = uint8(num)
			j76++
		}
		i -= j76
		copy(dAtA[i:], dAtA77[:j76])
		i = encodeVarintElements(dAtA, i, uint64(j76))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReferencedColumnIDs) > 0 {
		dAtA79 := make([]byte, len(m.ReferencedColumnIDs)*10)
		var j78 int
		for _, num := range m.ReferencedColumnIDs {
			for num >= 1<<7 {
				dAtA79[j78] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j78++
			}
			dAtA79[j78] = uint8(num)
			j78++
		}
		i -= j78
		copy(dAtA[i:], dAtA79[:j78])
		i = encodeVarintElements(dAtA, i, uint64(j78))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReferencedTableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ReferencedTableID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ColumnIDs) > 0 {
		dAtA81 := make([]byte, len(m.ColumnIDs)*10)
		var j80 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA81[j80] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j80++
			}
			dAtA81[j80] = uint8(num)
			j80++
		}
		i -= j80
		copy(dAtA[i:], dAtA81[:j80])
		i = encodeVarintElements(dAtA, i, uint64(j80))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnumType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnumType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMultiRegion {
		i--
		if m.IsMultiRegion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ArrayTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ArrayTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AliasType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliasType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TypeT.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsVirtual {
		i--
		if m.IsVirtual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.IsPublic {
		i--
		if m.IsPublic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Database) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Database) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Database) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x18
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x10
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Owner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Owner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Owner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserPrivileges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPrivileges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPrivileges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Privileges != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Privileges))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityGlobal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityGlobal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityGlobal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityPrimaryRegion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityPrimaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityPrimaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalitySecondaryRegion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalitySecondaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalitySecondaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegionName) > 0 {
		i -= len(m.RegionName)
		copy(dAtA[i:], m.RegionName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.RegionName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RegionEnumTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RegionEnumTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityRegionalByRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityRegionalByRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityRegionalByRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.As) > 0 {
		i -= len(m.As)
		copy(dAtA[i:], m.As)
		i = encodeVarintElements(dAtA, i, uint64(len(m.As)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexPartitioning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexPartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexPartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PartitioningDescriptor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowLevelTTL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowLevelTTL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowLevelTTL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RowLevelTTL.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseRegionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseRegionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseRegionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegionEnumTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RegionEnumTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseRoleSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseRoleSetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseRoleSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoleName) > 0 {
		i -= len(m.RoleName)
		copy(dAtA[i:], m.RoleName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.RoleName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintElements(dAtA []byte, offset int, v uint64) int {
	offset -= sovElements(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ElementProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.View != nil {
		l = m.View.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Sequence != nil {
		l = m.Sequence.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.EnumType != nil {
		l = m.EnumType.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.AliasType != nil {
		l = m.AliasType.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.ColumnFamily != nil {
		l = m.ColumnFamily.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Column != nil {
		l = m.Column.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.PrimaryIndex != nil {
		l = m.PrimaryIndex.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.SecondaryIndex != nil {
		l = m.SecondaryIndex.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.TemporaryIndex != nil {
		l = m.TemporaryIndex.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.UniqueWithoutIndexConstraint != nil {
		l = m.UniqueWithoutIndexConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.CheckConstraint != nil {
		l = m.CheckConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ForeignKeyConstraint != nil {
		l = m.ForeignKeyConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.TableComment != nil {
		l = m.TableComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.RowLevelTTL != nil {
		l = m.RowLevelTTL.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ColumnName != nil {
		l = m.ColumnName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ColumnType != nil {
		l = m.ColumnType.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ColumnDefaultExpression != nil {
		l = m.ColumnDefaultExpression.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ColumnOnUpdateExpression != nil {
		l = m.ColumnOnUpdateExpression.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.SequenceOwner != nil {
		l = m.SequenceOwner.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ColumnComment != nil {
		l = m.ColumnComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.IndexName != nil {
		l = m.IndexName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.IndexPartitioning != nil {
		l = m.IndexPartitioning.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.SecondaryIndexPartial != nil {
		l = m.SecondaryIndexPartial.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.IndexComment != nil {
		l = m.IndexComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ConstraintName != nil {
		l = m.ConstraintName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ConstraintComment != nil {
		l = m.ConstraintComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Namespace != nil {
		l = m.Namespace.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.UserPrivileges != nil {
		l = m.UserPrivileges.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.DatabaseRegionConfig != nil {
		l = m.DatabaseRegionConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.DatabaseRoleSetting != nil {
		l = m.DatabaseRoleSetting.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.DatabaseComment != nil {
		l = m.DatabaseComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.SchemaParent != nil {
		l = m.SchemaParent.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.SchemaComment != nil {
		l = m.SchemaComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ObjectParent != nil {
		l = m.ObjectParent.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.LocalityGlobal != nil {
		l = m.LocalityGlobal.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.LocalityPrimaryRegion != nil {
		l = m.LocalityPrimaryRegion.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.LocalitySecondaryRegion != nil {
		l = m.LocalitySecondaryRegion.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.LocalityRegionalByRow != nil {
		l = m.LocalityRegionalByRow.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TypeT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.ClosedTypeIDs) > 0 {
		l = 0
		for _, e := range m.ClosedTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *Expression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Expr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesSequenceIDs) > 0 {
		l = 0
		for _, e := range m.UsesSequenceIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.IsHidden {
		n += 2
	}
	if m.IsInaccessible {
		n += 2
	}
	if m.GeneratedAsIdentityType != 0 {
		n += 1 + sovElements(uint64(m.GeneratedAsIdentityType))
	}
	l = len(m.GeneratedAsIdentitySequenceOption)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.PgAttributeNum != 0 {
		n += 1 + sovElements(uint64(m.PgAttributeNum))
	}
	return n
}

func (m *ColumnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.FamilyID != 0 {
		n += 1 + sovElements(uint64(m.FamilyID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.TypeT.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.IsNullable {
		n += 2
	}
	if m.ComputeExpr != nil {
		l = m.ComputeExpr.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.IsVirtual {
		n += 2
	}
	if m.IsRelationBeingDropped {
		n += 2
	}
	return n
}

func (m *ColumnFamily) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.FamilyID != 0 {
		n += 1 + sovElements(uint64(m.FamilyID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if len(m.KeyColumnIDs) > 0 {
		l = 0
		for _, e := range m.KeyColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.KeyColumnDirections) > 0 {
		l = 0
		for _, e := range m.KeyColumnDirections {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.KeySuffixColumnIDs) > 0 {
		l = 0
		for _, e := range m.KeySuffixColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.StoringColumnIDs) > 0 {
		l = 0
		for _, e := range m.StoringColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.CompositeColumnIDs) > 0 {
		l = 0
		for _, e := range m.CompositeColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.IsUnique {
		n += 2
	}
	if m.IsInverted {
		n += 2
	}
	if m.Sharding != nil {
		l = m.Sharding.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.IsConcurrently {
		n += 3
	}
	if m.SourceIndexID != 0 {
		n += 2 + sovElements(uint64(m.SourceIndexID))
	}
	if m.TemporaryIndexID != 0 {
		n += 2 + sovElements(uint64(m.TemporaryIndexID))
	}
	return n
}

func (m *PrimaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Index.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *SecondaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Index.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *TemporaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Index.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.IsUsingSecondaryEncoding {
		n += 2
	}
	return n
}

func (m *SecondaryIndexPartial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.IsRelationBeingDropped {
		n += 2
	}
	return n
}

func (m *SchemaParent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.ParentDatabaseID != 0 {
		n += 1 + sovElements(uint64(m.ParentDatabaseID))
	}
	return n
}

func (m *ObjectParent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectID != 0 {
		n += 1 + sovElements(uint64(m.ObjectID))
	}
	if m.ParentSchemaID != 0 {
		n += 1 + sovElements(uint64(m.ParentSchemaID))
	}
	return n
}

func (m *Sequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	if m.IsTemporary {
		n += 2
	}
	return n
}

func (m *SequenceOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	return n
}

func (m *ColumnDefaultExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *ColumnOnUpdateExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *View) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ViewID != 0 {
		n += 1 + sovElements(uint64(m.ViewID))
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesRelationIDs) > 0 {
		l = 0
		for _, e := range m.UsesRelationIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.IsTemporary {
		n += 2
	}
	if m.IsMaterialized {
		n += 2
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IsTemporary {
		n += 2
	}
	return n
}

func (m *UniqueWithoutIndexConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *CheckConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *ForeignKeyConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.ReferencedTableID != 0 {
		n += 1 + sovElements(uint64(m.ReferencedTableID))
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l = 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *EnumType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	if m.ArrayTypeID != 0 {
		n += 1 + sovElements(uint64(m.ArrayTypeID))
	}
	if m.IsMultiRegion {
		n += 2
	}
	return n
}

func (m *AliasType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	l = m.TypeT.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.IsTemporary {
		n += 2
	}
	if m.IsPublic {
		n += 2
	}
	if m.IsVirtual {
		n += 2
	}
	return n
}

func (m *Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	return n
}

func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Owner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *UserPrivileges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Privileges != 0 {
		n += 1 + sovElements(uint64(m.Privileges))
	}
	return n
}

func (m *TableLocalityGlobal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *TableLocalityPrimaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *TableLocalitySecondaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.RegionEnumTypeID != 0 {
		n += 1 + sovElements(uint64(m.RegionEnumTypeID))
	}
	l = len(m.RegionName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TableLocalityRegionalByRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = len(m.As)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexPartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = m.PartitioningDescriptor.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *RowLevelTTL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = m.RowLevelTTL.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *ColumnName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ConstraintName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TableComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DatabaseComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *SchemaComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ColumnComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ConstraintComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DatabaseRegionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if m.RegionEnumTypeID != 0 {
		n += 1 + sovElements(uint64(m.RegionEnumTypeID))
	}
	return n
}

func (m *DatabaseRoleSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	l = len(m.RoleName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func sovElements(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozElements(x uint64) (n int) {
	return sovElements(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ElementProto) GetValue() interface{} {
	if this.Database != nil {
		return this.Database
	}
	if this.Schema != nil {
		return this.Schema
	}
	if this.View != nil {
		return this.View
	}
	if this.Sequence != nil {
		return this.Sequence
	}
	if this.Table != nil {
		return this.Table
	}
	if this.EnumType != nil {
		return this.EnumType
	}
	if this.AliasType != nil {
		return this.AliasType
	}
	if this.ColumnFamily != nil {
		return this.ColumnFamily
	}
	if this.Column != nil {
		return this.Column
	}
	if this.PrimaryIndex != nil {
		return this.PrimaryIndex
	}
	if this.SecondaryIndex != nil {
		return this.SecondaryIndex
	}
	if this.TemporaryIndex != nil {
		return this.TemporaryIndex
	}
	if this.UniqueWithoutIndexConstraint != nil {
		return this.UniqueWithoutIndexConstraint
	}
	if this.CheckConstraint != nil {
		return this.CheckConstraint
	}
	if this.ForeignKeyConstraint != nil {
		return this.ForeignKeyConstraint
	}
	if this.TableComment != nil {
		return this.TableComment
	}
	if this.RowLevelTTL != nil {
		return this.RowLevelTTL
	}
	if this.ColumnName != nil {
		return this.ColumnName
	}
	if this.ColumnType != nil {
		return this.ColumnType
	}
	if this.ColumnDefaultExpression != nil {
		return this.ColumnDefaultExpression
	}
	if this.ColumnOnUpdateExpression != nil {
		return this.ColumnOnUpdateExpression
	}
	if this.SequenceOwner != nil {
		return this.SequenceOwner
	}
	if this.ColumnComment != nil {
		return this.ColumnComment
	}
	if this.IndexName != nil {
		return this.IndexName
	}
	if this.IndexPartitioning != nil {
		return this.IndexPartitioning
	}
	if this.SecondaryIndexPartial != nil {
		return this.SecondaryIndexPartial
	}
	if this.IndexComment != nil {
		return this.IndexComment
	}
	if this.ConstraintName != nil {
		return this.ConstraintName
	}
	if this.ConstraintComment != nil {
		return this.ConstraintComment
	}
	if this.Namespace != nil {
		return this.Namespace
	}
	if this.Owner != nil {
		return this.Owner
	}
	if this.UserPrivileges != nil {
		return this.UserPrivileges
	}
	if this.DatabaseRegionConfig != nil {
		return this.DatabaseRegionConfig
	}
	if this.DatabaseRoleSetting != nil {
		return this.DatabaseRoleSetting
	}
	if this.DatabaseComment != nil {
		return this.DatabaseComment
	}
	if this.SchemaParent != nil {
		return this.SchemaParent
	}
	if this.SchemaComment != nil {
		return this.SchemaComment
	}
	if this.ObjectParent != nil {
		return this.ObjectParent
	}
	if this.LocalityGlobal != nil {
		return this.LocalityGlobal
	}
	if this.LocalityPrimaryRegion != nil {
		return this.LocalityPrimaryRegion
	}
	if this.LocalitySecondaryRegion != nil {
		return this.LocalitySecondaryRegion
	}
	if this.LocalityRegionalByRow != nil {
		return this.LocalityRegionalByRow
	}
	return nil
}

func (this *ElementProto) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Database:
		this.Database = vt
	case *Schema:
		this.Schema = vt
	case *View:
		this.View = vt
	case *Sequence:
		this.Sequence = vt
	case *Table:
		this.Table = vt
	case *EnumType:
		this.EnumType = vt
	case *AliasType:
		this.AliasType = vt
	case *ColumnFamily:
		this.ColumnFamily = vt
	case *Column:
		this.Column = vt
	case *PrimaryIndex:
		this.PrimaryIndex = vt
	case *SecondaryIndex:
		this.SecondaryIndex = vt
	case *TemporaryIndex:
		this.TemporaryIndex = vt
	case *UniqueWithoutIndexConstraint:
		this.UniqueWithoutIndexConstraint = vt
	case *CheckConstraint:
		this.CheckConstraint = vt
	case *ForeignKeyConstraint:
		this.ForeignKeyConstraint = vt
	case *TableComment:
		this.TableComment = vt
	case *RowLevelTTL:
		this.RowLevelTTL = vt
	case *ColumnName:
		this.ColumnName = vt
	case *ColumnType:
		this.ColumnType = vt
	case *ColumnDefaultExpression:
		this.ColumnDefaultExpression = vt
	case *ColumnOnUpdateExpression:
		this.ColumnOnUpdateExpression = vt
	case *SequenceOwner:
		this.SequenceOwner = vt
	case *ColumnComment:
		this.ColumnComment = vt
	case *IndexName:
		this.IndexName = vt
	case *IndexPartitioning:
		this.IndexPartitioning = vt
	case *SecondaryIndexPartial:
		this.SecondaryIndexPartial = vt
	case *IndexComment:
		this.IndexComment = vt
	case *ConstraintName:
		this.ConstraintName = vt
	case *ConstraintComment:
		this.ConstraintComment = vt
	case *Namespace:
		this.Namespace = vt
	case *Owner:
		this.Owner = vt
	case *UserPrivileges:
		this.UserPrivileges = vt
	case *DatabaseRegionConfig:
		this.DatabaseRegionConfig = vt
	case *DatabaseRoleSetting:
		this.DatabaseRoleSetting = vt
	case *DatabaseComment:
		this.DatabaseComment = vt
	case *SchemaParent:
		this.SchemaParent = vt
	case *SchemaComment:
		this.SchemaComment = vt
	case *ObjectParent:
		this.ObjectParent = vt
	case *TableLocalityGlobal:
		this.LocalityGlobal = vt
	case *TableLocalityPrimaryRegion:
		this.LocalityPrimaryRegion = vt
	case *TableLocalitySecondaryRegion:
		this.LocalitySecondaryRegion = vt
	case *TableLocalityRegionalByRow:
		this.LocalityRegionalByRow = vt
	default:
		return false
	}
	return true
}
func (m *ElementProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElementProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElementProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Database == nil {
				m.Database = &Database{}
			}
			if err := m.Database.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &Schema{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.View == nil {
				m.View = &View{}
			}
			if err := m.View.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sequence == nil {
				m.Sequence = &Sequence{}
			}
			if err := m.Sequence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Table == nil {
				m.Table = &Table{}
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnumType == nil {
				m.EnumType = &EnumType{}
			}
			if err := m.EnumType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AliasType == nil {
				m.AliasType = &AliasType{}
			}
			if err := m.AliasType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnFamily", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnFamily == nil {
				m.ColumnFamily = &ColumnFamily{}
			}
			if err := m.ColumnFamily.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Column == nil {
				m.Column = &Column{}
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimaryIndex == nil {
				m.PrimaryIndex = &PrimaryIndex{}
			}
			if err := m.PrimaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecondaryIndex == nil {
				m.SecondaryIndex = &SecondaryIndex{}
			}
			if err := m.SecondaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemporaryIndex == nil {
				m.TemporaryIndex = &TemporaryIndex{}
			}
			if err := m.TemporaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueWithoutIndexConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UniqueWithoutIndexConstraint == nil {
				m.UniqueWithoutIndexConstraint = &UniqueWithoutIndexConstraint{}
			}
			if err := m.UniqueWithoutIndexConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckConstraint == nil {
				m.CheckConstraint = &CheckConstraint{}
			}
			if err := m.CheckConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignKeyConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForeignKeyConstraint == nil {
				m.ForeignKeyConstraint = &ForeignKeyConstraint{}
			}
			if err := m.ForeignKeyConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableComment == nil {
				m.TableComment = &TableComment{}
			}
			if err := m.TableComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowLevelTTL == nil {
				m.RowLevelTTL = &RowLevelTTL{}
			}
			if err := m.RowLevelTTL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnName == nil {
				m.ColumnName = &ColumnName{}
			}
			if err := m.ColumnName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnType == nil {
				m.ColumnType = &ColumnType{}
			}
			if err := m.ColumnType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnDefaultExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnDefaultExpression == nil {
				m.ColumnDefaultExpression = &ColumnDefaultExpression{}
			}
			if err := m.ColumnDefaultExpression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnOnUpdateExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnOnUpdateExpression == nil {
				m.ColumnOnUpdateExpression = &ColumnOnUpdateExpression{}
			}
			if err := m.ColumnOnUpdateExpression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceOwner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SequenceOwner == nil {
				m.SequenceOwner = &SequenceOwner{}
			}
			if err := m.SequenceOwner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnComment == nil {
				m.ColumnComment = &ColumnComment{}
			}
			if err := m.ColumnComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexName == nil {
				m.IndexName = &IndexName{}
			}
			if err := m.IndexName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPartitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexPartitioning == nil {
				m.IndexPartitioning = &IndexPartitioning{}
			}
			if err := m.IndexPartitioning.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIndexPartial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecondaryIndexPartial == nil {
				m.SecondaryIndexPartial = &SecondaryIndexPartial{}
			}
			if err := m.SecondaryIndexPartial.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexComment == nil {
				m.IndexComment = &IndexComment{}
			}
			if err := m.IndexComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConstraintName == nil {
				m.ConstraintName = &ConstraintName{}
			}
			if err := m.ConstraintName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConstraintComment == nil {
				m.ConstraintComment = &ConstraintComment{}
			}
			if err := m.ConstraintComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Namespace == nil {
				m.Namespace = &Namespace{}
			}
			if err := m.Namespace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &Owner{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPrivileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPrivileges == nil {
				m.UserPrivileges = &UserPrivileges{}
			}
			if err := m.UserPrivileges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseRegionConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatabaseRegionConfig == nil {
				m.DatabaseRegionConfig = &DatabaseRegionConfig{}
			}
			if err := m.DatabaseRegionConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseRoleSetting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatabaseRoleSetting == nil {
				m.DatabaseRoleSetting = &DatabaseRoleSetting{}
			}
			if err := m.DatabaseRoleSetting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 82:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatabaseComment == nil {
				m.DatabaseComment = &DatabaseComment{}
			}
			if err := m.DatabaseComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaParent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaParent == nil {
				m.SchemaParent = &SchemaParent{}
			}
			if err := m.SchemaParent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 91:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaComment == nil {
				m.SchemaComment = &SchemaComment{}
			}
			if err := m.SchemaComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectParent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectParent == nil {
				m.ObjectParent = &ObjectParent{}
			}
			if err := m.ObjectParent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 110:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityGlobal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalityGlobal == nil {
				m.LocalityGlobal = &TableLocalityGlobal{}
			}
			if err := m.LocalityGlobal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 111:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityPrimaryRegion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalityPrimaryRegion == nil {
				m.LocalityPrimaryRegion = &TableLocalityPrimaryRegion{}
			}
			if err := m.LocalityPrimaryRegion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalitySecondaryRegion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalitySecondaryRegion == nil {
				m.LocalitySecondaryRegion = &TableLocalitySecondaryRegion{}
			}
			if err := m.LocalitySecondaryRegion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityRegionalByRow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalityRegionalByRow == nil {
				m.LocalityRegionalByRow = &TableLocalityRegionalByRow{}
			}
			if err := m.LocalityRegionalByRow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &types.T{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ClosedTypeIDs = append(m.ClosedTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ClosedTypeIDs) == 0 {
					m.ClosedTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ClosedTypeIDs = append(m.ClosedTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTypeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.Expression(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesTypeIDs) == 0 {
					m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesSequenceIDs) == 0 {
					m.UsesSequenceIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSequenceIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInaccessible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInaccessible = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAsIdentityType", wireType)
			}
			m.GeneratedAsIdentityType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeneratedAsIdentityType |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.GeneratedAsIdentityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAsIdentitySequenceOption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedAsIdentitySequenceOption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgAttributeNum", wireType)
			}
			m.PgAttributeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgAttributeNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyID", wireType)
			}
			m.FamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FamilyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNullable = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ComputeExpr == nil {
				m.ComputeExpr = &Expression{}
			}
			if err := m.ComputeExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVirtual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVirtual = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRelationBeingDropped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRelationBeingDropped = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnFamily) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnFamily: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnFamily: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyID", wireType)
			}
			m.FamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FamilyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyColumnIDs = append(m.KeyColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeyColumnIDs) == 0 {
					m.KeyColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyColumnIDs = append(m.KeyColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyColumnIDs", wireType)
			}
		case 4:
			if wireType == 0 {
				var v Index_Direction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Index_Direction(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyColumnDirections = append(m.KeyColumnDirections, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.KeyColumnDirections) == 0 {
					m.KeyColumnDirections = make([]Index_Direction, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Index_Direction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Index_Direction(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyColumnDirections = append(m.KeyColumnDirections, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyColumnDirections", wireType)
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeySuffixColumnIDs = append(m.KeySuffixColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeySuffixColumnIDs) == 0 {
					m.KeySuffixColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeySuffixColumnIDs = append(m.KeySuffixColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySuffixColumnIDs", wireType)
			}
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoringColumnIDs = append(m.StoringColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StoringColumnIDs) == 0 {
					m.StoringColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoringColumnIDs = append(m.StoringColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoringColumnIDs", wireType)
			}
		case 7:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CompositeColumnIDs = append(m.CompositeColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CompositeColumnIDs) == 0 {
					m.CompositeColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CompositeColumnIDs = append(m.CompositeColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeColumnIDs", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnique = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInverted = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sharding == nil {
				m.Sharding = &catpb.ShardedDescriptor{}
			}
			if err := m.Sharding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConcurrently", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConcurrently = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIndexID", wireType)
			}
			m.SourceIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryIndexID", wireType)
			}
			m.TemporaryIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemporaryIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TemporaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TemporaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TemporaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUsingSecondaryEncoding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUsingSecondaryEncoding = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondaryIndexPartial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondaryIndexPartial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondaryIndexPartial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRelationBeingDropped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRelationBeingDropped = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaParent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaParent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaParent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentDatabaseID", wireType)
			}
			m.ParentDatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentDatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectParent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectParent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectParent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentSchemaID", wireType)
			}
			m.ParentSchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentSchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnDefaultExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnDefaultExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnDefaultExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOnUpdateExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOnUpdateExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOnUpdateExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewID", wireType)
			}
			m.ViewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesTypeIDs) == 0 {
					m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesRelationIDs = append(m.UsesRelationIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesRelationIDs) == 0 {
					m.UsesRelationIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesRelationIDs = append(m.UsesRelationIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesRelationIDs", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMaterialized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMaterialized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniqueWithoutIndexConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedTableID", wireType)
			}
			m.ReferencedTableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferencedTableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReferencedColumnIDs) == 0 {
					m.ReferencedColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayTypeID", wireType)
			}
			m.ArrayTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArrayTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMultiRegion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMultiRegion = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliasType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliasType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliasType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPublic = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVirtual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVirtual = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Database) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Database: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Database: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Owner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Owner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Owner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPrivileges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPrivileges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPrivileges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			m.Privileges = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Privileges |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityGlobal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityGlobal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityGlobal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityPrimaryRegion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityPrimaryRegion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityPrimaryRegion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalitySecondaryRegion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalitySecondaryRegion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalitySecondaryRegion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEnumTypeID", wireType)
			}
			m.RegionEnumTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionEnumTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionName = github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityRegionalByRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityRegionalByRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityRegionalByRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.As = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexPartitioning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexPartitioning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexPartitioning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitioningDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartitioningDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowLevelTTL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowLevelTTL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowLevelTTL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RowLevelTTL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseRegionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseRegionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseRegionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEnumTypeID", wireType)
			}
			m.RegionEnumTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionEnumTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseRoleSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseRoleSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseRoleSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipElements(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowElements
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowElements
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowElements
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthElements
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupElements
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthElements
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthElements        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowElements          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupElements = fmt.Errorf("proto: unexpected end of group")
)
