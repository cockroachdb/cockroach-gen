// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: util/log/eventpb/storage_events.proto

package eventpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	logpb "github.com/cockroachdb/cockroach/pkg/util/log/logpb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// StoreStats contains per store stats.
//
// Note that because stats are scoped to the lifetime of the process, counters
// (and certain gauges) will be reset across node restarts.
type StoreStats struct {
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// node_id is the ID of the node.
	NodeId int32 `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:",omitempty"`
	// store_id is the ID of the store.
	StoreId int32 `protobuf:"varint,3,opt,name=store_id,json=storeId,proto3" json:",omitempty"`
	// levels is a nested message containing per-level statistics.
	Levels []LevelStats `protobuf:"bytes,4,rep,name=levels,proto3" json:""`
	// cache_size is the size of the cache for the store, in bytes (gauge).
	CacheSize int64 `protobuf:"varint,5,opt,name=cache_size,json=cacheSize,proto3" json:",omitempty"`
	// cache_count is the number of items in the cache (gauge).
	CacheCount int64 `protobuf:"varint,6,opt,name=cache_count,json=cacheCount,proto3" json:",omitempty"`
	// cache_hits is the number of cache hits (counter).
	CacheHits int64 `protobuf:"varint,7,opt,name=cache_hits,json=cacheHits,proto3" json:",omitempty"`
	// cache_misses is the number of cache misses (counter).
	CacheMisses int64 `protobuf:"varint,8,opt,name=cache_misses,json=cacheMisses,proto3" json:",omitempty"`
	// compaction_count_default is the count of default compactions (counter).
	CompactionCountDefault int64 `protobuf:"varint,9,opt,name=compaction_count_default,json=compactionCountDefault,proto3" json:",omitempty"`
	// compaction_count_delete_only is the count of delete-only compactions
	// (counter).
	CompactionCountDeleteOnly int64 `protobuf:"varint,10,opt,name=compaction_count_delete_only,json=compactionCountDeleteOnly,proto3" json:",omitempty"`
	// compaction_count_elision_only is the count of elision-only compactions
	// (counter).
	CompactionCountElisionOnly int64 `protobuf:"varint,11,opt,name=compaction_count_elision_only,json=compactionCountElisionOnly,proto3" json:",omitempty"`
	// compaction_count_move is the count of move-compactions (counter).
	CompactionCountMove int64 `protobuf:"varint,12,opt,name=compaction_count_move,json=compactionCountMove,proto3" json:",omitempty"`
	// compaction_count_read is the count of read-compactions (counter).
	CompactionCountRead int64 `protobuf:"varint,13,opt,name=compaction_count_read,json=compactionCountRead,proto3" json:",omitempty"`
	// compaction_count_rewrite is the count of rewrite-compactions (counter).
	CompactionCountRewrite int64 `protobuf:"varint,14,opt,name=compaction_count_rewrite,json=compactionCountRewrite,proto3" json:",omitempty"`
	// compactions_num_in_progress is the number of compactions in progress
	// (gauge).
	CompactionNumInProgress int64 `protobuf:"varint,15,opt,name=compaction_num_in_progress,json=compactionNumInProgress,proto3" json:",omitempty"`
	// compaction_marked_files is the count of files marked for compaction
	// (gauge).
	CompactionMarkedFiles int64 `protobuf:"varint,16,opt,name=compaction_marked_files,json=compactionMarkedFiles,proto3" json:",omitempty"`
	// flush_count is the number of flushes (counter).
	FlushCount int64 `protobuf:"varint,17,opt,name=flush_count,json=flushCount,proto3" json:",omitempty"`
	// memtable_size is the total size allocated to all memtables and (large)
	// batches, in bytes (gauge).
	MemtableSize uint64 `protobuf:"varint,18,opt,name=memtable_size,json=memtableSize,proto3" json:",omitempty"`
	// memtable_count is the count of memtables (gauge).
	MemtableCount int64 `protobuf:"varint,19,opt,name=memtable_count,json=memtableCount,proto3" json:",omitempty"`
	// memtable_zombie_count is the count of memtables no longer referenced by the
	// current DB state, but still in use by an iterator (gauge).
	MemtableZombieCount int64 `protobuf:"varint,20,opt,name=memtable_zombie_count,json=memtableZombieCount,proto3" json:",omitempty"`
	// memtable_zombie_size is the size, in bytes, of all zombie memtables
	// (gauge).
	MemtableZombieSize uint64 `protobuf:"varint,21,opt,name=memtable_zombie_size,json=memtableZombieSize,proto3" json:",omitempty"`
	// wal_live_count is the count of live WAL files (gauge).
	WalLiveCount int64 `protobuf:"varint,22,opt,name=wal_live_count,json=walLiveCount,proto3" json:",omitempty"`
	// wal_live_size is the size, in bytes, of live data in WAL files. With WAL
	// recycling, this value is less than the actual on-disk size of the WAL
	// files (gauge).
	WalLiveSize uint64 `protobuf:"varint,23,opt,name=wal_live_size,json=walLiveSize,proto3" json:",omitempty"`
	// wal_obsolete_count is the count of obsolete WAL files (gauge).
	WalObsoleteCount int64 `protobuf:"varint,24,opt,name=wal_obsolete_count,json=walObsoleteCount,proto3" json:",omitempty"`
	// wal_obsolete_size is the size of obsolete WAL files, in bytes (gauge).
	WalObsoleteSize uint64 `protobuf:"varint,25,opt,name=wal_obsolete_size,json=walObsoleteSize,proto3" json:",omitempty"`
	// wal_physical_size is the size, in bytes, of the WAL files on disk (gauge).
	WalPhysicalSize uint64 `protobuf:"varint,26,opt,name=wal_physical_size,json=walPhysicalSize,proto3" json:",omitempty"`
	// wal_bytes_in is the number of logical bytes written to the WAL (counter).
	WalBytesIn uint64 `protobuf:"varint,27,opt,name=wal_bytes_in,json=walBytesIn,proto3" json:",omitempty"`
	// wal_bytes_written is the number of bytes written to the WAL (counter).
	WalBytesWritten uint64 `protobuf:"varint,28,opt,name=wal_bytes_written,json=walBytesWritten,proto3" json:",omitempty"`
	// table_obsolete_count is the number of tables which are no longer referenced
	// by the current DB state or any open iterators (gauge).
	TableObsoleteCount int64 `protobuf:"varint,29,opt,name=table_obsolete_count,json=tableObsoleteCount,proto3" json:",omitempty"`
	// table_obsolete_size is the size, in bytes, of obsolete tables (gauge).
	TableObsoleteSize uint64 `protobuf:"varint,30,opt,name=table_obsolete_size,json=tableObsoleteSize,proto3" json:",omitempty"`
	// table_zombie_count is the number of tables no longer referenced by the
	// current DB state, but are still in use by an open iterator (gauge).
	TableZombieCount int64 `protobuf:"varint,31,opt,name=table_zombie_count,json=tableZombieCount,proto3" json:",omitempty"`
	// table_zombie_size is the size, in bytes, of zombie tables (gauge).
	TableZombieSize uint64 `protobuf:"varint,32,opt,name=table_zombie_size,json=tableZombieSize,proto3" json:",omitempty"`
	// range_key_sets_count is the approximate count of internal range key sets in
	// the store.
	RangeKeySetsCount uint64 `protobuf:"varint,33,opt,name=range_key_sets_count,json=rangeKeySetsCount,proto3" json:",omitempty"`
}

func (m *StoreStats) Reset()         { *m = StoreStats{} }
func (m *StoreStats) String() string { return proto.CompactTextString(m) }
func (*StoreStats) ProtoMessage()    {}
func (*StoreStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_0f06a89782d7ccac, []int{0}
}
func (m *StoreStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StoreStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreStats.Merge(m, src)
}
func (m *StoreStats) XXX_Size() int {
	return m.Size()
}
func (m *StoreStats) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreStats.DiscardUnknown(m)
}

var xxx_messageInfo_StoreStats proto.InternalMessageInfo

// LevelStats contains per-level statistics for an LSM.
type LevelStats struct {
	// level is the level ID in a LSM (e.g. level(L0) == 0, etc.)
	Level uint32 `protobuf:"varint,1,opt,name=level,proto3" json:",includeempty"`
	// num_files is the number of files in the level (gauge).
	NumFiles int64 `protobuf:"varint,2,opt,name=num_files,json=numFiles,proto3" json:",omitempty"`
	// size_bytes is the size of the level, in bytes (gauge).
	SizeBytes int64 `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:",omitempty"`
	// score is the compaction score of the level (gauge).
	Score float32 `protobuf:"fixed32,4,opt,name=score,proto3" json:",omitempty"`
	// bytes_in is the number of bytes written to this level (counter).
	BytesIn uint64 `protobuf:"varint,5,opt,name=bytes_in,json=bytesIn,proto3" json:",omitempty"`
	// bytes_ingested is the number of bytes ingested into this level (counter).
	BytesIngested uint64 `protobuf:"varint,6,opt,name=bytes_ingested,json=bytesIngested,proto3" json:",omitempty"`
	// bytes_moved is the number of bytes moved into this level via a
	// move-compaction (counter).
	BytesMoved uint64 `protobuf:"varint,7,opt,name=bytes_moved,json=bytesMoved,proto3" json:",omitempty"`
	// bytes_read is the number of bytes read from this level, during compactions
	// (counter).
	BytesRead uint64 `protobuf:"varint,8,opt,name=bytes_read,json=bytesRead,proto3" json:",omitempty"`
	// bytes_compacted is the number of bytes written to this level during
	// compactions (counter).
	BytesCompacted uint64 `protobuf:"varint,9,opt,name=bytes_compacted,json=bytesCompacted,proto3" json:",omitempty"`
	// bytes flushed is the number of bytes flushed to this level. This value is
	// always zero for levels other than L0 (counter).
	BytesFlushed uint64 `protobuf:"varint,10,opt,name=bytes_flushed,json=bytesFlushed,proto3" json:",omitempty"`
	// tables_compacted is the count of tables compacted into this level
	// (counter).
	TablesCompacted uint64 `protobuf:"varint,11,opt,name=tables_compacted,json=tablesCompacted,proto3" json:",omitempty"`
	// tables_flushed is the count of tables flushed into this level (counter).
	TablesFlushed uint64 `protobuf:"varint,12,opt,name=tables_flushed,json=tablesFlushed,proto3" json:",omitempty"`
	// tables_ingested is the count of tables ingested into this level (counter).
	TablesIngested uint64 `protobuf:"varint,13,opt,name=tables_ingested,json=tablesIngested,proto3" json:",omitempty"`
	// tables_moved is the count of tables moved into this level via
	// move-compactions (counter).
	TablesMoved uint64 `protobuf:"varint,14,opt,name=tables_moved,json=tablesMoved,proto3" json:",omitempty"`
	// num_sublevel is the count of sublevels for the level. This value is always
	// zero for levels other than L0 (gauge).
	NumSublevels int32 `protobuf:"varint,15,opt,name=num_sublevels,json=numSublevels,proto3" json:",omitempty"`
}

func (m *LevelStats) Reset()         { *m = LevelStats{} }
func (m *LevelStats) String() string { return proto.CompactTextString(m) }
func (*LevelStats) ProtoMessage()    {}
func (*LevelStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_0f06a89782d7ccac, []int{1}
}
func (m *LevelStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LevelStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LevelStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LevelStats.Merge(m, src)
}
func (m *LevelStats) XXX_Size() int {
	return m.Size()
}
func (m *LevelStats) XXX_DiscardUnknown() {
	xxx_messageInfo_LevelStats.DiscardUnknown(m)
}

var xxx_messageInfo_LevelStats proto.InternalMessageInfo

func init() {
	proto.RegisterType((*StoreStats)(nil), "cockroach.util.log.eventpb.StoreStats")
	proto.RegisterType((*LevelStats)(nil), "cockroach.util.log.eventpb.LevelStats")
}

func init() {
	proto.RegisterFile("util/log/eventpb/storage_events.proto", fileDescriptor_0f06a89782d7ccac)
}

var fileDescriptor_0f06a89782d7ccac = []byte{
	// 1090 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x96, 0xdf, 0x4e, 0x1b, 0x47,
	0x14, 0xc6, 0xbd, 0x80, 0xf9, 0x73, 0xb0, 0x4d, 0x58, 0x20, 0xd9, 0xb8, 0x89, 0xed, 0x46, 0x6d,
	0x43, 0xd4, 0xc4, 0x34, 0xa1, 0x28, 0x6a, 0x54, 0xb5, 0x95, 0x49, 0x10, 0x28, 0x50, 0x52, 0xb8,
	0xa8, 0x94, 0x9b, 0xd5, 0x7a, 0x77, 0x30, 0x2b, 0x66, 0x77, 0xac, 0x9d, 0xb1, 0x91, 0x79, 0x8a,
	0x3e, 0x16, 0x97, 0x5c, 0xe6, 0x0a, 0xb5, 0x70, 0xc7, 0x23, 0x54, 0xaa, 0x54, 0xcd, 0x39, 0xbb,
	0xb6, 0xb1, 0x87, 0x28, 0x77, 0xb6, 0xf6, 0xf7, 0x7d, 0xdf, 0xcc, 0x99, 0xb3, 0x73, 0x16, 0xbe,
	0xed, 0xa8, 0x90, 0xaf, 0x71, 0xd1, 0x5a, 0x63, 0x5d, 0x16, 0xab, 0x76, 0x73, 0x4d, 0x2a, 0x91,
	0x78, 0x2d, 0xe6, 0xe2, 0x7f, 0x59, 0x6f, 0x27, 0x42, 0x09, 0xbb, 0xec, 0x0b, 0xff, 0x24, 0x11,
	0x9e, 0x7f, 0x5c, 0xd7, 0x82, 0x3a, 0x17, 0xad, 0x7a, 0x2a, 0x28, 0x2f, 0xb7, 0x44, 0x4b, 0x20,
	0xb6, 0xa6, 0x7f, 0x91, 0xa2, 0x5c, 0xee, 0x1b, 0x73, 0xd1, 0x6a, 0x37, 0xc9, 0x9e, 0x9e, 0x3d,
	0xf9, 0x6f, 0x01, 0xe0, 0x50, 0x89, 0x84, 0x1d, 0x2a, 0x4f, 0x49, 0x7b, 0x17, 0xa6, 0x7d, 0x11,
	0x45, 0x22, 0x76, 0xac, 0x9a, 0xb5, 0x3a, 0xff, 0xea, 0xbb, 0xba, 0x21, 0x6d, 0x13, 0x89, 0x77,
	0xda, 0xe5, 0x2d, 0x53, 0x5e, 0xc8, 0x65, 0xa3, 0x70, 0x7e, 0x59, 0xcd, 0x5d, 0x5c, 0x56, 0xad,
	0x9b, 0xcb, 0x6a, 0xee, 0x20, 0xf5, 0xb0, 0x9f, 0xc2, 0x4c, 0x2c, 0x02, 0xe6, 0x86, 0x81, 0x33,
	0x51, 0xb3, 0x56, 0xf3, 0x8d, 0xd2, 0xcd, 0x65, 0x15, 0x9e, 0x8b, 0x28, 0x54, 0x2c, 0x6a, 0xab,
	0xde, 0xc1, 0xb4, 0x7e, 0xbc, 0x13, 0xd8, 0xcf, 0x60, 0x56, 0xef, 0x15, 0xc9, 0x49, 0x23, 0x39,
	0x83, 0xcf, 0x77, 0x02, 0x7b, 0x1b, 0xa6, 0x39, 0xeb, 0x32, 0x2e, 0x9d, 0xa9, 0xda, 0xe4, 0x5d,
	0x2b, 0x4c, 0xeb, 0x51, 0xdf, 0xd5, 0x24, 0xee, 0xac, 0x31, 0xab, 0x57, 0x48, 0xab, 0x23, 0xbd,
	0xfd, 0x02, 0xc0, 0xf7, 0xfc, 0x63, 0xe6, 0xca, 0xf0, 0x8c, 0x39, 0xf9, 0x9a, 0xb5, 0x3a, 0x39,
	0x16, 0x3b, 0x87, 0xc4, 0x61, 0x78, 0xc6, 0xec, 0x35, 0x98, 0x27, 0xdc, 0x17, 0x9d, 0x58, 0x39,
	0xd3, 0x46, 0x9e, 0x1c, 0x37, 0x35, 0x31, 0xf0, 0x3f, 0x0e, 0x95, 0x74, 0x66, 0x3e, 0xe3, 0xbf,
	0x1d, 0x2a, 0x69, 0xbf, 0x84, 0x02, 0xe1, 0x51, 0x28, 0x25, 0x93, 0xce, 0xac, 0x51, 0x40, 0x6b,
	0xd8, 0x43, 0xc4, 0xde, 0x06, 0xc7, 0x17, 0x51, 0xdb, 0xf3, 0x55, 0x28, 0x62, 0x5a, 0x97, 0x1b,
	0xb0, 0x23, 0xaf, 0xc3, 0x95, 0x33, 0x67, 0x94, 0xdf, 0x1f, 0xf0, 0xb8, 0xc8, 0xb7, 0x44, 0xdb,
	0xfb, 0xf0, 0xc8, 0xe0, 0xc4, 0x99, 0x62, 0xae, 0x88, 0x79, 0xcf, 0x01, 0xa3, 0xdb, 0xc3, 0x31,
	0x37, 0xad, 0xd8, 0x8f, 0x79, 0xcf, 0xfe, 0x03, 0x1e, 0x8f, 0x19, 0x32, 0x1e, 0x4a, 0xfd, 0x0f,
	0x1d, 0xe7, 0x8d, 0x8e, 0xe5, 0x11, 0xc7, 0x77, 0x24, 0x41, 0xcb, 0x06, 0xac, 0x8c, 0x59, 0x46,
	0xa2, 0xcb, 0x9c, 0x82, 0xd1, 0x6a, 0x69, 0xc4, 0x6a, 0x4f, 0x74, 0x99, 0xd1, 0x23, 0x61, 0x5e,
	0xe0, 0x14, 0xbf, 0xc8, 0xe3, 0x80, 0x79, 0x81, 0xb1, 0xea, 0x09, 0x3b, 0x4d, 0x42, 0xc5, 0x9c,
	0xd2, 0x17, 0x55, 0xfd, 0x80, 0x68, 0xfb, 0x3d, 0x0c, 0xed, 0xd7, 0x8d, 0x3b, 0x91, 0x1b, 0xc6,
	0x6e, 0x3b, 0x11, 0xad, 0x84, 0x49, 0xe9, 0x2c, 0x18, 0xbd, 0x1e, 0x0c, 0x14, 0xbf, 0x77, 0xa2,
	0x9d, 0xf8, 0x43, 0x8a, 0xdb, 0x5b, 0x30, 0xf4, 0xc8, 0x8d, 0xbc, 0xe4, 0x84, 0x05, 0xee, 0x51,
	0xc8, 0x99, 0x74, 0xee, 0x19, 0x9d, 0x86, 0x2a, 0xb1, 0x87, 0xf4, 0x96, 0x86, 0x75, 0x9f, 0x1f,
	0xf1, 0x8e, 0x3c, 0x4e, 0xfb, 0x7c, 0xd1, 0xdc, 0xe7, 0x88, 0x50, 0x9f, 0xaf, 0x43, 0x31, 0x62,
	0x91, 0xf2, 0x9a, 0x3c, 0x7d, 0x95, 0xec, 0x9a, 0xb5, 0x3a, 0x35, 0x26, 0x29, 0x64, 0x10, 0xbe,
	0x4d, 0x1b, 0x50, 0xea, 0x8b, 0x28, 0x68, 0xc9, 0x18, 0xd4, 0xb7, 0xa6, 0xac, 0x06, 0xac, 0xf4,
	0x65, 0x67, 0x22, 0x6a, 0x86, 0x99, 0x7a, 0xd9, 0x7c, 0x7e, 0x19, 0xfc, 0x11, 0x59, 0xf2, 0xf8,
	0x0d, 0x96, 0x47, 0x3d, 0x70, 0xd9, 0x2b, 0xc6, 0x65, 0xdb, 0xb7, 0x2d, 0x70, 0xf1, 0x3f, 0x42,
	0xe9, 0xd4, 0xe3, 0x2e, 0x0f, 0xbb, 0x59, 0xfc, 0x7d, 0x63, 0x7c, 0xe1, 0xd4, 0xe3, 0xbb, 0x61,
	0x37, 0xcd, 0x7d, 0x05, 0xc5, 0xbe, 0x0a, 0x03, 0x1f, 0x18, 0x03, 0xe7, 0x53, 0x11, 0x26, 0xfd,
	0x0c, 0xb6, 0xd6, 0x88, 0xa6, 0x14, 0xf8, 0x32, 0x52, 0x9a, 0x63, 0x4c, 0xbb, 0x77, 0xea, 0xf1,
	0xfd, 0x14, 0xa4, 0xc4, 0x37, 0xb0, 0x78, 0x4b, 0x8d, 0xa9, 0x0f, 0x8d, 0xa9, 0x0b, 0x43, 0x62,
	0x4c, 0x4e, 0xb5, 0xed, 0xe3, 0x9e, 0x0c, 0x7d, 0x8f, 0x93, 0xb6, 0x7c, 0xa7, 0xf6, 0x43, 0xca,
	0xa1, 0xf6, 0x07, 0xd0, 0x3b, 0x77, 0x9b, 0x3d, 0xc5, 0xa4, 0x1b, 0xc6, 0xce, 0x57, 0x46, 0x19,
	0x9c, 0x7a, 0xbc, 0xa1, 0x91, 0x9d, 0x38, 0x4b, 0x23, 0x85, 0x7e, 0x39, 0x14, 0x8b, 0x9d, 0x47,
	0x77, 0xa6, 0xa1, 0xec, 0x4f, 0xc2, 0xf4, 0x79, 0xd2, 0x61, 0x8e, 0x54, 0xe9, 0xb1, 0xb1, 0x4a,
	0x36, 0xb2, 0xb7, 0xeb, 0xf4, 0x0b, 0x2c, 0x8d, 0x38, 0xe0, 0x6e, 0x2b, 0xc6, 0xfc, 0xc5, 0x5b,
	0x06, 0xd9, 0x29, 0x19, 0x5a, 0xb2, 0x6a, 0x3e, 0xa5, 0xb1, 0x7e, 0x7c, 0x03, 0x8b, 0xe3, 0xcd,
	0x58, 0x33, 0xef, 0x7d, 0xb4, 0x13, 0x7f, 0x85, 0xe5, 0xc4, 0x8b, 0x5b, 0xcc, 0x3d, 0x61, 0x3d,
	0x57, 0x32, 0x25, 0xd3, 0xec, 0xaf, 0xcd, 0x4b, 0x47, 0xf6, 0x3d, 0xeb, 0x1d, 0x32, 0x25, 0x31,
	0xfc, 0xc9, 0xbf, 0x79, 0x80, 0xc1, 0x94, 0xb4, 0x9f, 0x42, 0x1e, 0xa7, 0x23, 0x8e, 0xff, 0x62,
	0x63, 0xf1, 0xe6, 0xb2, 0x5a, 0x7c, 0x1e, 0xc6, 0x3e, 0xef, 0x04, 0x8c, 0x3c, 0xe8, 0xb9, 0xfd,
	0x3d, 0xcc, 0xe9, 0xfb, 0x8a, 0xee, 0x97, 0x09, 0xe3, 0x4e, 0x67, 0xe3, 0x4e, 0x44, 0x57, 0xca,
	0x0b, 0x00, 0xbd, 0x29, 0x3a, 0x5e, 0x1c, 0xf0, 0x86, 0x49, 0xa8, 0x09, 0x3c, 0x57, 0xfb, 0x1b,
	0xc8, 0x4b, 0x5f, 0x24, 0xcc, 0x99, 0xaa, 0x59, 0xab, 0x13, 0x63, 0x24, 0x3d, 0xd4, 0xdf, 0x0c,
	0xfd, 0x06, 0xcb, 0x1b, 0xb7, 0x3b, 0xd3, 0x4c, 0xbb, 0x6b, 0x03, 0x4a, 0x19, 0xda, 0x62, 0x52,
	0xb1, 0x00, 0xa7, 0xf7, 0xb8, 0xa0, 0x98, 0x0a, 0x08, 0xd2, 0x37, 0x21, 0xc9, 0xf4, 0x94, 0x09,
	0x70, 0x82, 0x1b, 0xba, 0x18, 0x11, 0x3d, 0x5c, 0x02, 0xbd, 0x4f, 0x12, 0xe0, 0x48, 0x99, 0x35,
	0xf2, 0x73, 0x48, 0xe0, 0x20, 0x79, 0x0d, 0x0b, 0x84, 0xa7, 0x17, 0x31, 0x0b, 0x70, 0x6a, 0x8f,
	0x6b, 0x68, 0xf5, 0x9b, 0x19, 0xa5, 0x6f, 0x5c, 0x12, 0xe2, 0x2d, 0xcc, 0x02, 0x1c, 0xcf, 0x86,
	0x1b, 0x17, 0xa1, 0x2d, 0x62, 0xec, 0x9f, 0x80, 0x5a, 0x6f, 0x38, 0x6e, 0xfe, 0x33, 0x5d, 0x36,
	0x94, 0xb7, 0x01, 0xa5, 0x54, 0x9a, 0x05, 0x16, 0xcc, 0xf5, 0x23, 0x2a, 0x4b, 0x7c, 0x0d, 0xa9,
	0xd3, 0xa0, 0xee, 0x45, 0xf3, 0xfe, 0x08, 0xeb, 0x17, 0xfe, 0x25, 0x14, 0x52, 0x21, 0x55, 0xbe,
	0x64, 0xbe, 0x28, 0x89, 0xa1, 0xd2, 0xaf, 0x43, 0x51, 0xf7, 0xa3, 0xec, 0x34, 0xd3, 0xaf, 0xc3,
	0x05, 0xe3, 0x67, 0x64, 0x21, 0xee, 0x44, 0x87, 0x19, 0xd3, 0x78, 0x76, 0xfe, 0x4f, 0x25, 0x77,
	0x7e, 0x55, 0xb1, 0x2e, 0xae, 0x2a, 0xd6, 0xa7, 0xab, 0x8a, 0xf5, 0xf7, 0x55, 0xc5, 0xfa, 0xeb,
	0xba, 0x92, 0xbb, 0xb8, 0xae, 0xe4, 0x3e, 0x5d, 0x57, 0x72, 0x1f, 0x67, 0xd2, 0x2f, 0xc9, 0xe6,
	0x34, 0x7e, 0x2e, 0xaf, 0xff, 0x1f, 0x00, 0x00, 0xff, 0xff, 0xf4, 0xac, 0xa2, 0x90, 0xa5, 0x0b,
	0x00, 0x00,
}

func (m *StoreStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeKeySetsCount != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.RangeKeySetsCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.TableZombieSize != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.TableZombieSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.TableZombieCount != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.TableZombieCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.TableObsoleteSize != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.TableObsoleteSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.TableObsoleteCount != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.TableObsoleteCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.WalBytesWritten != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.WalBytesWritten))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.WalBytesIn != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.WalBytesIn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.WalPhysicalSize != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.WalPhysicalSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.WalObsoleteSize != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.WalObsoleteSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.WalObsoleteCount != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.WalObsoleteCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.WalLiveSize != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.WalLiveSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.WalLiveCount != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.WalLiveCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.MemtableZombieSize != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.MemtableZombieSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.MemtableZombieCount != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.MemtableZombieCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.MemtableCount != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.MemtableCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.MemtableSize != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.MemtableSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.FlushCount != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.FlushCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.CompactionMarkedFiles != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CompactionMarkedFiles))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CompactionNumInProgress != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CompactionNumInProgress))
		i--
		dAtA[i] = 0x78
	}
	if m.CompactionCountRewrite != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CompactionCountRewrite))
		i--
		dAtA[i] = 0x70
	}
	if m.CompactionCountRead != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CompactionCountRead))
		i--
		dAtA[i] = 0x68
	}
	if m.CompactionCountMove != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CompactionCountMove))
		i--
		dAtA[i] = 0x60
	}
	if m.CompactionCountElisionOnly != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CompactionCountElisionOnly))
		i--
		dAtA[i] = 0x58
	}
	if m.CompactionCountDeleteOnly != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CompactionCountDeleteOnly))
		i--
		dAtA[i] = 0x50
	}
	if m.CompactionCountDefault != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CompactionCountDefault))
		i--
		dAtA[i] = 0x48
	}
	if m.CacheMisses != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CacheMisses))
		i--
		dAtA[i] = 0x40
	}
	if m.CacheHits != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CacheHits))
		i--
		dAtA[i] = 0x38
	}
	if m.CacheCount != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CacheCount))
		i--
		dAtA[i] = 0x30
	}
	if m.CacheSize != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.CacheSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Levels) > 0 {
		for iNdEx := len(m.Levels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Levels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStorageEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.StoreId != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x18
	}
	if m.NodeId != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStorageEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LevelStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LevelStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LevelStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumSublevels != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.NumSublevels))
		i--
		dAtA[i] = 0x78
	}
	if m.TablesMoved != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.TablesMoved))
		i--
		dAtA[i] = 0x70
	}
	if m.TablesIngested != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.TablesIngested))
		i--
		dAtA[i] = 0x68
	}
	if m.TablesFlushed != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.TablesFlushed))
		i--
		dAtA[i] = 0x60
	}
	if m.TablesCompacted != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.TablesCompacted))
		i--
		dAtA[i] = 0x58
	}
	if m.BytesFlushed != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.BytesFlushed))
		i--
		dAtA[i] = 0x50
	}
	if m.BytesCompacted != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.BytesCompacted))
		i--
		dAtA[i] = 0x48
	}
	if m.BytesRead != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x40
	}
	if m.BytesMoved != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.BytesMoved))
		i--
		dAtA[i] = 0x38
	}
	if m.BytesIngested != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.BytesIngested))
		i--
		dAtA[i] = 0x30
	}
	if m.BytesIn != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.BytesIn))
		i--
		dAtA[i] = 0x28
	}
	if m.Score != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Score))))
		i--
		dAtA[i] = 0x25
	}
	if m.SizeBytes != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.NumFiles != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.NumFiles))
		i--
		dAtA[i] = 0x10
	}
	if m.Level != 0 {
		i = encodeVarintStorageEvents(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStorageEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovStorageEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StoreStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovStorageEvents(uint64(l))
	if m.NodeId != 0 {
		n += 1 + sovStorageEvents(uint64(m.NodeId))
	}
	if m.StoreId != 0 {
		n += 1 + sovStorageEvents(uint64(m.StoreId))
	}
	if len(m.Levels) > 0 {
		for _, e := range m.Levels {
			l = e.Size()
			n += 1 + l + sovStorageEvents(uint64(l))
		}
	}
	if m.CacheSize != 0 {
		n += 1 + sovStorageEvents(uint64(m.CacheSize))
	}
	if m.CacheCount != 0 {
		n += 1 + sovStorageEvents(uint64(m.CacheCount))
	}
	if m.CacheHits != 0 {
		n += 1 + sovStorageEvents(uint64(m.CacheHits))
	}
	if m.CacheMisses != 0 {
		n += 1 + sovStorageEvents(uint64(m.CacheMisses))
	}
	if m.CompactionCountDefault != 0 {
		n += 1 + sovStorageEvents(uint64(m.CompactionCountDefault))
	}
	if m.CompactionCountDeleteOnly != 0 {
		n += 1 + sovStorageEvents(uint64(m.CompactionCountDeleteOnly))
	}
	if m.CompactionCountElisionOnly != 0 {
		n += 1 + sovStorageEvents(uint64(m.CompactionCountElisionOnly))
	}
	if m.CompactionCountMove != 0 {
		n += 1 + sovStorageEvents(uint64(m.CompactionCountMove))
	}
	if m.CompactionCountRead != 0 {
		n += 1 + sovStorageEvents(uint64(m.CompactionCountRead))
	}
	if m.CompactionCountRewrite != 0 {
		n += 1 + sovStorageEvents(uint64(m.CompactionCountRewrite))
	}
	if m.CompactionNumInProgress != 0 {
		n += 1 + sovStorageEvents(uint64(m.CompactionNumInProgress))
	}
	if m.CompactionMarkedFiles != 0 {
		n += 2 + sovStorageEvents(uint64(m.CompactionMarkedFiles))
	}
	if m.FlushCount != 0 {
		n += 2 + sovStorageEvents(uint64(m.FlushCount))
	}
	if m.MemtableSize != 0 {
		n += 2 + sovStorageEvents(uint64(m.MemtableSize))
	}
	if m.MemtableCount != 0 {
		n += 2 + sovStorageEvents(uint64(m.MemtableCount))
	}
	if m.MemtableZombieCount != 0 {
		n += 2 + sovStorageEvents(uint64(m.MemtableZombieCount))
	}
	if m.MemtableZombieSize != 0 {
		n += 2 + sovStorageEvents(uint64(m.MemtableZombieSize))
	}
	if m.WalLiveCount != 0 {
		n += 2 + sovStorageEvents(uint64(m.WalLiveCount))
	}
	if m.WalLiveSize != 0 {
		n += 2 + sovStorageEvents(uint64(m.WalLiveSize))
	}
	if m.WalObsoleteCount != 0 {
		n += 2 + sovStorageEvents(uint64(m.WalObsoleteCount))
	}
	if m.WalObsoleteSize != 0 {
		n += 2 + sovStorageEvents(uint64(m.WalObsoleteSize))
	}
	if m.WalPhysicalSize != 0 {
		n += 2 + sovStorageEvents(uint64(m.WalPhysicalSize))
	}
	if m.WalBytesIn != 0 {
		n += 2 + sovStorageEvents(uint64(m.WalBytesIn))
	}
	if m.WalBytesWritten != 0 {
		n += 2 + sovStorageEvents(uint64(m.WalBytesWritten))
	}
	if m.TableObsoleteCount != 0 {
		n += 2 + sovStorageEvents(uint64(m.TableObsoleteCount))
	}
	if m.TableObsoleteSize != 0 {
		n += 2 + sovStorageEvents(uint64(m.TableObsoleteSize))
	}
	if m.TableZombieCount != 0 {
		n += 2 + sovStorageEvents(uint64(m.TableZombieCount))
	}
	if m.TableZombieSize != 0 {
		n += 2 + sovStorageEvents(uint64(m.TableZombieSize))
	}
	if m.RangeKeySetsCount != 0 {
		n += 2 + sovStorageEvents(uint64(m.RangeKeySetsCount))
	}
	return n
}

func (m *LevelStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovStorageEvents(uint64(m.Level))
	}
	if m.NumFiles != 0 {
		n += 1 + sovStorageEvents(uint64(m.NumFiles))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovStorageEvents(uint64(m.SizeBytes))
	}
	if m.Score != 0 {
		n += 5
	}
	if m.BytesIn != 0 {
		n += 1 + sovStorageEvents(uint64(m.BytesIn))
	}
	if m.BytesIngested != 0 {
		n += 1 + sovStorageEvents(uint64(m.BytesIngested))
	}
	if m.BytesMoved != 0 {
		n += 1 + sovStorageEvents(uint64(m.BytesMoved))
	}
	if m.BytesRead != 0 {
		n += 1 + sovStorageEvents(uint64(m.BytesRead))
	}
	if m.BytesCompacted != 0 {
		n += 1 + sovStorageEvents(uint64(m.BytesCompacted))
	}
	if m.BytesFlushed != 0 {
		n += 1 + sovStorageEvents(uint64(m.BytesFlushed))
	}
	if m.TablesCompacted != 0 {
		n += 1 + sovStorageEvents(uint64(m.TablesCompacted))
	}
	if m.TablesFlushed != 0 {
		n += 1 + sovStorageEvents(uint64(m.TablesFlushed))
	}
	if m.TablesIngested != 0 {
		n += 1 + sovStorageEvents(uint64(m.TablesIngested))
	}
	if m.TablesMoved != 0 {
		n += 1 + sovStorageEvents(uint64(m.TablesMoved))
	}
	if m.NumSublevels != 0 {
		n += 1 + sovStorageEvents(uint64(m.NumSublevels))
	}
	return n
}

func sovStorageEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStorageEvents(x uint64) (n int) {
	return sovStorageEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StoreStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStorageEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Levels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStorageEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Levels = append(m.Levels, LevelStats{})
			if err := m.Levels[len(m.Levels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			m.CacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheCount", wireType)
			}
			m.CacheCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheHits", wireType)
			}
			m.CacheHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheHits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheMisses", wireType)
			}
			m.CacheMisses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheMisses |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionCountDefault", wireType)
			}
			m.CompactionCountDefault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionCountDefault |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionCountDeleteOnly", wireType)
			}
			m.CompactionCountDeleteOnly = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionCountDeleteOnly |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionCountElisionOnly", wireType)
			}
			m.CompactionCountElisionOnly = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionCountElisionOnly |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionCountMove", wireType)
			}
			m.CompactionCountMove = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionCountMove |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionCountRead", wireType)
			}
			m.CompactionCountRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionCountRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionCountRewrite", wireType)
			}
			m.CompactionCountRewrite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionCountRewrite |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionNumInProgress", wireType)
			}
			m.CompactionNumInProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionNumInProgress |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionMarkedFiles", wireType)
			}
			m.CompactionMarkedFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionMarkedFiles |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushCount", wireType)
			}
			m.FlushCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlushCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemtableSize", wireType)
			}
			m.MemtableSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemtableSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemtableCount", wireType)
			}
			m.MemtableCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemtableCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemtableZombieCount", wireType)
			}
			m.MemtableZombieCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemtableZombieCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemtableZombieSize", wireType)
			}
			m.MemtableZombieSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemtableZombieSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalLiveCount", wireType)
			}
			m.WalLiveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalLiveCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalLiveSize", wireType)
			}
			m.WalLiveSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalLiveSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalObsoleteCount", wireType)
			}
			m.WalObsoleteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalObsoleteCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalObsoleteSize", wireType)
			}
			m.WalObsoleteSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalObsoleteSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalPhysicalSize", wireType)
			}
			m.WalPhysicalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalPhysicalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalBytesIn", wireType)
			}
			m.WalBytesIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalBytesIn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalBytesWritten", wireType)
			}
			m.WalBytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalBytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableObsoleteCount", wireType)
			}
			m.TableObsoleteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableObsoleteCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableObsoleteSize", wireType)
			}
			m.TableObsoleteSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableObsoleteSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableZombieCount", wireType)
			}
			m.TableZombieCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableZombieCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableZombieSize", wireType)
			}
			m.TableZombieSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableZombieSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeySetsCount", wireType)
			}
			m.RangeKeySetsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeKeySetsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStorageEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LevelStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LevelStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LevelStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFiles", wireType)
			}
			m.NumFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFiles |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIn", wireType)
			}
			m.BytesIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesIn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIngested", wireType)
			}
			m.BytesIngested = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesIngested |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesMoved", wireType)
			}
			m.BytesMoved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesMoved |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesCompacted", wireType)
			}
			m.BytesCompacted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesCompacted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesFlushed", wireType)
			}
			m.BytesFlushed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesFlushed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablesCompacted", wireType)
			}
			m.TablesCompacted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TablesCompacted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablesFlushed", wireType)
			}
			m.TablesFlushed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TablesFlushed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablesIngested", wireType)
			}
			m.TablesIngested = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TablesIngested |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablesMoved", wireType)
			}
			m.TablesMoved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TablesMoved |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSublevels", wireType)
			}
			m.NumSublevels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSublevels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStorageEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStorageEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStorageEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorageEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStorageEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStorageEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStorageEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStorageEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStorageEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStorageEvents = fmt.Errorf("proto: unexpected end of group")
)
